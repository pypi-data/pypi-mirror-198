{"version":3,"file":"chunks/vendors-node_modules_dnd-kit_accessibility_dist_accessibility_esm_js-node_modules_react-grid--85d690.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///../node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js","webpack:///../node_modules/react-grid-layout/build/utils.js"],"sourcesContent":["import React, { useState, useCallback } from 'react';\n\nconst hiddenStyles = {\n  display: 'none'\n};\nfunction HiddenText({\n  id,\n  value\n}) {\n  return React.createElement(\"div\", {\n    id: id,\n    style: hiddenStyles\n  }, value);\n}\n\nconst visuallyHidden = {\n  position: 'absolute',\n  width: 1,\n  height: 1,\n  margin: -1,\n  border: 0,\n  padding: 0,\n  overflow: 'hidden',\n  clip: 'rect(0 0 0 0)',\n  clipPath: 'inset(100%)',\n  whiteSpace: 'nowrap'\n};\nfunction LiveRegion({\n  id,\n  announcement\n}) {\n  return React.createElement(\"div\", {\n    id: id,\n    style: visuallyHidden,\n    role: \"status\",\n    \"aria-live\": \"assertive\",\n    \"aria-atomic\": true\n  }, announcement);\n}\n\nfunction useAnnouncement() {\n  const [announcement, setAnnouncement] = useState('');\n  const announce = useCallback(value => {\n    if (value != null) {\n      setAnnouncement(value);\n    }\n  }, []);\n  return {\n    announce,\n    announcement\n  };\n}\n\nexport { HiddenText, LiveRegion, useAnnouncement };\n//# sourceMappingURL=accessibility.esm.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\n\nvar _lodash = _interopRequireDefault(require(\"lodash.isequal\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar isProduction = process.env.NODE_ENV === \"production\";\nvar DEBUG = false;\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\n\nfunction bottom(layout\n/*: Layout*/\n)\n/*: number*/\n{\n  var max = 0,\n      bottomY;\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n\n  return max;\n}\n\nfunction cloneLayout(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\n\n\nfunction modifyLayout(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n\n  return newLayout;\n} // Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\n\n\nfunction withLayoutItem(layout\n/*: Layout*/\n, itemKey\n/*: string*/\n, cb\n/*: LayoutItem => LayoutItem*/\n)\n/*: [Layout, ?LayoutItem]*/\n{\n  var item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n} // Fast path to cloning, since this is monomorphic\n\n\nfunction cloneLayoutItem(layoutItem\n/*: LayoutItem*/\n)\n/*: LayoutItem*/\n{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\n\n\nfunction childrenEqual(a\n/*: ReactChildren*/\n, b\n/*: ReactChildren*/\n)\n/*: boolean*/\n{\n  return (0, _lodash.default)(_react.default.Children.map(a, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }), _react.default.Children.map(b, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }));\n}\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\n\n\nvar fastRGLPropsEqual\n/*: FastRGLPropsEqual*/\n= require(\"./fastRGLPropsEqual\"); // Like the above, but a lot simpler.\n\n\nexports.fastRGLPropsEqual = fastRGLPropsEqual;\n\nfunction fastPositionEqual(a\n/*: Position*/\n, b\n/*: Position*/\n)\n/*: boolean*/\n{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n/**\n * Given two layoutitems, check if they collide.\n */\n\n\nfunction collides(l1\n/*: LayoutItem*/\n, l2\n/*: LayoutItem*/\n)\n/*: boolean*/\n{\n  if (l1.i === l2.i) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\n\n\nfunction compact(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  var out = Array(layout.length);\n\n  for (var i = 0, len = sorted.length; i < len; i++) {\n    var l = cloneLayoutItem(sorted[i]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n\nvar heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\n\nfunction resolveCompactionCollision(layout\n/*: Layout*/\n, item\n/*: LayoutItem*/\n, moveToCoord\n/*: number*/\n, axis\n/*: \"x\" | \"y\"*/\n) {\n  var sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  var itemIndex = layout.map(function (layoutItem) {\n    return layoutItem.i;\n  }).indexOf(item.i); // Go through each item we collide with.\n\n  for (var i = itemIndex + 1; i < layout.length; i++) {\n    var otherItem = layout[i]; // Ignore static items\n\n    if (otherItem.static) continue; // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\n\n\nfunction compactItem(compareWith\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, fullLayout\n/*: Layout*/\n)\n/*: LayoutItem*/\n{\n  var compactV = compactType === \"vertical\";\n  var compactH = compactType === \"horizontal\";\n\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  var collides;\n\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  } // Ensure that there are no negative positions\n\n\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\n\n\nfunction correctBounds(layout\n/*: Layout*/\n, bounds\n/*: { cols: number }*/\n)\n/*: Layout*/\n{\n  var collidesWith = getStatics(layout);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\n\n\nfunction getLayoutItem(layout\n/*: Layout*/\n, id\n/*: string*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\n\n\nfunction getFirstCollision(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\n\nfunction getAllCollisions(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\n\n\nfunction getStatics(layout\n/*: Layout*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\n\n\nfunction moveElement(layout\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, x\n/*: ?number*/\n, y\n/*: ?number*/\n, isUserAction\n/*: ?boolean*/\n, preventCollision\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout; // Short-circuit if nothing to do.\n\n  if (l.y === y && l.x === x) return layout;\n  log(\"Moving element \".concat(l.i, \" to [\").concat(String(x), \",\").concat(String(y), \"] from [\").concat(l.x, \",\").concat(l.y, \"]\"));\n  var oldX = l.x;\n  var oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItems(layout, compactType);\n  var movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false; // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l);\n  var hasCollisions = collisions.length > 0; // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(\"Collision prevented on \".concat(l.i, \", reverting.\"));\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  } // Move each item that collides away from this element.\n\n\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    var collision = collisions[i];\n    log(\"Resolving collision between \".concat(l.i, \" at [\").concat(l.x, \",\").concat(l.y, \"] and \").concat(collision.i, \" at [\").concat(collision.x, \",\").concat(collision.y, \"]\")); // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n\n  return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\n\n\nfunction moveElementAwayFromCollision(layout\n/*: Layout*/\n, collidesWith\n/*: LayoutItem*/\n, itemToMove\n/*: LayoutItem*/\n, isUserAction\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  var compactH = compactType === \"horizontal\"; // Compact vertically if not set to horizontal\n\n  var compactV = compactType !== \"horizontal\";\n  var preventCollision = collidesWith.static; // we're already colliding (not for static items)\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    var fakeItem\n    /*: LayoutItem*/\n    = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(\"Doing reverse collision on \".concat(itemToMove.i, \" up to [\").concat(fakeItem.x, \",\").concat(fakeItem.y, \"].\"));\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\n\n\nfunction perc(num\n/*: number*/\n)\n/*: string*/\n{\n  return num * 100 + \"%\";\n}\n\nfunction setTransform(_ref)\n/*: Object*/\n{\n  var top = _ref.top,\n      left = _ref.left,\n      width = _ref.width,\n      height = _ref.height;\n  // Replace unitless items with px\n  var translate = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n\nfunction setTopLeft(_ref2)\n/*: Object*/\n{\n  var top = _ref2.top,\n      left = _ref2.left,\n      width = _ref2.width,\n      height = _ref2.height;\n  return {\n    top: \"\".concat(top, \"px\"),\n    left: \"\".concat(left, \"px\"),\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\n\n\nfunction sortLayoutItems(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n)\n/*: Layout*/\n{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByRowCol(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n\n    return -1;\n  });\n}\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByColRow(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\n\n\nfunction synchronizeLayoutWithChildren(initialLayout\n/*: Layout*/\n, children\n/*: ReactChildren*/\n, cols\n/*: number*/\n, compactType\n/*: CompactType*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  initialLayout = initialLayout || []; // Generate one layout item per child.\n\n  var layout\n  /*: LayoutItem[]*/\n  = [];\n\n  _react.default.Children.forEach(children, function (child\n  /*: ReactElement<any>*/\n  ) {\n    // Child may not exist\n    if ((child === null || child === void 0 ? void 0 : child.key) == null) return; // Don't overwrite if it already exists.\n\n    var exists = getLayoutItem(initialLayout, String(child.key));\n\n    if (exists) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      if (!isProduction && child.props._grid) {\n        console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. \" + \"Please use `data-grid` or add your properties directly to the `layout`.\");\n      }\n\n      var g = child.props[\"data-grid\"] || child.props._grid; // Hey, this item has a data-grid property, use it.\n\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        } // FIXME clone not really necessary here\n\n\n        layout.push(cloneLayoutItem(_objectSpread(_objectSpread({}, g), {}, {\n          i: child.key\n        })));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  }); // Correct the layout.\n\n\n  var correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\n\n\nfunction validateLayout(layout\n/*: Layout*/\n)\n/*: void*/\n{\n  var contextName\n  /*: string*/\n  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  var subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var item = layout[i];\n\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n  }\n} // Legacy support for verticalCompact: false\n\n\nfunction compactType(props\n/*: ?{ verticalCompact: boolean, compactType: CompactType }*/\n)\n/*: CompactType*/\n{\n  var _ref3 = props || {},\n      verticalCompact = _ref3.verticalCompact,\n      compactType = _ref3.compactType;\n\n  return verticalCompact === false ? null : compactType;\n}\n\nfunction log() {\n  var _console;\n\n  if (!DEBUG) return; // eslint-disable-next-line no-console\n\n  (_console = console).log.apply(_console, arguments);\n}\n\nvar noop = function noop() {};\n\nexports.noop = noop;"],"names":["hiddenStyles","display","HiddenText","id","value","style","visuallyHidden","position","width","height","margin","border","padding","overflow","clip","clipPath","whiteSpace","LiveRegion","announcement","role","useAnnouncement","setAnnouncement","useState","announce","useCallback","Object","defineProperty","exports","bottom","childrenEqual","a","b","_lodash","default","_react","Children","map","c","key","cloneLayout","cloneLayoutItem","collides","compact","compactItem","compactType","props","_ref3","verticalCompact","correctBounds","fastPositionEqual","left","top","fastRGLPropsEqual","getAllCollisions","getFirstCollision","getLayoutItem","getStatics","modifyLayout","moveElement","moveElementAwayFromCollision","noop","perc","num","setTopLeft","_ref2","concat","setTransform","_ref","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","sortLayoutItems","sortLayoutItemsByColRow","sortLayoutItemsByRowCol","synchronizeLayoutWithChildren","initialLayout","children","cols","allowOverlap","layout","forEach","child","exists","String","push","g","_grid","_objectSpread","i","w","h","x","y","correctedLayout","validateLayout","contextName","arguments","length","undefined","subProps","Array","isArray","Error","len","item","j","withLayoutItem","itemKey","cb","_interopRequireDefault","obj","__esModule","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","apply","target","source","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","bottomY","max","newLayout","layoutItem","minW","maxW","minH","maxH","moved","Boolean","static","isDraggable","isResizable","resizeHandles","isBounded","l1","l2","compareWith","sorted","out","l","indexOf","heightWidth","resolveCompactionCollision","moveToCoord","axis","sizeProp","otherItem","fullLayout","compactH","Math","min","bounds","collidesWith","isUserAction","preventCollision","oldX","oldY","reverse","collisions","hasCollisions","collision","itemToMove","compactV","fakeItem","slice","sort"],"sourceRoot":""}