{"version":3,"file":"chunks/app_views_issueDetails_groupMerged_index_tsx.xxxxxxxxxxxxxxxxxxxx.js","mappings":"gkBAiBA,MA+KMA,EAAuC,CAC3CC,IAAK,IAAIC,EAAAA,GAETC,OAIE,MAAMC,EAAQC,KAAKC,kBAEnBC,OAAOC,QAAQJ,GAAOK,SAAQC,IAAkB,IAAhBC,EAAKC,GAAMF,EACzCL,KAAKM,GAAOC,CAAK,GAErB,EAEAN,gBAAeA,KACN,CAELO,YAAa,GAEbC,YAAa,IAAIC,IAEjBC,aAAc,IAAID,IAElBE,iBAAiB,EAEjBC,sBAAsB,EAEtBC,0BAA0B,EAC1BC,aAAc,GACdC,qBAAsB,GACtBC,aAAc,GACdC,WAAY,IAAIR,IAChBS,UAAW,GACXC,YAAa,GACbC,eAAe,EACfC,SAAS,EACTC,OAAO,IAIXC,cAAaA,CAACC,EAAKC,EAASC,KACdC,EAAAA,EAAAA,GAAQF,GAETD,KAAII,IACb,MACMC,EAAc,IADLL,EAAIM,IAAIF,IAAOJ,EAAIO,IAAIH,IAAQ,CAAC,KACbF,GAElC,OADAF,EAAIQ,IAAIJ,EAAIC,GACLA,CAAW,IAItBI,wBACE,MAAMC,EACHC,MAAMC,KAAKrC,KAAKW,aAAa2B,UAA6BC,QACzDC,IAAA,IAAC,KAACC,GAAKD,EAAA,OAAKC,CAAI,KACb,GACP,OACEzC,KAAKS,YAAYiC,OACjB1C,KAAKQ,YAAY+B,QAAOI,IAAA,IAAC,YAACC,GAAYD,EAAA,QAAOC,CAAW,IAAEC,OACxDV,EAAYU,MAElB,EAGAC,QAAQC,GACN,MAAMC,EAAWD,GAAgB/C,KAAK+C,aAGtC/C,KAAKF,OACLE,KAAKiD,oBAEL,MAAMC,EAAWF,EAASvB,KACxB0B,IAAA,IAAC,SAACC,EAAQ,YAAEC,EAAW,QAAEC,GAAQH,EAAA,OAC/B,IAAII,SAAQ,CAACC,EAASC,KACpBzD,KAAKJ,IAAI8D,QAAQN,EAAU,CACzBO,OAAQ,MACRC,KAAMP,EACNQ,QAASA,CAACD,EAAME,EAAGC,KACjBP,EAAQ,CACNF,UACAM,OACAI,MAAOD,EAAOA,EAAKE,kBAAkB,QAAU,MAC/C,EAEJ1C,MAAO2C,IACL,MAAM3C,EAAQ2C,EAAIC,cAAcC,SAAU,EAC1CX,EAAOlC,EAAM,GAEf,GACF,IAGA8C,EAAyC,CAC7CC,OAAQC,IACN,MAAMC,EAA2C,CAAC,EAC5CC,EAA0B,GAuChC,OArCAF,EAAMnE,SAAQsE,IACZ,IAAKF,EAAYE,EAAK7C,IAAK,CACzB,MAAM8C,EAAU,CACdC,WAAY,EACZC,SAAU,MAIPH,GAGL1E,KAAKwB,cAAcxB,KAAKW,aAAc+D,EAAK7C,GAAI,CAC7CY,KAAqB,WAAfiC,EAAK3E,QAGbyE,EAAYE,EAAK7C,IAAM8C,EACvBF,EAASK,KAAKH,EAChB,CAEA,MAAMA,EAAUH,EAAYE,EAAK7C,KAC3B,QAACkD,EAAO,WAAEC,EAAU,WAAEJ,EAAU,SAAEK,EAAQ,YAAErC,GAAe8B,EAE7DE,IACFD,EAAQC,YAAcA,GAGpBG,GACFJ,EAAQE,SAASC,KAAK,CACpBC,UACAC,aACAC,WACArC,cACAgC,cAEJ,IAGKH,CAAQ,EAEjBS,QAASC,IAAuB,IAArBC,EAAOC,GAASF,EAEzB,MAAMG,EAtTc,WAAiB,IAAhBC,EAAMC,UAAA3C,OAAA,QAAA4C,IAAAD,UAAA,GAAAA,UAAA,GAAG,CAAC,EAErC,OADkBtF,OAAOwF,KAAKH,GACZ9D,KAAInB,GAAOiF,EAAOjF,KAAMqF,MAAKC,GAASA,GALxC,IAMlB,CAmTiCC,CAAoBR,GAKvCS,EAAoB5F,OAAOwF,KAAKL,GACnC5D,KAAIsE,GAAY,CAACA,EAAUV,EAASU,MACpCC,QAAO,CAACC,EAAGC,KAAwB,IAArBH,EAAUH,GAAMM,EAE7B,MAAOC,GAAiBC,OAAOL,GAAUM,MAAM,KAO/C,OALKJ,EAAIE,KACPF,EAAIE,GAAiB,IAEvBF,EAAIE,GAAerB,KAAK,CAACiB,EAAUH,IAE5BK,CAAG,GACT,CAAC,GAGAK,EAAYpG,OAAOwF,KAAKI,GAC3BrE,KAAI0E,GAAiB,CAACA,EAAeL,EAAkBK,MACvDH,QAAO,CAACC,EAAGM,KAAiC,IAA9BJ,EAAeK,GAAUD,EAGtC,MAAMhB,EAASiB,EAAUjE,QAAOkE,IAAA,IAAE,CAAEb,GAAMa,EAAA,OAAe,OAAVb,CAAc,IAEvDc,EAAMnB,EAAOS,QAAO,CAACW,EAAGC,KAAA,IAAG,CAAEhB,GAAMgB,EAAA,OAAKD,EAAMf,CAAK,GAAE,GAAKL,EAAO1C,OAGvE,OADAoD,EAAIE,GAAiBO,EACdT,CAAG,GACT,CAAC,GAEN,MAAO,CACLb,QACAQ,MAAOP,EACPS,oBACAQ,YACAhB,mBACD,GAQL,OAJIvC,IACF/C,KAAK+C,aAAeA,GAGfQ,QAAQsD,IAAI3D,GAAU4D,MAC3BC,IACGA,EAAgC3G,SAAQ4G,IAA4B,IAA3B,QAAC1D,EAAO,KAAEM,EAAI,MAAEI,GAAMgD,EAC9D,MAAMzC,EACQ,YAAZjB,EACKM,EAAmCnC,IAAI4C,EAAmBf,IAC3De,EAAmBf,GAASM,GAElC5D,KAAM,GAAEsD,UAAkBiB,EAC1BvE,KAAM,GAAEsD,UAAkBU,CAAK,IAGjChE,KAAKsB,SAAU,EACftB,KAAKuB,OAAQ,EACbvB,KAAKiD,mBAAmB,IAE1B,KACEjD,KAAKsB,SAAU,EACftB,KAAKuB,OAAQ,EACbvB,KAAKiD,mBAAmB,GAG9B,EAGAgE,cAAcpF,GACZ,IAAIqF,GAAU,GAKM,KAFNlH,KAAKkB,WAAWa,IAAIF,GAAM7B,KAAKkB,WAAWc,IAAIH,QAAM4D,IAEvDhD,OAIPzC,KAAKmB,UAAUgG,SAAStF,GAC1B7B,KAAKmB,UAAYnB,KAAKmB,UAAUoB,QAAOmC,GAAQA,IAAS7C,KAExD7B,KAAKmB,UAAY,IAAInB,KAAKmB,UAAWU,GACrCqF,GAAU,GAGZlH,KAAKwB,cAAcxB,KAAKkB,WAAYW,EAAI,CACtCqF,YAGFlH,KAAKoH,oBACP,EAGAC,gBAAeC,GAAyB,IAAvBC,EAAaC,GAAQF,EAChCJ,GAAU,GAKM,IAFNlH,KAAKW,aAAaqB,IAAIuF,IAEzB9E,OAIPzC,KAAKS,YAAYsB,IAAIwF,GACvBvH,KAAKS,YAAYgH,OAAOF,IAExBvH,KAAKS,YAAYwB,IAAIsF,EAAaC,GAClCN,GAAU,GAIZlH,KAAKwB,cAAcxB,KAAKW,aAAc4G,EAAa,CACjDL,YAKFlH,KAAKY,gBACHZ,KAAKQ,YAAYkC,MAAQ,GACC,IAA1B1C,KAAKS,YAAYiC,MACjB1C,KAAKkC,wBAEPlC,KAAKc,yBAAqD,IAA1Bd,KAAKS,YAAYiC,KAEjD1C,KAAK0H,sBACP,EAEAC,UAASC,GAA0D,IAAzD,QAACC,EAAO,eAAEC,EAAc,eAAEC,EAAc,aAAEC,GAAaJ,EAC/D,MAAMK,EAAM7F,MAAMC,KAAKrC,KAAKS,YAAYiF,QAExC,OAAO,IAAInC,SAAQ,CAACC,EAASC,KACvBzD,KAAKkC,wBACPuB,EAAO,IAAIyE,MAAM,uCAKnBlI,KAAKY,iBAAkB,EAGvBZ,KAAKwB,cAAcxB,KAAKW,aAAcsH,EAAK,CACzCf,SAAS,EACTzE,MAAM,IAERzC,KAAK0H,uBACLS,EAAAA,EAAAA,IAAkBL,GAElB9H,KAAKJ,IAAI8D,QAAS,WAAUmE,YAAmB,CAC7ClE,OAAQ,SACRyE,MAAO,CACLvG,GAAIoG,GAENpE,QAASA,MACPwE,EAAAA,EAAAA,IAAkBN,GAGlB/H,KAAKwB,cAAcxB,KAAKW,aAAcsH,EAAK,CACzCf,SAAS,EACTzE,MAAM,IAERzC,KAAKS,YAAY6H,OAAO,EAE1B/G,MAAOA,MACLgH,EAAAA,EAAAA,IAAgBP,GAChBhI,KAAKwB,cAAcxB,KAAKW,aAAcsH,EAAK,CACzCf,SAAS,EACTzE,MAAM,GACN,EAEJ+F,SAAUA,KACRxI,KAAKY,iBAAkB,EACvB4C,EAAQxD,KAAK0H,sBAAsB,IAErC,GAEN,EAIAe,QAAOC,GAA6B,IAA5B,OAACC,EAAM,MAAEP,EAAK,UAAEQ,GAAUF,EAChC,IAAKC,EACH,OAGF,MAAMV,EAAMjI,KAAKmB,UAmDjB,OAjDAnB,KAAKqB,eAAgB,EAErBrB,KAAKwB,cAAcxB,KAAKkB,WAAY+G,EAAsB,CACxDxF,MAAM,IAGRzC,KAAKoH,oBAEW,IAAI7D,SAAQC,IAE1B,MAAM,MAACqF,EAAK,QAAEhB,GAAWc,GAEzBG,EAAAA,EAAAA,IACE9I,KAAKJ,IACL,CACEiJ,QACAD,YACAG,QAAS,IAAId,EAAKJ,GAClBO,SAEF,CACEvE,QAASD,IACHA,GAAMoF,OAAOC,QACfjJ,KAAKkJ,QAAQ,CACXC,aAAcvF,EAAKoF,MAAMC,SAK7BjJ,KAAKwB,cAAcxB,KAAKkB,WAAY+G,EAAsB,CACxDf,SAAS,EACTzE,MAAM,IAERzC,KAAKmB,UAAY,EAAE,EAErBI,MAAOA,KACLvB,KAAKwB,cAAcxB,KAAKkB,WAAY+G,EAAsB,CACxDf,SAAS,EACTzE,MAAM,GACN,EAEJ+F,SAAUA,KACRxI,KAAKqB,eAAgB,EACrBmC,EAAQxD,KAAKoH,oBAAoB,GAGtC,GAIL,EAGAgC,+BACEpJ,KAAKwB,cACHxB,KAAKW,aACLX,KAAKQ,YAAYiB,KAAI4H,IAAA,IAAC,GAACxH,GAAGwH,EAAA,OAAKxH,CAAE,IACjC,CACEyH,WAAYtJ,KAAKa,uBAIrBb,KAAKa,sBAAwBb,KAAKa,qBAElCb,KAAKkJ,QAAQ,CACXrI,qBAAsBb,KAAKa,qBAC3BF,aAAcX,KAAKW,cAEvB,EAEA4I,4BAA4BhC,GAC1B,MAAM+B,EACJtJ,KAAKW,aAAaoB,IAAIwF,IAAgBvH,KAAKW,aAAaqB,IAAIuF,GAAa+B,UAC3EtJ,KAAKwB,cAAcxB,KAAKW,aAAc4G,EAAa,CAAC+B,WAAYA,IAChEtJ,KAAKkJ,QAAQ,CACXvI,aAAcX,KAAKW,cAEvB,EAEAsC,oBACE,MAAMlD,EAAQ,CACZgB,aAAcf,KAAKe,aAAawB,QAAOiH,IAAA,IAAC,iBAAClE,GAAiBkE,EAAA,OAAMlE,CAAgB,IAChFtE,qBAAsBhB,KAAKe,aAAawB,QACtCkH,IAAA,IAAC,iBAACnE,GAAiBmE,EAAA,OAAKnE,CAAgB,OAEvCoE,IAAK1J,KAAM,CACZ,cACA,cACA,eACA,aACA,eACA,UACA,QACA,2BACA,iBAIJ,OADAA,KAAKkJ,QAAQnJ,GACNA,CACT,EAEA2H,sBACE,MAAM3H,EAAQ2J,IAAK1J,KAAM,CACvB,kBACA,eACA,cACA,2BACA,yBAGF,OADAA,KAAKkJ,QAAQnJ,GACNA,CACT,EAEAqH,oBACE,MAAMrH,EAAQ2J,IAAK1J,KAAM,CAAC,gBAAiB,aAAc,cAEzD,OADAA,KAAKkJ,QAAQnJ,GACNA,CACT,EAEA4J,WACE,MAAO,IACFD,IAAK1J,KAAM,CACZ,2BACA,QACA,uBACA,UACA,gBACA,YACA,aACA,aACA,cACA,cACA,eACA,eACA,kBACA,uBACA,cACA,iBAGN,GAIF,GADsB4J,EAAAA,EAAAA,aAAYjK,E,iiCC/nBlC,MAAMkK,UAAmBC,EAAAA,UAAwBC,cAAA,SAAAvE,YAAAwE,EAAAA,EAAAA,GAAA,aAChC,CACbV,WAAW,EACXpC,SAAS,EACTzE,MAAM,KACPuH,EAAAA,EAAAA,GAAA,gBAEUC,EAAAA,EAAAA,QAAqBrG,GAAQ5D,KAAKkK,cAActG,SAAO6B,KAAUuE,EAAAA,EAAAA,GAAA,sBAE5D3J,IAAoB,IAAnB,aAACM,GAAaN,EAC7B,IAAKM,EACH,OAGF,MAAM,YAAC4G,GAAevH,KAAKmK,MACrBC,EAAazJ,EAAaoB,IAAIwF,EAAY1F,IAC5ClB,EAAaqB,IAAIuF,EAAY1F,SAC7B4D,EAEC2E,GAILlK,OAAOwF,KAAK0E,GAAYhK,SAAQE,IAC1B8J,EAAW9J,KAASN,KAAKD,MAAMO,IAInCN,KAAKqK,UAASC,IAAa,IAAKA,EAAW,CAAChK,GAAM8J,EAAW9J,MAAO,GACpE,KACH0J,EAAAA,EAAAA,GAAA,2BAEoB,KACnB,MAAM,YAACzC,GAAevH,KAAKmK,MAC3BF,EAAAA,EAAAA,4BAA0C1C,EAAY1F,GAAG,KAC1DmI,EAAAA,EAAAA,GAAA,qBAOc,KACb,MAAM,YAACzC,GAAevH,KAAKmK,OACrB,YAACvH,GAAe2E,EAElBvH,KAAKD,MAAM0C,MAKfwH,EAAAA,EAAAA,gBAA8B,CAAC1C,EAAY1F,GAAIe,EAAYf,IAAI,GAChE,CAdD0I,iBAAiBC,GACfA,EAAMC,gBACR,CAcAC,mBAEE,CAGFC,kBAAkB9I,EAAY+I,GAC5B,OAAKA,GAKHC,EAAAA,EAAAA,IAACC,EAAAA,EAAO,CAACC,MAAOlJ,EAAGgD,UACjBgG,EAAAA,EAAAA,IAAA,QAAAhG,SAAO+F,MALF/I,CAQX,CAEAmJ,SACE,MAAM,YAACzD,EAAW,aAAE0D,EAAY,iBAAEC,GAAoBlL,KAAKmK,OACrD,YAACvH,EAAW,GAAEf,EAAE,MAAE+I,GAASrD,GAC3B,UAAC+B,EAAS,KAAE7G,EAAI,QAAEyE,GAAWlH,KAAKD,MAClCoL,EAAmB1I,GAA6B,IAArByI,EAGjC,OACEE,EAAAA,EAAAA,IAACC,EAAW,CAAC5I,KAAMA,EAAKoC,SAAA,EACtBuG,EAAAA,EAAAA,IAACE,EAAQ,CAACC,UAAWjC,EAAUzE,SAAA,EAC7BuG,EAAAA,EAAAA,IAACI,EAAa,CAACC,QAASzL,KAAK0L,aAAa7G,SAAA,EACxCgG,EAAAA,EAAAA,IAACC,EAAAA,EAAO,CACNa,UAAWR,EACXJ,MACEI,GAAyC,IAArBD,GAChBU,EAAAA,EAAAA,GAAE,wDACFnG,EACLZ,UAEDgG,EAAAA,EAAAA,IAACgB,EAAAA,EAAQ,CACPhK,GAAIA,EACJtB,MAAOsB,EACPqF,QAASA,EACTyE,SAAUR,EACVW,SAAU9L,KAAK0K,sBAInBG,EAAAA,EAAAA,IAACkB,EAAgB,CAACN,QAASzL,KAAKuK,iBAAkByB,QAASnK,EAAGgD,SAC3D7E,KAAK2K,kBAAkB9I,EAAI+I,SAIhCC,EAAAA,EAAAA,IAAA,OAAAhG,UACEgG,EAAAA,EAAAA,IAACoB,EAAQ,CAACR,QAASzL,KAAKkM,mBAAmBrH,UACzCgG,EAAAA,EAAAA,IAACsB,EAAAA,GAAW,CAACC,UAAW9C,EAAY,OAAS,KAAM5G,KAAK,eAK5D4G,IACAuB,EAAAA,EAAAA,IAACwB,EAAe,CAACC,UAAU,aAAYzH,SACpCjC,IACCiI,EAAAA,EAAAA,IAAC0B,EAAY,CAACD,UAAU,gBAAezH,UACrCgG,EAAAA,EAAAA,IAAC2B,EAAAA,EAAkB,CACjB5I,KAAMhB,EACNqI,aAAcA,EACdwB,WAAS,EACTC,WAAS,EACTC,OAAO,sBAQvB,EAhII9C,EAAU+C,YAAA,aAmIhB,MAAMvB,GAAcwB,EAAAA,EAAAA,GAAO,MAAK,CAAAC,OAAA,aAAZD,EAChBE,GAAKA,EAAEtK,MAAQ,gBAAc,KAG3B+I,GAAgBqB,EAAAA,EAAAA,GAAO,MAAK,CAAAC,OAAA,aAAZD,CAAa,8DAI1BG,EAAAA,EAAAA,GAAM,GAAE,KAGX1B,GAAWuB,EAAAA,EAAAA,GAAO,MAAK,CAAAC,OAAA,aAAZD,CAAa,oEAGJE,GAAKA,EAAEE,MAAMC,aAAW,sBAC5BH,GAAKA,EAAEE,MAAME,qBAAmB,aACzCH,EAAAA,EAAAA,GAAM,IAAI,KAAIA,EAAAA,EAAAA,GAAM,GAAE,KAC/BD,GAAKA,EAAExB,UAAa,4BAA2BwB,EAAEE,MAAMC,eAAa,IAEpE7B,EAAW,6FAMkB0B,GAAKA,EAAEE,MAAMC,aAAW,OAKnDnB,GAAmBc,EAAAA,EAAAA,GAAO,QAAO,CAAAC,OAAA,aAAdD,CAAe,gBACvBE,GAAKA,EAAEE,MAAMG,KAAKC,YAAU,IAEzC/B,EAAQ,iCAMNW,GAAWY,EAAAA,EAAAA,GAAO,OAAM,CAAAC,OAAA,aAAbD,CAAc,CAAAS,KAAA,SAAAC,OAAA,mBAIzBlB,GAAkBQ,EAAAA,EAAAA,GAAO,MAAK,CAAAC,OAAA,aAAZD,CAAa,iDAGfE,GAAKA,EAAEE,MAAMO,YAAU,KAGvCjB,GAAeM,EAAAA,EAAAA,GAAO,MAAK,CAAAC,OAAA,aAAZD,CAAa,qEAKnBG,EAAAA,EAAAA,GAAM,GAAE,MAIvB,I,wJCjMO,SAASS,EAAapN,GAMnB,IANoB,QAC5BwH,EAAO,QACP6F,EAAO,MACP7E,EAAK,UACLlB,EAAS,iBACTgG,GACMtN,EACN,MAAM,YACJI,EAAW,YACXD,EAAW,qBACXK,EAAoB,gBACpBD,EAAe,yBACfE,IACE8M,EAAAA,EAAAA,GAAe3D,EAAAA,GAEb4D,EAAepN,GAAaiC,MAAQ,EA2BpCoL,EACJtN,EAAYqC,QAAU,GAClB+I,EAAAA,EAAAA,GAAE,qDACmB,IAArBnL,EAAYiC,MACZkJ,EAAAA,EAAAA,GAAE,gDACF3B,EAAAA,EAAAA,yBACA2B,EAAAA,EAAAA,GAAE,mDACFnG,EAEN,OACE2F,EAAAA,EAAAA,IAAC2C,EAAAA,GAAW,CAACC,YAAU,EAAAnJ,SAAA,EACrBuG,EAAAA,EAAAA,IAAA,OAAAvG,SAAA,EACEgG,EAAAA,EAAAA,IAACoD,EAAAA,EAAO,CACNtC,SAAU/K,EACVsN,UAAWvG,EACXwG,SAASvC,EAAAA,EAAAA,GACP,8GACA/G,UAEFgG,EAAAA,EAAAA,IAACuD,EAAAA,GAAM,CAAC1L,KAAK,KAAKqI,MAAO+C,EAAsBjJ,SAC5CrE,EAAYqC,QAAU,GACnB+I,EAAAA,EAAAA,GAAE,YACFyC,EAAAA,EAAAA,IAAI,oCAAqC,CACvCC,sBAAuBT,SAKjChD,EAAAA,EAAAA,IAAC0D,EAAa,CACZ7L,KAAK,KACLiJ,UAAW7K,EACX2K,QAxDR,SAAwBjB,GACtBA,EAAMgE,kBAEN,MAAMrO,EAAUM,EAAYN,UAG5B,GAAyB,IAArBM,EAAYiC,KACd,OAIF,MAAO+L,EAAaC,GAAiBtM,MAAMC,KAAKlC,GAASsB,KACvDe,IAAA,IAAE,CAAEgF,GAAQhF,EAAA,OAAKgF,CAAO,KAG1BmH,EAAAA,EAAAA,eAAc,CACZC,cAAe/G,EACf6F,UACAmB,YAAahH,EACbgB,QACA4F,cACAC,iBAEJ,EAkCQ3D,MACGjK,OAEG2E,GADAmG,EAAAA,EAAAA,GAAE,gDAEP/G,UAEA+G,EAAAA,EAAAA,GAAE,iBAGPf,EAAAA,EAAAA,IAACuD,EAAAA,GAAM,CAAC1L,KAAK,KAAK+I,QAASkC,EAAiB9I,SACzChE,GAAuB+K,EAAAA,EAAAA,GAAE,eAAgBA,EAAAA,EAAAA,GAAE,oBAIpD,CAxFgB6B,EAAab,YAAA,gBA0F7B,MAAM2B,GAAgB1B,EAAAA,EAAAA,GAAOuB,EAAAA,GAAM,CAAAtB,OAAA,YAAbD,CAAc,gBACnBG,EAAAA,EAAAA,GAAM,GAAE,KCjFzB,SAAS8B,EAAUzO,GAQT,IARU,aAClB0O,EAAe,GAAE,UACjBC,EAAS,iBACTrB,EAAgB,UAChBhG,EAAS,aACTsD,EAAY,QACZpD,EAAO,QACP6F,GACMrN,EACN,MAAM4O,EAA8BF,EAAaxM,QAC/CC,IAAA,IAAC,YAACI,GAAYJ,EAAA,QAAOI,CAAW,IAIlC,OAFmBqM,EAA4BpM,OAAS,GAatDuI,EAAAA,EAAAA,IAAC8D,EAAAA,SAAQ,CAAArK,SAAA,EACPuG,EAAAA,EAAAA,IAAA,MAAAvG,SAAA,EACEgG,EAAAA,EAAAA,IAAA,QAAAhG,UAAO+G,EAAAA,EAAAA,GAAE,2CAAiD,KAC1Df,EAAAA,EAAAA,IAACsE,EAAAA,EAAU,CAACC,MAAOH,EAA4BpM,aAGjDuI,EAAAA,EAAAA,IAACiE,EAAAA,GAAK,CAAAxK,SAAA,EACJgG,EAAAA,EAAAA,IAAC4C,EAAa,CACZE,iBAAkBA,EAClBhG,UAAWA,EACXkB,MAAOoC,EAAaqE,KACpB5B,QAASA,EACT7F,QAASA,KAGXgD,EAAAA,EAAAA,IAAC0E,EAAAA,EAAS,CAAA1K,SACPoK,EAA4BxN,KAAI8F,IAC/BsD,EAAAA,EAAAA,IAAChB,EAAU,CAEToB,aAAcA,EACd1D,YAAaA,EACb2D,iBAAkB+D,EAA4BpM,QAHzC0E,EAAY1F,WAQxBmN,IAAanE,EAAAA,EAAAA,IAAC2E,EAAAA,EAAU,CAACR,UAAWA,QAnCrCnE,EAAAA,EAAAA,IAACwE,EAAAA,GAAK,CAAAxK,UACJgG,EAAAA,EAAAA,IAAC4E,EAAAA,EAAiB,CAAA5K,UAChBgG,EAAAA,EAAAA,IAAA,KAAAhG,UAAI+G,EAAAA,EAAAA,GAAE,0DAoChB,CAtDSkD,EAAUlC,YAAA,aAwDnB,SAAe8C,EAAAA,EAAAA,GAAiBZ,GCvDhC,MAAMa,UAAwB7F,EAAAA,UAAwBC,cAAA,SAAAvE,YAAAwE,EAAAA,EAAAA,GAAA,aACrC,CACbxJ,YAAa,GACbc,SAAS,EACTC,OAAO,EACP6G,MAAOpI,KAAKmK,MAAMyF,SAASxH,MAAMA,OAAS,MAC3C4B,EAAAA,EAAAA,GAAA,yBAyBkB3J,IAAgD,IAA/C,YAACG,EAAW,YAAEY,EAAW,QAAEE,EAAO,MAAEC,GAAMlB,EACxDG,GACFR,KAAKqK,SAAS,CACZ7J,cACAY,cACAE,aAA4B,IAAZA,GAA0BA,EAC1CC,WAAwB,IAAVA,GAAwBA,GAE1C,KACDyI,EAAAA,EAAAA,GAAA,gBAEUC,EAAAA,EAAAA,OAAqBjK,KAAK6P,sBAAkBpK,KAAUuE,EAAAA,EAAAA,GAAA,kBAerD,KACVC,EAAAA,EAAAA,QAAsB,CACpB,CACE7G,SAAUpD,KAAK8P,cACfxM,QAAS,SACTD,YAAarD,KAAKmK,MAAMyF,SAASxH,QAEnC,KACH4B,EAAAA,EAAAA,GAAA,sBAEe,KACdC,EAAAA,EAAAA,UAAwB,CACtBpC,QAAS7H,KAAKmK,MAAMxB,OAAOd,QAC3BC,gBAAgB8D,EAAAA,EAAAA,GAAE,qBAClB7D,gBAAgB6D,EAAAA,EAAAA,GAAE,6CAClB5D,cAAc4D,EAAAA,EAAAA,GAAE,0CAChB,GACH,CAlEDmE,oBACE/P,KAAKgQ,WACP,CAEAC,0BAA0BC,GACxB,GACEA,EAAUvH,OAAOd,UAAY7H,KAAKmK,MAAMxB,OAAOd,SAC/CqI,EAAUN,SAASO,SAAWnQ,KAAKmK,MAAMyF,SAASO,OAClD,CACA,MAAM9M,EAAc6M,EAAUN,SAASxH,MACvCpI,KAAKqK,SACH,CACEjC,MAAO/E,EAAY+E,OAErBpI,KAAKgQ,UAET,CACF,CAEAI,uBACEpQ,KAAKqQ,YACP,CAeAP,cACE,MAAM,OAACnH,EAAM,SAAEiH,GAAY5P,KAAKmK,OAC1B,QAACtC,GAAWc,EAEZtF,EAAc,IACfuM,EAASxH,MACZkI,MAAO,GACPlI,MAAOpI,KAAKD,MAAMqI,OAGpB,MAAQ,WAAUP,aAAmB0I,EAAAA,UAAalN,IACpD,CAqBA2H,SACE,MAAM,QAAC0C,EAAO,OAAE/E,GAAU3I,KAAKmK,OACzB,QAACtC,GAAWc,GACXrH,QAASkP,EAAS,MAAEjP,EAAK,YAAEf,EAAW,YAAEY,GAAepB,KAAKD,MAC7D0Q,EAAUlP,IAAUiP,EACpBE,GAAwBD,IAAYD,EAE1C,OACE3F,EAAAA,EAAAA,IAAC8F,EAAAA,GAAW,CAAA9L,UACVuG,EAAAA,EAAAA,IAACuF,EAAAA,GAAW,CAACC,WAAS,EAAA/L,SAAA,EACpBgG,EAAAA,EAAAA,IAACgG,EAAAA,GAAK,CAACC,KAAK,UAASjM,UAClB+G,EAAAA,EAAAA,GACC,uGAIH4E,IAAa3F,EAAAA,EAAAA,IAACkG,EAAAA,EAAgB,IAC9BN,IACC5F,EAAAA,EAAAA,IAACmG,EAAAA,EAAY,CACX7C,SAASvC,EAAAA,EAAAA,GAAE,wDACXqF,QAASjR,KAAKgQ,YAIjBU,IACC7F,EAAAA,EAAAA,IAACiE,EAAU,CACTpB,QAASA,EACTqB,aAAcvO,EACdwO,UAAW5N,EACXyG,QAASA,EACTF,UAAW3H,KAAKkR,cAChBvD,iBAAkB1D,EAAAA,EAAAA,mCAM9B,EAjHI0F,EAAe/C,YAAA,kBAsHrB,SAAe8C,EAAAA,EAAAA,GAAiBC,E","sources":["webpack:///./app/stores/groupingStore.tsx","webpack:///./app/views/issueDetails/groupMerged/mergedItem.tsx","webpack:///./app/views/issueDetails/groupMerged/mergedToolbar.tsx","webpack:///./app/views/issueDetails/groupMerged/mergedList.tsx","webpack:///./app/views/issueDetails/groupMerged/index.tsx"],"sourcesContent":["import pick from 'lodash/pick';\nimport {createStore} from 'reflux';\n\nimport {mergeGroups} from 'sentry/actionCreators/group';\nimport {\n  addErrorMessage,\n  addLoadingMessage,\n  addSuccessMessage,\n} from 'sentry/actionCreators/indicator';\nimport {Client} from 'sentry/api';\nimport {Group, Organization, Project} from 'sentry/types';\nimport {Event} from 'sentry/types/event';\nimport toArray from 'sentry/utils/toArray';\n\nimport {CommonStoreDefinition} from './types';\n\n// Between 0-100\nconst MIN_SCORE = 0.6;\n\n// @param score: {[key: string]: number}\nconst checkBelowThreshold = (scores = {}) => {\n  const scoreKeys = Object.keys(scores);\n  return !scoreKeys.map(key => scores[key]).find(score => score >= MIN_SCORE);\n};\n\ntype State = {\n  // \"Compare\" button state\n  enableFingerprintCompare: boolean;\n  error: boolean;\n  filteredSimilarItems: SimilarItem[];\n  loading: boolean;\n  mergeDisabled: boolean;\n  mergeList: Array<string>;\n  mergeState: Map<any, any>;\n  // List of fingerprints that belong to issue\n  mergedItems: Fingerprint[];\n  mergedLinks: string;\n  similarItems: SimilarItem[];\n  similarLinks: string;\n  // Disabled state of \"Unmerge\" button in \"Merged\" tab (for Issues)\n  unmergeDisabled: boolean;\n  // If \"Collapse All\" was just used, this will be true\n  unmergeLastCollapsed: boolean;\n  // Map of {[fingerprint]: Array<fingerprint, event id>} that is selected to be unmerged\n  unmergeList: Map<any, any>;\n  // Map of state for each fingerprint (i.e. \"collapsed\")\n  unmergeState: Map<any, any>;\n};\n\ntype ScoreMap = Record<string, number | null>;\n\ntype ApiFingerprint = {\n  id: string;\n  latestEvent: Event;\n  childId?: string;\n  childLabel?: string;\n  eventCount?: number;\n  label?: string;\n  lastSeen?: string;\n  parentId?: string;\n  parentLabel?: string;\n  state?: string;\n};\n\ntype ChildFingerprint = {\n  childId: string;\n  childLabel?: string;\n  eventCount?: number;\n  lastSeen?: string;\n  latestEvent?: Event;\n};\n\nexport type Fingerprint = {\n  children: Array<ChildFingerprint>;\n  eventCount: number;\n  id: string;\n  latestEvent: Event;\n  label?: string;\n  lastSeen?: string;\n  parentId?: string;\n  parentLabel?: string;\n  state?: string;\n};\n\nexport type SimilarItem = {\n  isBelowThreshold: boolean;\n  issue: Group;\n  aggregate?: {\n    exception: number;\n    message: number;\n  };\n  score?: Record<string, number | null>;\n  scoresByInterface?: {\n    exception: Array<[string, number | null]>;\n    message: Array<[string, any | null]>;\n  };\n};\n\ntype ResponseProcessors = {\n  merged: (item: ApiFingerprint[]) => Fingerprint[];\n  similar: (data: [Group, ScoreMap]) => {\n    aggregate: Record<string, number>;\n    isBelowThreshold: boolean;\n    issue: Group;\n    score: ScoreMap;\n    scoresByInterface: Record<string, Array<[string, number | null]>>;\n  };\n};\n\ntype DataKey = keyof ResponseProcessors;\n\ntype ResultsAsArrayDataMerged = Parameters<ResponseProcessors['merged']>[0];\n\ntype ResultsAsArrayDataSimilar = Array<Parameters<ResponseProcessors['similar']>[0]>;\n\ntype ResultsAsArray = Array<{\n  data: ResultsAsArrayDataMerged | ResultsAsArrayDataSimilar;\n  dataKey: DataKey;\n  links: string | null;\n}>;\n\ntype IdState = {\n  busy?: boolean;\n  checked?: boolean;\n  collapsed?: boolean;\n};\n\ntype InternalDefinition = {\n  api: Client;\n};\n\ntype UnmergeResponse = Pick<\n  State,\n  | 'unmergeDisabled'\n  | 'unmergeState'\n  | 'unmergeList'\n  | 'enableFingerprintCompare'\n  | 'unmergeLastCollapsed'\n>;\n\ninterface GroupingStoreDefinition\n  extends CommonStoreDefinition<State>,\n    InternalDefinition {\n  getInitialState(): State;\n  init(): void;\n  isAllUnmergedSelected(): boolean;\n  onFetch(\n    toFetchArray?: Array<{\n      dataKey: DataKey;\n      endpoint: string;\n      queryParams?: Record<string, any>;\n    }>\n  ): Promise<any>;\n  onMerge(props: {\n    projectId: Project['id'];\n    params?: {\n      groupId: Group['id'];\n      orgId: Organization['id'];\n    };\n    query?: string;\n  }): undefined | Promise<any>;\n  onToggleCollapseFingerprint(fingerprint: string): void;\n  onToggleCollapseFingerprints(): void;\n  onToggleMerge(id: string): void;\n  onToggleUnmerge(props: [string, string] | string): void;\n  onUnmerge(props: {\n    groupId: Group['id'];\n    errorMessage?: string;\n    loadingMessage?: string;\n    successMessage?: string;\n  }): Promise<UnmergeResponse>;\n  setStateForId(\n    map: Map<string, IdState>,\n    idOrIds: Array<string> | string,\n    newState: IdState\n  ): Array<IdState>;\n  triggerFetchState(): Pick<\n    State,\n    | 'similarItems'\n    | 'filteredSimilarItems'\n    | 'mergedItems'\n    | 'mergedLinks'\n    | 'similarLinks'\n    | 'mergeState'\n    | 'unmergeState'\n    | 'loading'\n    | 'error'\n  >;\n  triggerMergeState(): Pick<State, 'mergeState' | 'mergeDisabled' | 'mergeList'>;\n  triggerUnmergeState(): UnmergeResponse;\n}\n\nconst storeConfig: GroupingStoreDefinition = {\n  api: new Client(),\n\n  init() {\n    // XXX: Do not use `this.listenTo` in this store. We avoid usage of reflux\n    // listeners due to their leaky nature in tests.\n\n    const state = this.getInitialState();\n\n    Object.entries(state).forEach(([key, value]) => {\n      this[key] = value;\n    });\n  },\n\n  getInitialState() {\n    return {\n      // List of fingerprints that belong to issue\n      mergedItems: [],\n      // Map of {[fingerprint]: Array<fingerprint, event id>} that is selected to be unmerged\n      unmergeList: new Map(),\n      // Map of state for each fingerprint (i.e. \"collapsed\")\n      unmergeState: new Map(),\n      // Disabled state of \"Unmerge\" button in \"Merged\" tab (for Issues)\n      unmergeDisabled: true,\n      // If \"Collapse All\" was just used, this will be true\n      unmergeLastCollapsed: false,\n      // \"Compare\" button state\n      enableFingerprintCompare: false,\n      similarItems: [],\n      filteredSimilarItems: [],\n      similarLinks: '',\n      mergeState: new Map(),\n      mergeList: [],\n      mergedLinks: '',\n      mergeDisabled: false,\n      loading: true,\n      error: false,\n    };\n  },\n\n  setStateForId(map, idOrIds, newState) {\n    const ids = toArray(idOrIds);\n\n    return ids.map(id => {\n      const state = (map.has(id) && map.get(id)) || {};\n      const mergedState = {...state, ...newState};\n      map.set(id, mergedState);\n      return mergedState;\n    });\n  },\n\n  isAllUnmergedSelected() {\n    const lockedItems =\n      (Array.from(this.unmergeState.values()) as Array<IdState>).filter(\n        ({busy}) => busy\n      ) || [];\n    return (\n      this.unmergeList.size ===\n      this.mergedItems.filter(({latestEvent}) => !!latestEvent).length -\n        lockedItems.length\n    );\n  },\n\n  // Fetches data\n  onFetch(toFetchArray) {\n    const requests = toFetchArray || this.toFetchArray;\n\n    // Reset state and trigger update\n    this.init();\n    this.triggerFetchState();\n\n    const promises = requests.map(\n      ({endpoint, queryParams, dataKey}) =>\n        new Promise((resolve, reject) => {\n          this.api.request(endpoint, {\n            method: 'GET',\n            data: queryParams,\n            success: (data, _, resp) => {\n              resolve({\n                dataKey,\n                data,\n                links: resp ? resp.getResponseHeader('Link') : null,\n              });\n            },\n            error: err => {\n              const error = err.responseJSON?.detail || true;\n              reject(error);\n            },\n          });\n        })\n    );\n\n    const responseProcessors: ResponseProcessors = {\n      merged: items => {\n        const newItemsMap: Record<string, Fingerprint> = {};\n        const newItems: Fingerprint[] = [];\n\n        items.forEach(item => {\n          if (!newItemsMap[item.id]) {\n            const newItem = {\n              eventCount: 0,\n              children: [],\n              // lastSeen and latestEvent properties are correct\n              // since the server returns items in\n              // descending order of lastSeen\n              ...item,\n            };\n            // Check for locked items\n            this.setStateForId(this.unmergeState, item.id, {\n              busy: item.state === 'locked',\n            });\n\n            newItemsMap[item.id] = newItem;\n            newItems.push(newItem);\n          }\n\n          const newItem = newItemsMap[item.id];\n          const {childId, childLabel, eventCount, lastSeen, latestEvent} = item;\n\n          if (eventCount) {\n            newItem.eventCount += eventCount;\n          }\n\n          if (childId) {\n            newItem.children.push({\n              childId,\n              childLabel,\n              lastSeen,\n              latestEvent,\n              eventCount,\n            });\n          }\n        });\n\n        return newItems;\n      },\n      similar: ([issue, scoreMap]) => {\n        // Hide items with a low scores\n        const isBelowThreshold = checkBelowThreshold(scoreMap);\n\n        // List of scores indexed by interface (i.e., exception and message)\n        // Note: for v2, the interface is always \"similarity\". When v2 is\n        // rolled out we can get rid of this grouping entirely.\n        const scoresByInterface = Object.keys(scoreMap)\n          .map(scoreKey => [scoreKey, scoreMap[scoreKey]])\n          .reduce((acc, [scoreKey, score]) => {\n            // v1 layout: '<interface>:...'\n            const [interfaceName] = String(scoreKey).split(':');\n\n            if (!acc[interfaceName]) {\n              acc[interfaceName] = [];\n            }\n            acc[interfaceName].push([scoreKey, score]);\n\n            return acc;\n          }, {});\n\n        // Aggregate score by interface\n        const aggregate = Object.keys(scoresByInterface)\n          .map(interfaceName => [interfaceName, scoresByInterface[interfaceName]])\n          .reduce((acc, [interfaceName, allScores]) => {\n            // `null` scores means feature was not present in both issues, do not\n            // include in aggregate\n            const scores = allScores.filter(([, score]) => score !== null);\n\n            const avg = scores.reduce((sum, [, score]) => sum + score, 0) / scores.length;\n\n            acc[interfaceName] = avg;\n            return acc;\n          }, {});\n\n        return {\n          issue,\n          score: scoreMap,\n          scoresByInterface,\n          aggregate,\n          isBelowThreshold,\n        };\n      },\n    };\n\n    if (toFetchArray) {\n      this.toFetchArray = toFetchArray;\n    }\n\n    return Promise.all(promises).then(\n      resultsArray => {\n        (resultsArray as ResultsAsArray).forEach(({dataKey, data, links}) => {\n          const items =\n            dataKey === 'similar'\n              ? (data as ResultsAsArrayDataSimilar).map(responseProcessors[dataKey])\n              : responseProcessors[dataKey](data as ResultsAsArrayDataMerged);\n\n          this[`${dataKey}Items`] = items;\n          this[`${dataKey}Links`] = links;\n        });\n\n        this.loading = false;\n        this.error = false;\n        this.triggerFetchState();\n      },\n      () => {\n        this.loading = false;\n        this.error = true;\n        this.triggerFetchState();\n      }\n    );\n  },\n\n  // Toggle merge checkbox\n  onToggleMerge(id) {\n    let checked = false;\n\n    // Don't do anything if item is busy\n    const state = this.mergeState.has(id) ? this.mergeState.get(id) : undefined;\n\n    if (state?.busy === true) {\n      return;\n    }\n\n    if (this.mergeList.includes(id)) {\n      this.mergeList = this.mergeList.filter(item => item !== id);\n    } else {\n      this.mergeList = [...this.mergeList, id];\n      checked = true;\n    }\n\n    this.setStateForId(this.mergeState, id, {\n      checked,\n    });\n\n    this.triggerMergeState();\n  },\n\n  // Toggle unmerge check box\n  onToggleUnmerge([fingerprint, eventId]) {\n    let checked = false;\n\n    // Uncheck an item to unmerge\n    const state = this.unmergeState.get(fingerprint);\n\n    if (state?.busy === true) {\n      return;\n    }\n\n    if (this.unmergeList.has(fingerprint)) {\n      this.unmergeList.delete(fingerprint);\n    } else {\n      this.unmergeList.set(fingerprint, eventId);\n      checked = true;\n    }\n\n    // Update \"checked\" state for row\n    this.setStateForId(this.unmergeState, fingerprint, {\n      checked,\n    });\n\n    // Unmerge should be disabled if 0 or all items are selected, or if there's\n    // only one item to select\n    this.unmergeDisabled =\n      this.mergedItems.size <= 1 ||\n      this.unmergeList.size === 0 ||\n      this.isAllUnmergedSelected();\n\n    this.enableFingerprintCompare = this.unmergeList.size === 2;\n\n    this.triggerUnmergeState();\n  },\n\n  onUnmerge({groupId, loadingMessage, successMessage, errorMessage}) {\n    const ids = Array.from(this.unmergeList.keys()) as Array<string>;\n\n    return new Promise((resolve, reject) => {\n      if (this.isAllUnmergedSelected()) {\n        reject(new Error('Not allowed to unmerge ALL events'));\n        return;\n      }\n\n      // Disable unmerge button\n      this.unmergeDisabled = true;\n\n      // Disable rows\n      this.setStateForId(this.unmergeState, ids, {\n        checked: false,\n        busy: true,\n      });\n      this.triggerUnmergeState();\n      addLoadingMessage(loadingMessage);\n\n      this.api.request(`/issues/${groupId}/hashes/`, {\n        method: 'DELETE',\n        query: {\n          id: ids,\n        },\n        success: () => {\n          addSuccessMessage(successMessage);\n\n          // Busy rows after successful Unmerge\n          this.setStateForId(this.unmergeState, ids, {\n            checked: false,\n            busy: true,\n          });\n          this.unmergeList.clear();\n        },\n        error: () => {\n          addErrorMessage(errorMessage);\n          this.setStateForId(this.unmergeState, ids, {\n            checked: true,\n            busy: false,\n          });\n        },\n        complete: () => {\n          this.unmergeDisabled = false;\n          resolve(this.triggerUnmergeState());\n        },\n      });\n    });\n  },\n\n  // For cross-project views, we need to pass projectId instead of\n  // depending on router params (since we will only have orgId in that case)\n  onMerge({params, query, projectId}) {\n    if (!params) {\n      return undefined;\n    }\n\n    const ids = this.mergeList;\n\n    this.mergeDisabled = true;\n\n    this.setStateForId(this.mergeState, ids as Array<string>, {\n      busy: true,\n    });\n\n    this.triggerMergeState();\n\n    const promise = new Promise(resolve => {\n      // Disable merge button\n      const {orgId, groupId} = params;\n\n      mergeGroups(\n        this.api,\n        {\n          orgId,\n          projectId,\n          itemIds: [...ids, groupId],\n          query,\n        },\n        {\n          success: data => {\n            if (data?.merge?.parent) {\n              this.trigger({\n                mergedParent: data.merge.parent,\n              });\n            }\n\n            // Hide rows after successful merge\n            this.setStateForId(this.mergeState, ids as Array<string>, {\n              checked: false,\n              busy: true,\n            });\n            this.mergeList = [];\n          },\n          error: () => {\n            this.setStateForId(this.mergeState, ids as Array<string>, {\n              checked: true,\n              busy: false,\n            });\n          },\n          complete: () => {\n            this.mergeDisabled = false;\n            resolve(this.triggerMergeState());\n          },\n        }\n      );\n    });\n\n    return promise;\n  },\n\n  // Toggle collapsed state of all fingerprints\n  onToggleCollapseFingerprints() {\n    this.setStateForId(\n      this.unmergeState,\n      this.mergedItems.map(({id}) => id),\n      {\n        collapsed: !this.unmergeLastCollapsed,\n      }\n    );\n\n    this.unmergeLastCollapsed = !this.unmergeLastCollapsed;\n\n    this.trigger({\n      unmergeLastCollapsed: this.unmergeLastCollapsed,\n      unmergeState: this.unmergeState,\n    });\n  },\n\n  onToggleCollapseFingerprint(fingerprint) {\n    const collapsed =\n      this.unmergeState.has(fingerprint) && this.unmergeState.get(fingerprint).collapsed;\n    this.setStateForId(this.unmergeState, fingerprint, {collapsed: !collapsed});\n    this.trigger({\n      unmergeState: this.unmergeState,\n    });\n  },\n\n  triggerFetchState() {\n    const state = {\n      similarItems: this.similarItems.filter(({isBelowThreshold}) => !isBelowThreshold),\n      filteredSimilarItems: this.similarItems.filter(\n        ({isBelowThreshold}) => isBelowThreshold\n      ),\n      ...pick(this, [\n        'mergedItems',\n        'mergedLinks',\n        'similarLinks',\n        'mergeState',\n        'unmergeState',\n        'loading',\n        'error',\n        'enableFingerprintCompare',\n        'unmergeList',\n      ]),\n    };\n    this.trigger(state);\n    return state;\n  },\n\n  triggerUnmergeState() {\n    const state = pick(this, [\n      'unmergeDisabled',\n      'unmergeState',\n      'unmergeList',\n      'enableFingerprintCompare',\n      'unmergeLastCollapsed',\n    ]);\n    this.trigger(state);\n    return state;\n  },\n\n  triggerMergeState() {\n    const state = pick(this, ['mergeDisabled', 'mergeState', 'mergeList']);\n    this.trigger(state);\n    return state;\n  },\n\n  getState(): State {\n    return {\n      ...pick(this, [\n        'enableFingerprintCompare',\n        'error',\n        'filteredSimilarItems',\n        'loading',\n        'mergeDisabled',\n        'mergeList',\n        'mergeState',\n        'mergeState',\n        'mergedItems',\n        'mergedLinks',\n        'similarItems',\n        'similarLinks',\n        'unmergeDisabled',\n        'unmergeLastCollapsed',\n        'unmergeList',\n        'unmergeState',\n      ]),\n    };\n  },\n};\n\nconst GroupingStore = createStore(storeConfig);\nexport default GroupingStore;\n","import {Component} from 'react';\nimport styled from '@emotion/styled';\n\nimport Checkbox from 'sentry/components/checkbox';\nimport EventOrGroupHeader from 'sentry/components/eventOrGroupHeader';\nimport {Tooltip} from 'sentry/components/tooltip';\nimport {IconChevron} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport GroupingStore, {Fingerprint} from 'sentry/stores/groupingStore';\nimport {space} from 'sentry/styles/space';\nimport {Organization} from 'sentry/types';\n\ntype Props = {\n  fingerprint: Fingerprint;\n  organization: Organization;\n  totalFingerprint: number;\n};\n\ntype State = {\n  busy: boolean;\n  checked: boolean;\n  collapsed: boolean;\n};\n\nclass MergedItem extends Component<Props, State> {\n  state: State = {\n    collapsed: false,\n    checked: false,\n    busy: false,\n  };\n\n  listener = GroupingStore.listen(data => this.onGroupChange(data), undefined);\n\n  onGroupChange = ({unmergeState}) => {\n    if (!unmergeState) {\n      return;\n    }\n\n    const {fingerprint} = this.props;\n    const stateForId = unmergeState.has(fingerprint.id)\n      ? unmergeState.get(fingerprint.id)\n      : undefined;\n\n    if (!stateForId) {\n      return;\n    }\n\n    Object.keys(stateForId).forEach(key => {\n      if (stateForId[key] === this.state[key]) {\n        return;\n      }\n\n      this.setState(prevState => ({...prevState, [key]: stateForId[key]}));\n    });\n  };\n\n  handleToggleEvents = () => {\n    const {fingerprint} = this.props;\n    GroupingStore.onToggleCollapseFingerprint(fingerprint.id);\n  };\n\n  // Disable default behavior of toggling checkbox\n  handleLabelClick(event: React.MouseEvent) {\n    event.preventDefault();\n  }\n\n  handleToggle = () => {\n    const {fingerprint} = this.props;\n    const {latestEvent} = fingerprint;\n\n    if (this.state.busy) {\n      return;\n    }\n\n    // clicking anywhere in the row will toggle the checkbox\n    GroupingStore.onToggleUnmerge([fingerprint.id, latestEvent.id]);\n  };\n\n  handleCheckClick() {\n    // noop because of react warning about being a controlled input without `onChange`\n    // we handle change via row click\n  }\n\n  renderFingerprint(id: string, label?: string) {\n    if (!label) {\n      return id;\n    }\n\n    return (\n      <Tooltip title={id}>\n        <code>{label}</code>\n      </Tooltip>\n    );\n  }\n\n  render() {\n    const {fingerprint, organization, totalFingerprint} = this.props;\n    const {latestEvent, id, label} = fingerprint;\n    const {collapsed, busy, checked} = this.state;\n    const checkboxDisabled = busy || totalFingerprint === 1;\n\n    // `latestEvent` can be null if last event w/ fingerprint is not within retention period\n    return (\n      <MergedGroup busy={busy}>\n        <Controls expanded={!collapsed}>\n          <ActionWrapper onClick={this.handleToggle}>\n            <Tooltip\n              disabled={!checkboxDisabled}\n              title={\n                checkboxDisabled && totalFingerprint === 1\n                  ? t('To check, the list must contain 2 or more items')\n                  : undefined\n              }\n            >\n              <Checkbox\n                id={id}\n                value={id}\n                checked={checked}\n                disabled={checkboxDisabled}\n                onChange={this.handleCheckClick}\n              />\n            </Tooltip>\n\n            <FingerprintLabel onClick={this.handleLabelClick} htmlFor={id}>\n              {this.renderFingerprint(id, label)}\n            </FingerprintLabel>\n          </ActionWrapper>\n\n          <div>\n            <Collapse onClick={this.handleToggleEvents}>\n              <IconChevron direction={collapsed ? 'down' : 'up'} size=\"xs\" />\n            </Collapse>\n          </div>\n        </Controls>\n\n        {!collapsed && (\n          <MergedEventList className=\"event-list\">\n            {latestEvent && (\n              <EventDetails className=\"event-details\">\n                <EventOrGroupHeader\n                  data={latestEvent}\n                  organization={organization}\n                  hideIcons\n                  hideLevel\n                  source=\"merged-item\"\n                />\n              </EventDetails>\n            )}\n          </MergedEventList>\n        )}\n      </MergedGroup>\n    );\n  }\n}\n\nconst MergedGroup = styled('div')<{busy: boolean}>`\n  ${p => p.busy && 'opacity: 0.2'};\n`;\n\nconst ActionWrapper = styled('div')`\n  display: grid;\n  grid-auto-flow: column;\n  align-items: center;\n  gap: ${space(1)};\n`;\n\nconst Controls = styled('div')<{expanded: boolean}>`\n  display: flex;\n  justify-content: space-between;\n  border-top: 1px solid ${p => p.theme.innerBorder};\n  background-color: ${p => p.theme.backgroundSecondary};\n  padding: ${space(0.5)} ${space(1)};\n  ${p => p.expanded && `border-bottom: 1px solid ${p.theme.innerBorder}`};\n\n  ${MergedGroup} {\n    &:first-child & {\n      border-top: none;\n    }\n    &:last-child & {\n      border-top: none;\n      border-bottom: 1px solid ${p => p.theme.innerBorder};\n    }\n  }\n`;\n\nconst FingerprintLabel = styled('label')`\n  font-family: ${p => p.theme.text.familyMono};\n\n  ${Controls} & {\n    font-weight: 400;\n    margin: 0;\n  }\n`;\n\nconst Collapse = styled('span')`\n  cursor: pointer;\n`;\n\nconst MergedEventList = styled('div')`\n  overflow: hidden;\n  border: none;\n  background-color: ${p => p.theme.background};\n`;\n\nconst EventDetails = styled('div')`\n  display: flex;\n  justify-content: space-between;\n\n  .event-list & {\n    padding: ${space(1)};\n  }\n`;\n\nexport default MergedItem;\n","import styled from '@emotion/styled';\n\nimport {openDiffModal} from 'sentry/actionCreators/modal';\nimport {Button} from 'sentry/components/button';\nimport Confirm from 'sentry/components/confirm';\nimport {PanelHeader} from 'sentry/components/panels';\nimport {t, tct} from 'sentry/locale';\nimport GroupingStore from 'sentry/stores/groupingStore';\nimport {useLegacyStore} from 'sentry/stores/useLegacyStore';\nimport {space} from 'sentry/styles/space';\nimport {Group, Organization, Project} from 'sentry/types';\n\ntype Props = {\n  groupId: Group['id'];\n  onToggleCollapse: () => void;\n  onUnmerge: () => void;\n  orgId: Organization['slug'];\n  project: Project;\n};\n\nexport function MergedToolbar({\n  groupId,\n  project,\n  orgId,\n  onUnmerge,\n  onToggleCollapse,\n}: Props) {\n  const {\n    unmergeList,\n    mergedItems,\n    unmergeLastCollapsed,\n    unmergeDisabled,\n    enableFingerprintCompare,\n  } = useLegacyStore(GroupingStore);\n\n  const unmergeCount = unmergeList?.size ?? 0;\n\n  function handleShowDiff(event: React.MouseEvent) {\n    event.stopPropagation();\n\n    const entries = unmergeList.entries();\n\n    // `unmergeList` should only have 2 items in map\n    if (unmergeList.size !== 2) {\n      return;\n    }\n\n    // only need eventId, not fingerprint\n    const [baseEventId, targetEventId] = Array.from(entries).map(\n      ([, eventId]) => eventId\n    );\n\n    openDiffModal({\n      targetIssueId: groupId,\n      project,\n      baseIssueId: groupId,\n      orgId,\n      baseEventId,\n      targetEventId,\n    });\n  }\n\n  const unmergeDisabledReason =\n    mergedItems.length <= 1\n      ? t('To unmerge, the list must contain 2 or more items')\n      : unmergeList.size === 0\n      ? t('To unmerge, 1 or more items must be selected')\n      : GroupingStore.isAllUnmergedSelected()\n      ? t('We are unable to unmerge all items at once')\n      : undefined;\n\n  return (\n    <PanelHeader hasButtons>\n      <div>\n        <Confirm\n          disabled={unmergeDisabled}\n          onConfirm={onUnmerge}\n          message={t(\n            'These events will be unmerged and grouped into a new issue. Are you sure you want to unmerge these events?'\n          )}\n        >\n          <Button size=\"sm\" title={unmergeDisabledReason}>\n            {mergedItems.length <= 1\n              ? t('Unmerge')\n              : tct('Unmerge ([itemsSelectedQuantity])', {\n                  itemsSelectedQuantity: unmergeCount,\n                })}\n          </Button>\n        </Confirm>\n\n        <CompareButton\n          size=\"sm\"\n          disabled={!enableFingerprintCompare}\n          onClick={handleShowDiff}\n          title={\n            !enableFingerprintCompare\n              ? t('To compare, exactly 2 items must be selected')\n              : undefined\n          }\n        >\n          {t('Compare')}\n        </CompareButton>\n      </div>\n      <Button size=\"sm\" onClick={onToggleCollapse}>\n        {unmergeLastCollapsed ? t('Expand All') : t('Collapse All')}\n      </Button>\n    </PanelHeader>\n  );\n}\n\nconst CompareButton = styled(Button)`\n  margin-left: ${space(1)};\n`;\n","import {Fragment} from 'react';\n\nimport EmptyStateWarning from 'sentry/components/emptyStateWarning';\nimport Pagination from 'sentry/components/pagination';\nimport {Panel, PanelBody} from 'sentry/components/panels';\nimport QueryCount from 'sentry/components/queryCount';\nimport {t} from 'sentry/locale';\nimport {Fingerprint} from 'sentry/stores/groupingStore';\nimport {Group, Organization, Project} from 'sentry/types';\nimport withOrganization from 'sentry/utils/withOrganization';\n\nimport MergedItem from './mergedItem';\nimport {MergedToolbar} from './mergedToolbar';\n\ntype Props = {\n  groupId: Group['id'];\n  /*\n   * From GroupingStore.onToggleCollapseFingerprints\n   */\n  onToggleCollapse: () => void;\n  /**\n   * From GroupMergedView -> handleUnmerge\n   */\n  onUnmerge: () => void;\n  organization: Organization;\n  project: Project;\n  fingerprints?: Fingerprint[];\n  pageLinks?: string;\n};\n\nfunction MergedList({\n  fingerprints = [],\n  pageLinks,\n  onToggleCollapse,\n  onUnmerge,\n  organization,\n  groupId,\n  project,\n}: Props) {\n  const fingerprintsWithLatestEvent = fingerprints.filter(\n    ({latestEvent}) => !!latestEvent\n  );\n  const hasResults = fingerprintsWithLatestEvent.length > 0;\n\n  if (!hasResults) {\n    return (\n      <Panel>\n        <EmptyStateWarning>\n          <p>{t(\"There don't seem to be any hashes for this issue.\")}</p>\n        </EmptyStateWarning>\n      </Panel>\n    );\n  }\n\n  return (\n    <Fragment>\n      <h4>\n        <span>{t('Merged fingerprints with latest event')}</span>{' '}\n        <QueryCount count={fingerprintsWithLatestEvent.length} />\n      </h4>\n\n      <Panel>\n        <MergedToolbar\n          onToggleCollapse={onToggleCollapse}\n          onUnmerge={onUnmerge}\n          orgId={organization.slug}\n          project={project}\n          groupId={groupId}\n        />\n\n        <PanelBody>\n          {fingerprintsWithLatestEvent.map(fingerprint => (\n            <MergedItem\n              key={fingerprint.id}\n              organization={organization}\n              fingerprint={fingerprint}\n              totalFingerprint={fingerprintsWithLatestEvent.length}\n            />\n          ))}\n        </PanelBody>\n      </Panel>\n      {pageLinks && <Pagination pageLinks={pageLinks} />}\n    </Fragment>\n  );\n}\n\nexport default withOrganization(MergedList);\n","import {Component} from 'react';\nimport {RouteComponentProps} from 'react-router';\nimport * as qs from 'query-string';\n\nimport {Alert} from 'sentry/components/alert';\nimport * as Layout from 'sentry/components/layouts/thirds';\nimport LoadingError from 'sentry/components/loadingError';\nimport LoadingIndicator from 'sentry/components/loadingIndicator';\nimport {t} from 'sentry/locale';\nimport GroupingStore, {Fingerprint} from 'sentry/stores/groupingStore';\nimport {Group, Organization, Project} from 'sentry/types';\nimport withOrganization from 'sentry/utils/withOrganization';\n\nimport MergedList from './mergedList';\n\ntype Props = RouteComponentProps<\n  {groupId: Group['id']; orgId: Organization['slug']},\n  {}\n> & {\n  organization: Organization;\n  project: Project;\n};\n\ntype State = {\n  error: boolean;\n  loading: boolean;\n  mergedItems: Array<Fingerprint>;\n  query: string;\n  mergedLinks?: string;\n};\n\nclass GroupMergedView extends Component<Props, State> {\n  state: State = {\n    mergedItems: [],\n    loading: true,\n    error: false,\n    query: this.props.location.query.query || '',\n  };\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    if (\n      nextProps.params.groupId !== this.props.params.groupId ||\n      nextProps.location.search !== this.props.location.search\n    ) {\n      const queryParams = nextProps.location.query;\n      this.setState(\n        {\n          query: queryParams.query,\n        },\n        this.fetchData\n      );\n    }\n  }\n\n  componentWillUnmount() {\n    this.listener?.();\n  }\n\n  onGroupingChange = ({mergedItems, mergedLinks, loading, error}) => {\n    if (mergedItems) {\n      this.setState({\n        mergedItems,\n        mergedLinks,\n        loading: typeof loading !== 'undefined' ? loading : false,\n        error: typeof error !== 'undefined' ? error : false,\n      });\n    }\n  };\n\n  listener = GroupingStore.listen(this.onGroupingChange, undefined);\n\n  getEndpoint() {\n    const {params, location} = this.props;\n    const {groupId} = params;\n\n    const queryParams = {\n      ...location.query,\n      limit: 50,\n      query: this.state.query,\n    };\n\n    return `/issues/${groupId}/hashes/?${qs.stringify(queryParams)}`;\n  }\n\n  fetchData = () => {\n    GroupingStore.onFetch([\n      {\n        endpoint: this.getEndpoint(),\n        dataKey: 'merged',\n        queryParams: this.props.location.query,\n      },\n    ]);\n  };\n\n  handleUnmerge = () => {\n    GroupingStore.onUnmerge({\n      groupId: this.props.params.groupId,\n      loadingMessage: t('Unmerging events\\u2026'),\n      successMessage: t('Events successfully queued for unmerging.'),\n      errorMessage: t('Unable to queue events for unmerging.'),\n    });\n  };\n\n  render() {\n    const {project, params} = this.props;\n    const {groupId} = params;\n    const {loading: isLoading, error, mergedItems, mergedLinks} = this.state;\n    const isError = error && !isLoading;\n    const isLoadedSuccessfully = !isError && !isLoading;\n\n    return (\n      <Layout.Body>\n        <Layout.Main fullWidth>\n          <Alert type=\"warning\">\n            {t(\n              'This is an experimental feature. Data may not be immediately available while we process unmerges.'\n            )}\n          </Alert>\n\n          {isLoading && <LoadingIndicator />}\n          {isError && (\n            <LoadingError\n              message={t('Unable to load merged events, please try again later')}\n              onRetry={this.fetchData}\n            />\n          )}\n\n          {isLoadedSuccessfully && (\n            <MergedList\n              project={project}\n              fingerprints={mergedItems}\n              pageLinks={mergedLinks}\n              groupId={groupId}\n              onUnmerge={this.handleUnmerge}\n              onToggleCollapse={GroupingStore.onToggleCollapseFingerprints}\n            />\n          )}\n        </Layout.Main>\n      </Layout.Body>\n    );\n  }\n}\n\nexport {GroupMergedView};\n\nexport default withOrganization(GroupMergedView);\n"],"names":["storeConfig","api","Client","init","state","this","getInitialState","Object","entries","forEach","_ref","key","value","mergedItems","unmergeList","Map","unmergeState","unmergeDisabled","unmergeLastCollapsed","enableFingerprintCompare","similarItems","filteredSimilarItems","similarLinks","mergeState","mergeList","mergedLinks","mergeDisabled","loading","error","setStateForId","map","idOrIds","newState","toArray","id","mergedState","has","get","set","isAllUnmergedSelected","lockedItems","Array","from","values","filter","_ref2","busy","size","_ref3","latestEvent","length","onFetch","toFetchArray","requests","triggerFetchState","promises","_ref4","endpoint","queryParams","dataKey","Promise","resolve","reject","request","method","data","success","_","resp","links","getResponseHeader","err","responseJSON","detail","responseProcessors","merged","items","newItemsMap","newItems","item","newItem","eventCount","children","push","childId","childLabel","lastSeen","similar","_ref5","issue","scoreMap","isBelowThreshold","scores","arguments","undefined","keys","find","score","checkBelowThreshold","scoresByInterface","scoreKey","reduce","acc","_ref6","interfaceName","String","split","aggregate","_ref7","allScores","_ref8","avg","sum","_ref9","all","then","resultsArray","_ref10","onToggleMerge","checked","includes","triggerMergeState","onToggleUnmerge","_ref11","fingerprint","eventId","delete","triggerUnmergeState","onUnmerge","_ref12","groupId","loadingMessage","successMessage","errorMessage","ids","Error","addLoadingMessage","query","addSuccessMessage","clear","addErrorMessage","complete","onMerge","_ref13","params","projectId","orgId","mergeGroups","itemIds","merge","parent","trigger","mergedParent","onToggleCollapseFingerprints","_ref14","collapsed","onToggleCollapseFingerprint","_ref15","_ref16","pick","getState","createStore","MergedItem","Component","constructor","_defineProperty","GroupingStore","onGroupChange","props","stateForId","setState","prevState","handleLabelClick","event","preventDefault","handleCheckClick","renderFingerprint","label","_jsx","Tooltip","title","render","organization","totalFingerprint","checkboxDisabled","_jsxs","MergedGroup","Controls","expanded","ActionWrapper","onClick","handleToggle","disabled","t","Checkbox","onChange","FingerprintLabel","htmlFor","Collapse","handleToggleEvents","IconChevron","direction","MergedEventList","className","EventDetails","EventOrGroupHeader","hideIcons","hideLevel","source","displayName","_styled","target","p","space","theme","innerBorder","backgroundSecondary","text","familyMono","name","styles","background","MergedToolbar","project","onToggleCollapse","useLegacyStore","unmergeCount","unmergeDisabledReason","PanelHeader","hasButtons","Confirm","onConfirm","message","Button","tct","itemsSelectedQuantity","CompareButton","stopPropagation","baseEventId","targetEventId","openDiffModal","targetIssueId","baseIssueId","MergedList","fingerprints","pageLinks","fingerprintsWithLatestEvent","Fragment","QueryCount","count","Panel","slug","PanelBody","Pagination","EmptyStateWarning","withOrganization","GroupMergedView","location","onGroupingChange","getEndpoint","componentDidMount","fetchData","componentWillReceiveProps","nextProps","search","componentWillUnmount","listener","limit","qs","isLoading","isError","isLoadedSuccessfully","Layout","fullWidth","Alert","type","LoadingIndicator","LoadingError","onRetry","handleUnmerge"],"sourceRoot":""}