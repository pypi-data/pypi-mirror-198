/* -*- mode: c++ -*- */
// Scanner definition for Beancount's DSL (with RE/flex).
//
// See RE/flex manual: https://www.genivia.com/doc/reflex/html/

%top{
#include "beancount/cparser/parser.h"    /* Generated by bison. */
#include "beancount/cparser/location.h"  /* Generated by bison %locations. */
#include "beancount/ccore/number.h"
#include "beancount/ccore/date.h"

#include <utility>
#include <cassert>

#include "reflex/matcher.h"
#include "absl/strings/string_view.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/escaping.h"
#include "absl/time/civil_time.h"
#include "absl/status/statusor.h"

namespace beancount {
namespace scanner {

// Using declarations for symbols in the scanner implementation only.
using beancount::parser::Parser;

// A default location object to reuse to avoid having to construct one where
// it's not needed.
static beancount::parser::location kLocation;

#define DEFLOC location()
//#define DEFLOC kLocation  // This saves only 10ms. Not worth it.


}  // namespace scanner
}  // namespace beancount
}

//- Definitions ---------------------------------------------------------------

// This option generates a ascnner that works with Bison 3.2 C++ complete
// symbols, specified by %define api.value.type variant and %define
// api.token.constructor in a Bison grammar file. This option also sets option
// −−bison-cc and sets −−token-type to the parser's symbol_type, and sets
// −−token-eof to 0, assuming these options are not specified already. Combine
// this option with −−bison-locations to support the Bison %locations feature.
%option bison-complete

// This option generates a scanner that works with Bison with locations enabled.
%option bison-locations

%option bison-cc-namespace=beancount::parser
%option bison-cc-parser=Parser

// Redirect scanner errors to raising a parser-level exception. The doc says:
//
//   This suppresses the default rule that echoes all unmatched input text when
//   no rule matches. With the −−flex option, the scanner reports "scanner
//   jammed" when no rule matches by calling yyFlexLexer::LexerError("scanner
//   jammed"). Without the −−flex and −−debug options, a std::runtime exception
//   is raised by invoking AbstractLexer::lexer_error("scanner jammed"). To
//   throw a custom exception instead, use option −−exception or override the
//   virtual method lexer_error in a derived lexer class. The virtual methods
//   LexerError and lexer_error may be redefined by a user-specified derived
//   lexer class, see Inheriting Lexer/yyFlexLexer . Without the −−flex option,
//   but with the −−debug option, the default rule is suppressed without
//   invoking lexer_error to raise an exception. See also options
//   −−exception=VALUE and -S (or −−find)."
//
// Note: syntax_error is never really invoked; because we have a default
// matching rule that gobbles up invalid tokens.
%option nodefault
%option exception="Parser::syntax_error(location(), absl::StrCat(\"Unknown token: '\", matcher().str(), \"'\"))"

%option namespace=beancount::scanner
%option lexer=Scanner

// Note: You can use a %class{} to insert data members into the scanner.

%option tabs=8

// Unicode matching is enabled with %option unicode.
%option unicode

%option indent
%option fast

// Profiling options.
// Observations:
// - The most expensive rule is the newline matching rule. Not sure why.
// - Find a way to make creating the location() object conditional and cheaper.
//   We don't need it everywhere. It's a virtual method. Only create and pass it
//   where needed.
// - Accounts and currencies are also very expensive to compute.
//
// NOTE(blais): You should turn this in to a Bazel config setting.
// %option perf-report

// States.
%x INVALID
%x IGNORE

// Patterns for the international components of the names of accounts.
ACCOUNTTYPE     [\p{Lu}\p{Lo}][\p{L}\p{N}\-]*
ACCOUNTNAME     [\p{Lu}\p{Lo}\p{N}][\p{L}\p{N}\-]*

// Characters that may be used as flags. Single-character letters may also be
// used as flags, but must be prefixed by a quote, as in "'P' for "P".
FLAGS           [!&#?%]

DATE		\d{4}[\-/]\d{2}[\-/]\d{2}
TIME		\d{1,2}:\d{2}(:\d{2})?

//- Rules ---------------------------------------------------------------------

// Note about returning error values:
//
// Returning YYUNDEF tells the parser that some lexical error was found. It will
// emit an error message about an “invalid token”, and enter error-recovery (see
// section Error Recovery). Returning an unknown token kind results in the exact
// same behavior.
//
// Returning YYerror requires the parser to enter error-recovery WITHOUT
// emitting an error message. This way the lexical analyzer can produce an
// accurate error messages about the invalid input (something the parser cannot
// do), and yet benefit from the error-recovery features of the parser.

%%

/* Newlines matter. */
\n { return Parser::make_EOL(DEFLOC); }

/* Indentation.
 *
 * This makes use of RE/flex's indentation stops feature and results in much
 * tighter indentation handling.
 */
^\h+                      // nodent, text is aligned to current margin column
^\h+\i                    { return Parser::make_INDENT(DEFLOC); }
^\h*\j                    { return Parser::make_DEDENT(DEFLOC); }
\j                        { return Parser::make_DEDENT(DEFLOC); }

/* Whitespace. */
[ \t\r]+                  /* Ignored whitespace. */
;.*                       /* Eat up Comments, anywhere. */

/* Boolean values. Must be before currencies. */
TRUE\b {
  return Parser::make_BOOL(true, DEFLOC);
}

FALSE\b {
  return Parser::make_BOOL(false, DEFLOC);
}

NULL\b {
  return Parser::make_NONE(DEFLOC);
}

 /* Currencies.
  *
  * A currency (or sometimes called "commodities") is a string which
  * - Begins with either a letter or a slash (/) character.
  * - Contains at least one letter.
  * - Ends with either a letter or a number.
  * - May contain the following special characters within: period (.),
  *   underscore (_), dash (-), or quote (').
  * The pattern has to be kept in sync with beancount.core.amount.CURRENCY_RE.
  *
  * In Beancount v3 (C++ version), a single character (e.g. "V" for Visa) is a
  * valid currency. v2 uses the GNU flex scanner which does not have the
  * lookahead capability required to make this possible but the v3 C++ scanner
  * uses Genivia's RE-Flex which supports a lookahead and it will.
  *
  * Example currencies:
  *   "AAPL" (stock)
  *   "V" (single-character stock)
  *   "NT.TO" (stock on another market)
  *   "TLT_040921C144" (equity option)
  *   "/6J" (currency futures)
  *   "/NQH21" (commodity futures)
  *   "/NQH21_QNEG21C13100" (futures option)
  *
  * Counter-examples:
  * - "/6.3": If a currency begins with a slash, the following pattern has to
  *   include at least one letter. "/6J" is a valid currency, but "/6.3" is not.
  * - "CAC_": A currency cannot end with a special character; it has to end with
  *   either an uppercase letter or a number ("C345" is a valid currency, but
  *   "C_" is not).
  *
  * Note: In this scanner we locate the rule above that matching SLASH on
  * purpose so that a name starting with '/' for a futures contract will match
  * with higher priority than that matching a divide '/' character.
  *
  * Keep in sync with {edefe3fbe907}.
  */
[A-Z][A-Z0-9\'\.\_\-]*[A-Z0-9]?\b {
  return Parser::make_CURRENCY(str(), location());
}
\/[A-Z0-9\'\.\_\-]*[A-Z]([A-Z0-9\'\.\_\-]*[A-Z0-9])? {
  return Parser::make_CURRENCY(str(), location());
}

/* Characters with special meanings. */
\|		{ return Parser::make_PIPE(DEFLOC); }
@@		{ return Parser::make_ATAT(DEFLOC); }
@		{ return Parser::make_AT(DEFLOC); }
\{\{		{ return Parser::make_LCURLCURL(DEFLOC); }
\}\}		{ return Parser::make_RCURLCURL(DEFLOC); }
\{		{ return Parser::make_LCURL(DEFLOC); }
\}		{ return Parser::make_RCURL(DEFLOC); }
,		{ return Parser::make_COMMA(DEFLOC); }
\~		{ return Parser::make_TILDE(DEFLOC); }
\+		{ return Parser::make_PLUS(DEFLOC); }
\-		{ return Parser::make_MINUS(DEFLOC); }
\/		{ return Parser::make_SLASH(DEFLOC); }
\(		{ return Parser::make_LPAREN(DEFLOC); }
\)		{ return Parser::make_RPAREN(DEFLOC); }
\#		{ return Parser::make_HASH(DEFLOC); }
\*		{ return Parser::make_ASTERISK(DEFLOC); }
\:		{ return Parser::make_COLON(DEFLOC); }

{FLAGS} {
  return Parser::make_FLAG(chr(), DEFLOC);
}
'[A-Z] {
  return Parser::make_FLAG(text()[1], DEFLOC);
}

/* Keywords. */
txn		{ return Parser::make_TXN(DEFLOC); }
balance		{ return Parser::make_BALANCE(DEFLOC); }
open		{ return Parser::make_OPEN(DEFLOC); }
close		{ return Parser::make_CLOSE(DEFLOC); }
commodity	{ return Parser::make_COMMODITY(DEFLOC); }
pad		{ return Parser::make_PAD(DEFLOC); }
event		{ return Parser::make_EVENT(DEFLOC); }
query		{ return Parser::make_QUERY(DEFLOC); }
custom		{ return Parser::make_CUSTOM(DEFLOC); }
price		{ return Parser::make_PRICE(DEFLOC); }
note		{ return Parser::make_NOTE(DEFLOC); }
document	{ return Parser::make_DOCUMENT(DEFLOC); }
pushtag	        { return Parser::make_PUSHTAG(DEFLOC); }
poptag		{ return Parser::make_POPTAG(DEFLOC); }
pushmeta	{ return Parser::make_PUSHMETA(DEFLOC); }
popmeta		{ return Parser::make_POPMETA(DEFLOC); }
option		{ return Parser::make_OPTION(DEFLOC); }
options		{ return Parser::make_OPTIONS(DEFLOC); }
plugin		{ return Parser::make_PLUGIN(DEFLOC); }
include		{ return Parser::make_INCLUDE(DEFLOC); }

/* Date or date/time.
 *
 * Note that we're not parsing time separately because absorbing that pattern at
 * the top level adds more than 10% to the total parsing time, so we process it
 * as an optional group only after dates.
 */
{DATE}([ \t]+({TIME}))?\b {
  // Parse date.
  const auto& m = matcher();
  auto sdate = ParseDateFromString(m.begin());
  if (!sdate.ok()) {
    return Parser::make_YYUNDEF(std::string(sdate.status().message()), location());
  }
  const absl::CivilDay& date = sdate.value();

  // If not time is available, return a date.
  if (size() == 10) {
    return Parser::make_DATE(date, location());
  }

  // Otherwise, parse the time.
  const char* timestr = m.begin() + 10;
  size_t num_ws = 0;
  for (; *timestr == ' ' || *timestr == '\t'; timestr++, num_ws++) {}
  std::string_view timeview{timestr, m.size() - 10 - num_ws};
  auto stime = ParseTimeFromString(timeview);
  if (!stime.ok()) {
    return Parser::make_YYUNDEF(std::string(stime.status().message()), location());
  }

  // Merge date and time.
  const absl::CivilSecond& time = stime.value();
  absl::CivilSecond datetime{
    date.year(), date.month(), date.day(),
    time.hour(), time.minute(), time.second()};
  return Parser::make_DATETIME(datetime, location());
}

/* Account names. */
{ACCOUNTTYPE}(:{ACCOUNTNAME})+ {
  return Parser::make_ACCOUNT(str(), location());
}

/* String literals. */
\"([^\\\"]|\\.)*\" {
  // Check for very long strings and issue an error. This helps narrow down
  // errors when an unterminated string occurs.
  if (matcher().size() >= 16384) {
    return Parser::make_YYUNDEF("String too long", location());
  }

  std::string_view contents(matcher().begin() + 1, matcher().size() - 2);
  std::string unescaped;
  std::string error_message;
  if (!absl::CUnescape(contents, &unescaped, &error_message)) {
    return Parser::make_YYUNDEF(error_message, location());
  }

  return Parser::make_STRING(std::move(unescaped), location());
}

/* Numbers. */
(\d+|\d[0-9,]+\d)(\.\d*)? {
  // Strip commas from the local buffer (without allocating memory).
  static char buffer[1024];
  if (size() < 1024) {
    CopySansCommas(matcher().begin(), buffer, matcher().size());
  }
  decimal::Decimal number(buffer);
  return Parser::make_NUMBER(number, location());
}

/* Tags. */
#[A-Za-z0-9\-_/.]+ {
  std::string text = {matcher().begin() + 1, matcher().size() - 1};
  return Parser::make_TAG(std::move(text), location());
}

/* Links. */
\^[A-Za-z0-9\-_/.]+ {
  std::string text = {matcher().begin() + 1, matcher().size() - 1};
  return Parser::make_LINK(std::move(text), location());
}

/* Keys. */
[a-z][a-zA-Z0-9\-_]+/: {
  return Parser::make_KEY(str(), location());
}

/* Lines starting with an asterisk, a colon, an hash, or a character in the
 * FLAGS characters set are ignored. This rule is inserted here to give higher
 * precedence to rules matching valid tokens. */
^[\*\:\#]/.	{ start(IGNORE); }
^{FLAGS}/.	{ start(IGNORE); }

/* Default rule. {bf253a29a820} */
. {
  matcher().unput(*text());
  start(INVALID);
}

<<EOF>> {
  /* If indented, dedent and repeat on the next EOF. */
  if (matcher().stops().size() > 0) {
    matcher().stops().pop_back();
    return Parser::make_DEDENT(location());
  }

  /* Mark the end of file with an explicit token. */
  return Parser::make_YYEOF(location());
}

/* Invalid input: skip over to to the next whitespace character. */
<INVALID>[^ \t\n\r]+ {

  // Go back to initial state.
  start(INITIAL);

  // Return special error token generated by Bison.
  //
  // Note that the error message never makes it through to Bison here. It simply
  // logs an "expected invalid token" message, but with the location. Meh.
  return Parser::make_YYUNDEF(absl::StrCat("Invalid token: '", str(), "'"),
                              location());
}

/* Ignore input till the newline. */
<IGNORE>.* {
    start(INITIAL);
}


%%

//-----------------------------------------------------------------------------
// Code: Scanner Body

namespace beancount {
namespace scanner {

}  // namespace scanner
}  // namespace beancount
