Metadata-Version: 2.1
Name: babichjacob-bounded-channel
Version: 0.3.2
Summary: A Python implementation of tokio::sync::mpsc::channel
Home-page: https://github.com/babichjacob/python-bounded-channel
License: MIT
Author: J or Jacob Babich
Author-email: jacobbabichpublic+git@gmail.com
Requires-Python: >=3.5,<4.0
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Requires-Dist: babichjacob-option-and-result (>=0.2.0,<0.3.0)
Project-URL: Repository, https://github.com/babichjacob/python-bounded-channel
Description-Content-Type: text/markdown

<h1 align="center">🪢 Bounded Channel</h1>

This library uses documentation copied and pasted from [Tokio's `sync::mpsc` library](https://docs.rs/tokio/latest/tokio/sync/mpsc/index.html), which they have generously published under the MIT license. 🙏

This is a Python implementation of [their bounded channel](https://docs.rs/tokio/latest/tokio/sync/mpsc/fn.channel.html).

## 💻 Installation

This package is [published to PyPI as `babichjacob-bounded-channel`](https://pypi.org/project/babichjacob-bounded-channel/).

## 🛠 Usage

```py
from asyncio import create_task, gather, run, sleep
from itertools import count

from bounded_channel import bounded_channel, Receiver, Sender


async def producer(sender: Sender[int]):
    "Produces integer values as long as there is a receiver to receive them"
    for value in count():
        await sleep(0.02)

        res = await sender.send(value)

        # No receivers are listening anymore
        if res.is_err():
            break


async def consumer(receiver: Receiver[int]):
    async for value in receiver:
        await sleep(0.03)

        print("received", value)

        if value >= 100:
            # Signal to please stop producing values
            receiver.close()
            # From then on, the remaining buffered values will be received
            # until they run out for good (to a maximum of 165 or so)
            # (it's dependent on the difference of speed between the producer and consumer)

    # Alternatively, the loop could be broken out of
    # and any extra buffered values would be ignored


async def main():
    sender, receiver = channel(64)

    producer_task = create_task(producer(sender))
    consumer_task = create_task(consumer(receiver))

    # Drop extra references to the sender and receiver
    del sender
    del receiver
    # so their RAII semantics behave properly

    await gather(producer_task, consumer_task)


run(main())
```

## 😵 Help! I have a question

Create an issue and I'll try to help.

## 😡 Fix! There is something that needs improvement

Create an issue or pull request and I'll try to fix.

## 📄 License

MIT

## 🙏 Attribution

_This README was generated with ❤️ by [readme-md-generator](https://github.com/kefranabg/readme-md-generator)_

