// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/data/service/common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/core/framework/graph.pb.h"
#include "tensorflow/core/protobuf/data_service.pb.h"
#include "tensorflow/core/protobuf/snapshot.pb.h"
#include "tensorflow/tsl/protobuf/status.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto;
namespace tensorflow {
namespace data {
class DataTransferServerInfo;
struct DataTransferServerInfoDefaultTypeInternal;
extern DataTransferServerInfoDefaultTypeInternal _DataTransferServerInfo_default_instance_;
class DatasetDef;
struct DatasetDefDefaultTypeInternal;
extern DatasetDefDefaultTypeInternal _DatasetDef_default_instance_;
class IterationKeyDef;
struct IterationKeyDefDefaultTypeInternal;
extern IterationKeyDefDefaultTypeInternal _IterationKeyDef_default_instance_;
class SnapshotStreamInfo;
struct SnapshotStreamInfoDefaultTypeInternal;
extern SnapshotStreamInfoDefaultTypeInternal _SnapshotStreamInfo_default_instance_;
class SnapshotTaskDef;
struct SnapshotTaskDefDefaultTypeInternal;
extern SnapshotTaskDefDefaultTypeInternal _SnapshotTaskDef_default_instance_;
class SnapshotTaskProgress;
struct SnapshotTaskProgressDefaultTypeInternal;
extern SnapshotTaskProgressDefaultTypeInternal _SnapshotTaskProgress_default_instance_;
class TaskDef;
struct TaskDefDefaultTypeInternal;
extern TaskDefDefaultTypeInternal _TaskDef_default_instance_;
class TaskInfo;
struct TaskInfoDefaultTypeInternal;
extern TaskInfoDefaultTypeInternal _TaskInfo_default_instance_;
}  // namespace data
}  // namespace tensorflow
PROTOBUF_NAMESPACE_OPEN
template<> ::tensorflow::data::DataTransferServerInfo* Arena::CreateMaybeMessage<::tensorflow::data::DataTransferServerInfo>(Arena*);
template<> ::tensorflow::data::DatasetDef* Arena::CreateMaybeMessage<::tensorflow::data::DatasetDef>(Arena*);
template<> ::tensorflow::data::IterationKeyDef* Arena::CreateMaybeMessage<::tensorflow::data::IterationKeyDef>(Arena*);
template<> ::tensorflow::data::SnapshotStreamInfo* Arena::CreateMaybeMessage<::tensorflow::data::SnapshotStreamInfo>(Arena*);
template<> ::tensorflow::data::SnapshotTaskDef* Arena::CreateMaybeMessage<::tensorflow::data::SnapshotTaskDef>(Arena*);
template<> ::tensorflow::data::SnapshotTaskProgress* Arena::CreateMaybeMessage<::tensorflow::data::SnapshotTaskProgress>(Arena*);
template<> ::tensorflow::data::TaskDef* Arena::CreateMaybeMessage<::tensorflow::data::TaskDef>(Arena*);
template<> ::tensorflow::data::TaskInfo* Arena::CreateMaybeMessage<::tensorflow::data::TaskInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tensorflow {
namespace data {

enum SnapshotStreamInfo_State : int {
  SnapshotStreamInfo_State_UNSPECIFIED = 0,
  SnapshotStreamInfo_State_ASSIGNED = 1,
  SnapshotStreamInfo_State_ORPHAN = 2,
  SnapshotStreamInfo_State_UNKNOWN = 3,
  SnapshotStreamInfo_State_DONE = 4,
  SnapshotStreamInfo_State_SnapshotStreamInfo_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SnapshotStreamInfo_State_SnapshotStreamInfo_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SnapshotStreamInfo_State_IsValid(int value);
constexpr SnapshotStreamInfo_State SnapshotStreamInfo_State_State_MIN = SnapshotStreamInfo_State_UNSPECIFIED;
constexpr SnapshotStreamInfo_State SnapshotStreamInfo_State_State_MAX = SnapshotStreamInfo_State_DONE;
constexpr int SnapshotStreamInfo_State_State_ARRAYSIZE = SnapshotStreamInfo_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SnapshotStreamInfo_State_descriptor();
template<typename T>
inline const std::string& SnapshotStreamInfo_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SnapshotStreamInfo_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SnapshotStreamInfo_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SnapshotStreamInfo_State_descriptor(), enum_t_value);
}
inline bool SnapshotStreamInfo_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SnapshotStreamInfo_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SnapshotStreamInfo_State>(
    SnapshotStreamInfo_State_descriptor(), name, value);
}
enum TargetWorkers : int {
  TARGET_WORKERS_UNSPECIFIED = 0,
  TARGET_WORKERS_AUTO = 1,
  TARGET_WORKERS_ANY = 2,
  TARGET_WORKERS_LOCAL = 3,
  TargetWorkers_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TargetWorkers_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TargetWorkers_IsValid(int value);
constexpr TargetWorkers TargetWorkers_MIN = TARGET_WORKERS_UNSPECIFIED;
constexpr TargetWorkers TargetWorkers_MAX = TARGET_WORKERS_LOCAL;
constexpr int TargetWorkers_ARRAYSIZE = TargetWorkers_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TargetWorkers_descriptor();
template<typename T>
inline const std::string& TargetWorkers_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TargetWorkers>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TargetWorkers_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TargetWorkers_descriptor(), enum_t_value);
}
inline bool TargetWorkers_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TargetWorkers* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TargetWorkers>(
    TargetWorkers_descriptor(), name, value);
}
// ===================================================================

class DatasetDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.DatasetDef) */ {
 public:
  inline DatasetDef() : DatasetDef(nullptr) {}
  ~DatasetDef() override;
  explicit PROTOBUF_CONSTEXPR DatasetDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatasetDef(const DatasetDef& from);
  DatasetDef(DatasetDef&& from) noexcept
    : DatasetDef() {
    *this = ::std::move(from);
  }

  inline DatasetDef& operator=(const DatasetDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatasetDef& operator=(DatasetDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatasetDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatasetDef* internal_default_instance() {
    return reinterpret_cast<const DatasetDef*>(
               &_DatasetDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DatasetDef& a, DatasetDef& b) {
    a.Swap(&b);
  }
  inline void Swap(DatasetDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatasetDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatasetDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatasetDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatasetDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatasetDef& from) {
    DatasetDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatasetDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.data.DatasetDef";
  }
  protected:
  explicit DatasetDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGraphFieldNumber = 1,
  };
  // .tensorflow.GraphDef graph = 1;
  bool has_graph() const;
  private:
  bool _internal_has_graph() const;
  public:
  void clear_graph();
  const ::tensorflow::GraphDef& graph() const;
  PROTOBUF_NODISCARD ::tensorflow::GraphDef* release_graph();
  ::tensorflow::GraphDef* mutable_graph();
  void set_allocated_graph(::tensorflow::GraphDef* graph);
  private:
  const ::tensorflow::GraphDef& _internal_graph() const;
  ::tensorflow::GraphDef* _internal_mutable_graph();
  public:
  void unsafe_arena_set_allocated_graph(
      ::tensorflow::GraphDef* graph);
  ::tensorflow::GraphDef* unsafe_arena_release_graph();

  // @@protoc_insertion_point(class_scope:tensorflow.data.DatasetDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::tensorflow::GraphDef* graph_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class IterationKeyDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.IterationKeyDef) */ {
 public:
  inline IterationKeyDef() : IterationKeyDef(nullptr) {}
  ~IterationKeyDef() override;
  explicit PROTOBUF_CONSTEXPR IterationKeyDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IterationKeyDef(const IterationKeyDef& from);
  IterationKeyDef(IterationKeyDef&& from) noexcept
    : IterationKeyDef() {
    *this = ::std::move(from);
  }

  inline IterationKeyDef& operator=(const IterationKeyDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline IterationKeyDef& operator=(IterationKeyDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IterationKeyDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const IterationKeyDef* internal_default_instance() {
    return reinterpret_cast<const IterationKeyDef*>(
               &_IterationKeyDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(IterationKeyDef& a, IterationKeyDef& b) {
    a.Swap(&b);
  }
  inline void Swap(IterationKeyDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IterationKeyDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IterationKeyDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IterationKeyDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IterationKeyDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IterationKeyDef& from) {
    IterationKeyDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IterationKeyDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.data.IterationKeyDef";
  }
  protected:
  explicit IterationKeyDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIterationFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 iteration = 2;
  void clear_iteration();
  int64_t iteration() const;
  void set_iteration(int64_t value);
  private:
  int64_t _internal_iteration() const;
  void _internal_set_iteration(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tensorflow.data.IterationKeyDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int64_t iteration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TaskDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.TaskDef) */ {
 public:
  inline TaskDef() : TaskDef(nullptr) {}
  ~TaskDef() override;
  explicit PROTOBUF_CONSTEXPR TaskDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskDef(const TaskDef& from);
  TaskDef(TaskDef&& from) noexcept
    : TaskDef() {
    *this = ::std::move(from);
  }

  inline TaskDef& operator=(const TaskDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskDef& operator=(TaskDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskDef& default_instance() {
    return *internal_default_instance();
  }
  enum DatasetCase {
    kDatasetDef = 1,
    kPath = 2,
    DATASET_NOT_SET = 0,
  };

  enum OptionalNumConsumersCase {
    kNumConsumers = 7,
    OPTIONAL_NUM_CONSUMERS_NOT_SET = 0,
  };

  static inline const TaskDef* internal_default_instance() {
    return reinterpret_cast<const TaskDef*>(
               &_TaskDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TaskDef& a, TaskDef& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskDef& from) {
    TaskDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.data.TaskDef";
  }
  protected:
  explicit TaskDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatasetIdFieldNumber = 3,
    kWorkerAddressFieldNumber = 8,
    kProcessingModeDefFieldNumber = 10,
    kTaskIdFieldNumber = 4,
    kIterationIdFieldNumber = 5,
    kNumSplitProvidersFieldNumber = 9,
    kNumWorkersFieldNumber = 11,
    kWorkerIndexFieldNumber = 12,
    kUseCrossTrainerCacheFieldNumber = 13,
    kDatasetDefFieldNumber = 1,
    kPathFieldNumber = 2,
    kNumConsumersFieldNumber = 7,
  };
  // string dataset_id = 3;
  void clear_dataset_id();
  const std::string& dataset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dataset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dataset_id();
  PROTOBUF_NODISCARD std::string* release_dataset_id();
  void set_allocated_dataset_id(std::string* dataset_id);
  private:
  const std::string& _internal_dataset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dataset_id(const std::string& value);
  std::string* _internal_mutable_dataset_id();
  public:

  // string worker_address = 8;
  void clear_worker_address();
  const std::string& worker_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_address();
  PROTOBUF_NODISCARD std::string* release_worker_address();
  void set_allocated_worker_address(std::string* worker_address);
  private:
  const std::string& _internal_worker_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_address(const std::string& value);
  std::string* _internal_mutable_worker_address();
  public:

  // .tensorflow.data.ProcessingModeDef processing_mode_def = 10;
  bool has_processing_mode_def() const;
  private:
  bool _internal_has_processing_mode_def() const;
  public:
  void clear_processing_mode_def();
  const ::tensorflow::data::ProcessingModeDef& processing_mode_def() const;
  PROTOBUF_NODISCARD ::tensorflow::data::ProcessingModeDef* release_processing_mode_def();
  ::tensorflow::data::ProcessingModeDef* mutable_processing_mode_def();
  void set_allocated_processing_mode_def(::tensorflow::data::ProcessingModeDef* processing_mode_def);
  private:
  const ::tensorflow::data::ProcessingModeDef& _internal_processing_mode_def() const;
  ::tensorflow::data::ProcessingModeDef* _internal_mutable_processing_mode_def();
  public:
  void unsafe_arena_set_allocated_processing_mode_def(
      ::tensorflow::data::ProcessingModeDef* processing_mode_def);
  ::tensorflow::data::ProcessingModeDef* unsafe_arena_release_processing_mode_def();

  // int64 task_id = 4;
  void clear_task_id();
  int64_t task_id() const;
  void set_task_id(int64_t value);
  private:
  int64_t _internal_task_id() const;
  void _internal_set_task_id(int64_t value);
  public:

  // int64 iteration_id = 5;
  void clear_iteration_id();
  int64_t iteration_id() const;
  void set_iteration_id(int64_t value);
  private:
  int64_t _internal_iteration_id() const;
  void _internal_set_iteration_id(int64_t value);
  public:

  // int64 num_split_providers = 9;
  void clear_num_split_providers();
  int64_t num_split_providers() const;
  void set_num_split_providers(int64_t value);
  private:
  int64_t _internal_num_split_providers() const;
  void _internal_set_num_split_providers(int64_t value);
  public:

  // int64 num_workers = 11;
  void clear_num_workers();
  int64_t num_workers() const;
  void set_num_workers(int64_t value);
  private:
  int64_t _internal_num_workers() const;
  void _internal_set_num_workers(int64_t value);
  public:

  // int64 worker_index = 12;
  void clear_worker_index();
  int64_t worker_index() const;
  void set_worker_index(int64_t value);
  private:
  int64_t _internal_worker_index() const;
  void _internal_set_worker_index(int64_t value);
  public:

  // bool use_cross_trainer_cache = 13;
  void clear_use_cross_trainer_cache();
  bool use_cross_trainer_cache() const;
  void set_use_cross_trainer_cache(bool value);
  private:
  bool _internal_use_cross_trainer_cache() const;
  void _internal_set_use_cross_trainer_cache(bool value);
  public:

  // .tensorflow.data.DatasetDef dataset_def = 1;
  bool has_dataset_def() const;
  private:
  bool _internal_has_dataset_def() const;
  public:
  void clear_dataset_def();
  const ::tensorflow::data::DatasetDef& dataset_def() const;
  PROTOBUF_NODISCARD ::tensorflow::data::DatasetDef* release_dataset_def();
  ::tensorflow::data::DatasetDef* mutable_dataset_def();
  void set_allocated_dataset_def(::tensorflow::data::DatasetDef* dataset_def);
  private:
  const ::tensorflow::data::DatasetDef& _internal_dataset_def() const;
  ::tensorflow::data::DatasetDef* _internal_mutable_dataset_def();
  public:
  void unsafe_arena_set_allocated_dataset_def(
      ::tensorflow::data::DatasetDef* dataset_def);
  ::tensorflow::data::DatasetDef* unsafe_arena_release_dataset_def();

  // string path = 2;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // int64 num_consumers = 7;
  bool has_num_consumers() const;
  private:
  bool _internal_has_num_consumers() const;
  public:
  void clear_num_consumers();
  int64_t num_consumers() const;
  void set_num_consumers(int64_t value);
  private:
  int64_t _internal_num_consumers() const;
  void _internal_set_num_consumers(int64_t value);
  public:

  void clear_dataset();
  DatasetCase dataset_case() const;
  void clear_optional_num_consumers();
  OptionalNumConsumersCase optional_num_consumers_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.data.TaskDef)
 private:
  class _Internal;
  void set_has_dataset_def();
  void set_has_path();
  void set_has_num_consumers();

  inline bool has_dataset() const;
  inline void clear_has_dataset();

  inline bool has_optional_num_consumers() const;
  inline void clear_has_optional_num_consumers();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dataset_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_address_;
    ::tensorflow::data::ProcessingModeDef* processing_mode_def_;
    int64_t task_id_;
    int64_t iteration_id_;
    int64_t num_split_providers_;
    int64_t num_workers_;
    int64_t worker_index_;
    bool use_cross_trainer_cache_;
    union DatasetUnion {
      constexpr DatasetUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::tensorflow::data::DatasetDef* dataset_def_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    } dataset_;
    union OptionalNumConsumersUnion {
      constexpr OptionalNumConsumersUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int64_t num_consumers_;
    } optional_num_consumers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TaskInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.TaskInfo) */ {
 public:
  inline TaskInfo() : TaskInfo(nullptr) {}
  ~TaskInfo() override;
  explicit PROTOBUF_CONSTEXPR TaskInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskInfo(const TaskInfo& from);
  TaskInfo(TaskInfo&& from) noexcept
    : TaskInfo() {
    *this = ::std::move(from);
  }

  inline TaskInfo& operator=(const TaskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskInfo& operator=(TaskInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskInfo* internal_default_instance() {
    return reinterpret_cast<const TaskInfo*>(
               &_TaskInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TaskInfo& a, TaskInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskInfo& from) {
    TaskInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.data.TaskInfo";
  }
  protected:
  explicit TaskInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkerTagsFieldNumber = 6,
    kTransferServersFieldNumber = 8,
    kWorkerAddressFieldNumber = 1,
    kTaskIdFieldNumber = 2,
    kIterationIdFieldNumber = 3,
    kStartingRoundFieldNumber = 5,
    kWorkerUidFieldNumber = 7,
  };
  // repeated string worker_tags = 6;
  int worker_tags_size() const;
  private:
  int _internal_worker_tags_size() const;
  public:
  void clear_worker_tags();
  const std::string& worker_tags(int index) const;
  std::string* mutable_worker_tags(int index);
  void set_worker_tags(int index, const std::string& value);
  void set_worker_tags(int index, std::string&& value);
  void set_worker_tags(int index, const char* value);
  void set_worker_tags(int index, const char* value, size_t size);
  std::string* add_worker_tags();
  void add_worker_tags(const std::string& value);
  void add_worker_tags(std::string&& value);
  void add_worker_tags(const char* value);
  void add_worker_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& worker_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_worker_tags();
  private:
  const std::string& _internal_worker_tags(int index) const;
  std::string* _internal_add_worker_tags();
  public:

  // repeated .tensorflow.data.DataTransferServerInfo transfer_servers = 8;
  int transfer_servers_size() const;
  private:
  int _internal_transfer_servers_size() const;
  public:
  void clear_transfer_servers();
  ::tensorflow::data::DataTransferServerInfo* mutable_transfer_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::data::DataTransferServerInfo >*
      mutable_transfer_servers();
  private:
  const ::tensorflow::data::DataTransferServerInfo& _internal_transfer_servers(int index) const;
  ::tensorflow::data::DataTransferServerInfo* _internal_add_transfer_servers();
  public:
  const ::tensorflow::data::DataTransferServerInfo& transfer_servers(int index) const;
  ::tensorflow::data::DataTransferServerInfo* add_transfer_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::data::DataTransferServerInfo >&
      transfer_servers() const;

  // string worker_address = 1;
  void clear_worker_address();
  const std::string& worker_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_address();
  PROTOBUF_NODISCARD std::string* release_worker_address();
  void set_allocated_worker_address(std::string* worker_address);
  private:
  const std::string& _internal_worker_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_address(const std::string& value);
  std::string* _internal_mutable_worker_address();
  public:

  // int64 task_id = 2;
  void clear_task_id();
  int64_t task_id() const;
  void set_task_id(int64_t value);
  private:
  int64_t _internal_task_id() const;
  void _internal_set_task_id(int64_t value);
  public:

  // int64 iteration_id = 3;
  void clear_iteration_id();
  int64_t iteration_id() const;
  void set_iteration_id(int64_t value);
  private:
  int64_t _internal_iteration_id() const;
  void _internal_set_iteration_id(int64_t value);
  public:

  // int64 starting_round = 5;
  void clear_starting_round();
  int64_t starting_round() const;
  void set_starting_round(int64_t value);
  private:
  int64_t _internal_starting_round() const;
  void _internal_set_starting_round(int64_t value);
  public:

  // int64 worker_uid = 7;
  void clear_worker_uid();
  int64_t worker_uid() const;
  void set_worker_uid(int64_t value);
  private:
  int64_t _internal_worker_uid() const;
  void _internal_set_worker_uid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tensorflow.data.TaskInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> worker_tags_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::data::DataTransferServerInfo > transfer_servers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_address_;
    int64_t task_id_;
    int64_t iteration_id_;
    int64_t starting_round_;
    int64_t worker_uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SnapshotTaskDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.SnapshotTaskDef) */ {
 public:
  inline SnapshotTaskDef() : SnapshotTaskDef(nullptr) {}
  ~SnapshotTaskDef() override;
  explicit PROTOBUF_CONSTEXPR SnapshotTaskDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotTaskDef(const SnapshotTaskDef& from);
  SnapshotTaskDef(SnapshotTaskDef&& from) noexcept
    : SnapshotTaskDef() {
    *this = ::std::move(from);
  }

  inline SnapshotTaskDef& operator=(const SnapshotTaskDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotTaskDef& operator=(SnapshotTaskDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotTaskDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotTaskDef* internal_default_instance() {
    return reinterpret_cast<const SnapshotTaskDef*>(
               &_SnapshotTaskDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SnapshotTaskDef& a, SnapshotTaskDef& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotTaskDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotTaskDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotTaskDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotTaskDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotTaskDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotTaskDef& from) {
    SnapshotTaskDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotTaskDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.data.SnapshotTaskDef";
  }
  protected:
  explicit SnapshotTaskDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasePathFieldNumber = 1,
    kMetadataFieldNumber = 4,
    kStreamIndexFieldNumber = 2,
    kNumSourcesFieldNumber = 3,
  };
  // string base_path = 1;
  void clear_base_path();
  const std::string& base_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_path();
  PROTOBUF_NODISCARD std::string* release_base_path();
  void set_allocated_base_path(std::string* base_path);
  private:
  const std::string& _internal_base_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_path(const std::string& value);
  std::string* _internal_mutable_base_path();
  public:

  // .tensorflow.data.experimental.DistributedSnapshotMetadata metadata = 4;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::tensorflow::data::experimental::DistributedSnapshotMetadata& metadata() const;
  PROTOBUF_NODISCARD ::tensorflow::data::experimental::DistributedSnapshotMetadata* release_metadata();
  ::tensorflow::data::experimental::DistributedSnapshotMetadata* mutable_metadata();
  void set_allocated_metadata(::tensorflow::data::experimental::DistributedSnapshotMetadata* metadata);
  private:
  const ::tensorflow::data::experimental::DistributedSnapshotMetadata& _internal_metadata() const;
  ::tensorflow::data::experimental::DistributedSnapshotMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::tensorflow::data::experimental::DistributedSnapshotMetadata* metadata);
  ::tensorflow::data::experimental::DistributedSnapshotMetadata* unsafe_arena_release_metadata();

  // int64 stream_index = 2;
  void clear_stream_index();
  int64_t stream_index() const;
  void set_stream_index(int64_t value);
  private:
  int64_t _internal_stream_index() const;
  void _internal_set_stream_index(int64_t value);
  public:

  // int64 num_sources = 3;
  void clear_num_sources();
  int64_t num_sources() const;
  void set_num_sources(int64_t value);
  private:
  int64_t _internal_num_sources() const;
  void _internal_set_num_sources(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tensorflow.data.SnapshotTaskDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_path_;
    ::tensorflow::data::experimental::DistributedSnapshotMetadata* metadata_;
    int64_t stream_index_;
    int64_t num_sources_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SnapshotTaskProgress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.SnapshotTaskProgress) */ {
 public:
  inline SnapshotTaskProgress() : SnapshotTaskProgress(nullptr) {}
  ~SnapshotTaskProgress() override;
  explicit PROTOBUF_CONSTEXPR SnapshotTaskProgress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotTaskProgress(const SnapshotTaskProgress& from);
  SnapshotTaskProgress(SnapshotTaskProgress&& from) noexcept
    : SnapshotTaskProgress() {
    *this = ::std::move(from);
  }

  inline SnapshotTaskProgress& operator=(const SnapshotTaskProgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotTaskProgress& operator=(SnapshotTaskProgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotTaskProgress& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotTaskProgress* internal_default_instance() {
    return reinterpret_cast<const SnapshotTaskProgress*>(
               &_SnapshotTaskProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SnapshotTaskProgress& a, SnapshotTaskProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotTaskProgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotTaskProgress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotTaskProgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotTaskProgress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotTaskProgress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotTaskProgress& from) {
    SnapshotTaskProgress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotTaskProgress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.data.SnapshotTaskProgress";
  }
  protected:
  explicit SnapshotTaskProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotTaskFieldNumber = 1,
    kStatusFieldNumber = 3,
    kCompletedFieldNumber = 2,
  };
  // .tensorflow.data.SnapshotTaskDef snapshot_task = 1;
  bool has_snapshot_task() const;
  private:
  bool _internal_has_snapshot_task() const;
  public:
  void clear_snapshot_task();
  const ::tensorflow::data::SnapshotTaskDef& snapshot_task() const;
  PROTOBUF_NODISCARD ::tensorflow::data::SnapshotTaskDef* release_snapshot_task();
  ::tensorflow::data::SnapshotTaskDef* mutable_snapshot_task();
  void set_allocated_snapshot_task(::tensorflow::data::SnapshotTaskDef* snapshot_task);
  private:
  const ::tensorflow::data::SnapshotTaskDef& _internal_snapshot_task() const;
  ::tensorflow::data::SnapshotTaskDef* _internal_mutable_snapshot_task();
  public:
  void unsafe_arena_set_allocated_snapshot_task(
      ::tensorflow::data::SnapshotTaskDef* snapshot_task);
  ::tensorflow::data::SnapshotTaskDef* unsafe_arena_release_snapshot_task();

  // .tensorflow.StatusProto status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::tensorflow::StatusProto& status() const;
  PROTOBUF_NODISCARD ::tensorflow::StatusProto* release_status();
  ::tensorflow::StatusProto* mutable_status();
  void set_allocated_status(::tensorflow::StatusProto* status);
  private:
  const ::tensorflow::StatusProto& _internal_status() const;
  ::tensorflow::StatusProto* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::tensorflow::StatusProto* status);
  ::tensorflow::StatusProto* unsafe_arena_release_status();

  // bool completed = 2;
  void clear_completed();
  bool completed() const;
  void set_completed(bool value);
  private:
  bool _internal_completed() const;
  void _internal_set_completed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tensorflow.data.SnapshotTaskProgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::tensorflow::data::SnapshotTaskDef* snapshot_task_;
    ::tensorflow::StatusProto* status_;
    bool completed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SnapshotStreamInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.SnapshotStreamInfo) */ {
 public:
  inline SnapshotStreamInfo() : SnapshotStreamInfo(nullptr) {}
  ~SnapshotStreamInfo() override;
  explicit PROTOBUF_CONSTEXPR SnapshotStreamInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotStreamInfo(const SnapshotStreamInfo& from);
  SnapshotStreamInfo(SnapshotStreamInfo&& from) noexcept
    : SnapshotStreamInfo() {
    *this = ::std::move(from);
  }

  inline SnapshotStreamInfo& operator=(const SnapshotStreamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotStreamInfo& operator=(SnapshotStreamInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotStreamInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotStreamInfo* internal_default_instance() {
    return reinterpret_cast<const SnapshotStreamInfo*>(
               &_SnapshotStreamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SnapshotStreamInfo& a, SnapshotStreamInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotStreamInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotStreamInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotStreamInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotStreamInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotStreamInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotStreamInfo& from) {
    SnapshotStreamInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotStreamInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.data.SnapshotStreamInfo";
  }
  protected:
  explicit SnapshotStreamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SnapshotStreamInfo_State State;
  static constexpr State UNSPECIFIED =
    SnapshotStreamInfo_State_UNSPECIFIED;
  static constexpr State ASSIGNED =
    SnapshotStreamInfo_State_ASSIGNED;
  static constexpr State ORPHAN =
    SnapshotStreamInfo_State_ORPHAN;
  static constexpr State UNKNOWN =
    SnapshotStreamInfo_State_UNKNOWN;
  static constexpr State DONE =
    SnapshotStreamInfo_State_DONE;
  static inline bool State_IsValid(int value) {
    return SnapshotStreamInfo_State_IsValid(value);
  }
  static constexpr State State_MIN =
    SnapshotStreamInfo_State_State_MIN;
  static constexpr State State_MAX =
    SnapshotStreamInfo_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    SnapshotStreamInfo_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return SnapshotStreamInfo_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return SnapshotStreamInfo_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return SnapshotStreamInfo_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // int64 index = 1;
  void clear_index();
  int64_t index() const;
  void set_index(int64_t value);
  private:
  int64_t _internal_index() const;
  void _internal_set_index(int64_t value);
  public:

  // .tensorflow.data.SnapshotStreamInfo.State state = 2;
  void clear_state();
  ::tensorflow::data::SnapshotStreamInfo_State state() const;
  void set_state(::tensorflow::data::SnapshotStreamInfo_State value);
  private:
  ::tensorflow::data::SnapshotStreamInfo_State _internal_state() const;
  void _internal_set_state(::tensorflow::data::SnapshotStreamInfo_State value);
  public:

  // @@protoc_insertion_point(class_scope:tensorflow.data.SnapshotStreamInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t index_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class DataTransferServerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.DataTransferServerInfo) */ {
 public:
  inline DataTransferServerInfo() : DataTransferServerInfo(nullptr) {}
  ~DataTransferServerInfo() override;
  explicit PROTOBUF_CONSTEXPR DataTransferServerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataTransferServerInfo(const DataTransferServerInfo& from);
  DataTransferServerInfo(DataTransferServerInfo&& from) noexcept
    : DataTransferServerInfo() {
    *this = ::std::move(from);
  }

  inline DataTransferServerInfo& operator=(const DataTransferServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataTransferServerInfo& operator=(DataTransferServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataTransferServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataTransferServerInfo* internal_default_instance() {
    return reinterpret_cast<const DataTransferServerInfo*>(
               &_DataTransferServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DataTransferServerInfo& a, DataTransferServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DataTransferServerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataTransferServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataTransferServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataTransferServerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataTransferServerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataTransferServerInfo& from) {
    DataTransferServerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataTransferServerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.data.DataTransferServerInfo";
  }
  protected:
  explicit DataTransferServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolFieldNumber = 1,
    kAddressFieldNumber = 2,
    kCompatibilityInfoFieldNumber = 3,
  };
  // string protocol = 1;
  void clear_protocol();
  const std::string& protocol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol();
  PROTOBUF_NODISCARD std::string* release_protocol();
  void set_allocated_protocol(std::string* protocol);
  private:
  const std::string& _internal_protocol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol(const std::string& value);
  std::string* _internal_mutable_protocol();
  public:

  // string address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // bytes compatibility_info = 3;
  void clear_compatibility_info();
  const std::string& compatibility_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_compatibility_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_compatibility_info();
  PROTOBUF_NODISCARD std::string* release_compatibility_info();
  void set_allocated_compatibility_info(std::string* compatibility_info);
  private:
  const std::string& _internal_compatibility_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_compatibility_info(const std::string& value);
  std::string* _internal_mutable_compatibility_info();
  public:

  // @@protoc_insertion_point(class_scope:tensorflow.data.DataTransferServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr compatibility_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DatasetDef

// .tensorflow.GraphDef graph = 1;
inline bool DatasetDef::_internal_has_graph() const {
  return this != internal_default_instance() && _impl_.graph_ != nullptr;
}
inline bool DatasetDef::has_graph() const {
  return _internal_has_graph();
}
inline const ::tensorflow::GraphDef& DatasetDef::_internal_graph() const {
  const ::tensorflow::GraphDef* p = _impl_.graph_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::GraphDef&>(
      ::tensorflow::_GraphDef_default_instance_);
}
inline const ::tensorflow::GraphDef& DatasetDef::graph() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.DatasetDef.graph)
  return _internal_graph();
}
inline void DatasetDef::unsafe_arena_set_allocated_graph(
    ::tensorflow::GraphDef* graph) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.graph_);
  }
  _impl_.graph_ = graph;
  if (graph) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.data.DatasetDef.graph)
}
inline ::tensorflow::GraphDef* DatasetDef::release_graph() {
  
  ::tensorflow::GraphDef* temp = _impl_.graph_;
  _impl_.graph_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tensorflow::GraphDef* DatasetDef::unsafe_arena_release_graph() {
  // @@protoc_insertion_point(field_release:tensorflow.data.DatasetDef.graph)
  
  ::tensorflow::GraphDef* temp = _impl_.graph_;
  _impl_.graph_ = nullptr;
  return temp;
}
inline ::tensorflow::GraphDef* DatasetDef::_internal_mutable_graph() {
  
  if (_impl_.graph_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::GraphDef>(GetArenaForAllocation());
    _impl_.graph_ = p;
  }
  return _impl_.graph_;
}
inline ::tensorflow::GraphDef* DatasetDef::mutable_graph() {
  ::tensorflow::GraphDef* _msg = _internal_mutable_graph();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.DatasetDef.graph)
  return _msg;
}
inline void DatasetDef::set_allocated_graph(::tensorflow::GraphDef* graph) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.graph_);
  }
  if (graph) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(graph));
    if (message_arena != submessage_arena) {
      graph = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graph, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.graph_ = graph;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.DatasetDef.graph)
}

// -------------------------------------------------------------------

// IterationKeyDef

// string name = 1;
inline void IterationKeyDef::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& IterationKeyDef::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.IterationKeyDef.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IterationKeyDef::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tensorflow.data.IterationKeyDef.name)
}
inline std::string* IterationKeyDef::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.IterationKeyDef.name)
  return _s;
}
inline const std::string& IterationKeyDef::_internal_name() const {
  return _impl_.name_.Get();
}
inline void IterationKeyDef::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* IterationKeyDef::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* IterationKeyDef::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.data.IterationKeyDef.name)
  return _impl_.name_.Release();
}
inline void IterationKeyDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.IterationKeyDef.name)
}

// int64 iteration = 2;
inline void IterationKeyDef::clear_iteration() {
  _impl_.iteration_ = int64_t{0};
}
inline int64_t IterationKeyDef::_internal_iteration() const {
  return _impl_.iteration_;
}
inline int64_t IterationKeyDef::iteration() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.IterationKeyDef.iteration)
  return _internal_iteration();
}
inline void IterationKeyDef::_internal_set_iteration(int64_t value) {
  
  _impl_.iteration_ = value;
}
inline void IterationKeyDef::set_iteration(int64_t value) {
  _internal_set_iteration(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.IterationKeyDef.iteration)
}

// -------------------------------------------------------------------

// TaskDef

// .tensorflow.data.DatasetDef dataset_def = 1;
inline bool TaskDef::_internal_has_dataset_def() const {
  return dataset_case() == kDatasetDef;
}
inline bool TaskDef::has_dataset_def() const {
  return _internal_has_dataset_def();
}
inline void TaskDef::set_has_dataset_def() {
  _impl_._oneof_case_[0] = kDatasetDef;
}
inline void TaskDef::clear_dataset_def() {
  if (_internal_has_dataset_def()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.dataset_.dataset_def_;
    }
    clear_has_dataset();
  }
}
inline ::tensorflow::data::DatasetDef* TaskDef::release_dataset_def() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskDef.dataset_def)
  if (_internal_has_dataset_def()) {
    clear_has_dataset();
    ::tensorflow::data::DatasetDef* temp = _impl_.dataset_.dataset_def_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.dataset_.dataset_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::data::DatasetDef& TaskDef::_internal_dataset_def() const {
  return _internal_has_dataset_def()
      ? *_impl_.dataset_.dataset_def_
      : reinterpret_cast< ::tensorflow::data::DatasetDef&>(::tensorflow::data::_DatasetDef_default_instance_);
}
inline const ::tensorflow::data::DatasetDef& TaskDef::dataset_def() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.dataset_def)
  return _internal_dataset_def();
}
inline ::tensorflow::data::DatasetDef* TaskDef::unsafe_arena_release_dataset_def() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.data.TaskDef.dataset_def)
  if (_internal_has_dataset_def()) {
    clear_has_dataset();
    ::tensorflow::data::DatasetDef* temp = _impl_.dataset_.dataset_def_;
    _impl_.dataset_.dataset_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TaskDef::unsafe_arena_set_allocated_dataset_def(::tensorflow::data::DatasetDef* dataset_def) {
  clear_dataset();
  if (dataset_def) {
    set_has_dataset_def();
    _impl_.dataset_.dataset_def_ = dataset_def;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.data.TaskDef.dataset_def)
}
inline ::tensorflow::data::DatasetDef* TaskDef::_internal_mutable_dataset_def() {
  if (!_internal_has_dataset_def()) {
    clear_dataset();
    set_has_dataset_def();
    _impl_.dataset_.dataset_def_ = CreateMaybeMessage< ::tensorflow::data::DatasetDef >(GetArenaForAllocation());
  }
  return _impl_.dataset_.dataset_def_;
}
inline ::tensorflow::data::DatasetDef* TaskDef::mutable_dataset_def() {
  ::tensorflow::data::DatasetDef* _msg = _internal_mutable_dataset_def();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskDef.dataset_def)
  return _msg;
}

// string path = 2;
inline bool TaskDef::_internal_has_path() const {
  return dataset_case() == kPath;
}
inline bool TaskDef::has_path() const {
  return _internal_has_path();
}
inline void TaskDef::set_has_path() {
  _impl_._oneof_case_[0] = kPath;
}
inline void TaskDef::clear_path() {
  if (_internal_has_path()) {
    _impl_.dataset_.path_.Destroy();
    clear_has_dataset();
  }
}
inline const std::string& TaskDef::path() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline void TaskDef::set_path(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_path()) {
    clear_dataset();
    set_has_path();
    _impl_.dataset_.path_.InitDefault();
  }
  _impl_.dataset_.path_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.path)
}
inline std::string* TaskDef::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskDef.path)
  return _s;
}
inline const std::string& TaskDef::_internal_path() const {
  if (_internal_has_path()) {
    return _impl_.dataset_.path_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TaskDef::_internal_set_path(const std::string& value) {
  if (!_internal_has_path()) {
    clear_dataset();
    set_has_path();
    _impl_.dataset_.path_.InitDefault();
  }
  _impl_.dataset_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskDef::_internal_mutable_path() {
  if (!_internal_has_path()) {
    clear_dataset();
    set_has_path();
    _impl_.dataset_.path_.InitDefault();
  }
  return _impl_.dataset_.path_.Mutable(      GetArenaForAllocation());
}
inline std::string* TaskDef::release_path() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskDef.path)
  if (_internal_has_path()) {
    clear_has_dataset();
    return _impl_.dataset_.path_.Release();
  } else {
    return nullptr;
  }
}
inline void TaskDef::set_allocated_path(std::string* path) {
  if (has_dataset()) {
    clear_dataset();
  }
  if (path != nullptr) {
    set_has_path();
    _impl_.dataset_.path_.InitAllocated(path, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskDef.path)
}

// string dataset_id = 3;
inline void TaskDef::clear_dataset_id() {
  _impl_.dataset_id_.ClearToEmpty();
}
inline const std::string& TaskDef::dataset_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.dataset_id)
  return _internal_dataset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskDef::set_dataset_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dataset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.dataset_id)
}
inline std::string* TaskDef::mutable_dataset_id() {
  std::string* _s = _internal_mutable_dataset_id();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskDef.dataset_id)
  return _s;
}
inline const std::string& TaskDef::_internal_dataset_id() const {
  return _impl_.dataset_id_.Get();
}
inline void TaskDef::_internal_set_dataset_id(const std::string& value) {
  
  _impl_.dataset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskDef::_internal_mutable_dataset_id() {
  
  return _impl_.dataset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskDef::release_dataset_id() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskDef.dataset_id)
  return _impl_.dataset_id_.Release();
}
inline void TaskDef::set_allocated_dataset_id(std::string* dataset_id) {
  if (dataset_id != nullptr) {
    
  } else {
    
  }
  _impl_.dataset_id_.SetAllocated(dataset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dataset_id_.IsDefault()) {
    _impl_.dataset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskDef.dataset_id)
}

// int64 task_id = 4;
inline void TaskDef::clear_task_id() {
  _impl_.task_id_ = int64_t{0};
}
inline int64_t TaskDef::_internal_task_id() const {
  return _impl_.task_id_;
}
inline int64_t TaskDef::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.task_id)
  return _internal_task_id();
}
inline void TaskDef::_internal_set_task_id(int64_t value) {
  
  _impl_.task_id_ = value;
}
inline void TaskDef::set_task_id(int64_t value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.task_id)
}

// int64 iteration_id = 5;
inline void TaskDef::clear_iteration_id() {
  _impl_.iteration_id_ = int64_t{0};
}
inline int64_t TaskDef::_internal_iteration_id() const {
  return _impl_.iteration_id_;
}
inline int64_t TaskDef::iteration_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.iteration_id)
  return _internal_iteration_id();
}
inline void TaskDef::_internal_set_iteration_id(int64_t value) {
  
  _impl_.iteration_id_ = value;
}
inline void TaskDef::set_iteration_id(int64_t value) {
  _internal_set_iteration_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.iteration_id)
}

// int64 num_split_providers = 9;
inline void TaskDef::clear_num_split_providers() {
  _impl_.num_split_providers_ = int64_t{0};
}
inline int64_t TaskDef::_internal_num_split_providers() const {
  return _impl_.num_split_providers_;
}
inline int64_t TaskDef::num_split_providers() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.num_split_providers)
  return _internal_num_split_providers();
}
inline void TaskDef::_internal_set_num_split_providers(int64_t value) {
  
  _impl_.num_split_providers_ = value;
}
inline void TaskDef::set_num_split_providers(int64_t value) {
  _internal_set_num_split_providers(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.num_split_providers)
}

// string worker_address = 8;
inline void TaskDef::clear_worker_address() {
  _impl_.worker_address_.ClearToEmpty();
}
inline const std::string& TaskDef::worker_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.worker_address)
  return _internal_worker_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskDef::set_worker_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.worker_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.worker_address)
}
inline std::string* TaskDef::mutable_worker_address() {
  std::string* _s = _internal_mutable_worker_address();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskDef.worker_address)
  return _s;
}
inline const std::string& TaskDef::_internal_worker_address() const {
  return _impl_.worker_address_.Get();
}
inline void TaskDef::_internal_set_worker_address(const std::string& value) {
  
  _impl_.worker_address_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskDef::_internal_mutable_worker_address() {
  
  return _impl_.worker_address_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskDef::release_worker_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskDef.worker_address)
  return _impl_.worker_address_.Release();
}
inline void TaskDef::set_allocated_worker_address(std::string* worker_address) {
  if (worker_address != nullptr) {
    
  } else {
    
  }
  _impl_.worker_address_.SetAllocated(worker_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.worker_address_.IsDefault()) {
    _impl_.worker_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskDef.worker_address)
}

// .tensorflow.data.ProcessingModeDef processing_mode_def = 10;
inline bool TaskDef::_internal_has_processing_mode_def() const {
  return this != internal_default_instance() && _impl_.processing_mode_def_ != nullptr;
}
inline bool TaskDef::has_processing_mode_def() const {
  return _internal_has_processing_mode_def();
}
inline const ::tensorflow::data::ProcessingModeDef& TaskDef::_internal_processing_mode_def() const {
  const ::tensorflow::data::ProcessingModeDef* p = _impl_.processing_mode_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::data::ProcessingModeDef&>(
      ::tensorflow::data::_ProcessingModeDef_default_instance_);
}
inline const ::tensorflow::data::ProcessingModeDef& TaskDef::processing_mode_def() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.processing_mode_def)
  return _internal_processing_mode_def();
}
inline void TaskDef::unsafe_arena_set_allocated_processing_mode_def(
    ::tensorflow::data::ProcessingModeDef* processing_mode_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.processing_mode_def_);
  }
  _impl_.processing_mode_def_ = processing_mode_def;
  if (processing_mode_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.data.TaskDef.processing_mode_def)
}
inline ::tensorflow::data::ProcessingModeDef* TaskDef::release_processing_mode_def() {
  
  ::tensorflow::data::ProcessingModeDef* temp = _impl_.processing_mode_def_;
  _impl_.processing_mode_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tensorflow::data::ProcessingModeDef* TaskDef::unsafe_arena_release_processing_mode_def() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskDef.processing_mode_def)
  
  ::tensorflow::data::ProcessingModeDef* temp = _impl_.processing_mode_def_;
  _impl_.processing_mode_def_ = nullptr;
  return temp;
}
inline ::tensorflow::data::ProcessingModeDef* TaskDef::_internal_mutable_processing_mode_def() {
  
  if (_impl_.processing_mode_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::data::ProcessingModeDef>(GetArenaForAllocation());
    _impl_.processing_mode_def_ = p;
  }
  return _impl_.processing_mode_def_;
}
inline ::tensorflow::data::ProcessingModeDef* TaskDef::mutable_processing_mode_def() {
  ::tensorflow::data::ProcessingModeDef* _msg = _internal_mutable_processing_mode_def();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskDef.processing_mode_def)
  return _msg;
}
inline void TaskDef::set_allocated_processing_mode_def(::tensorflow::data::ProcessingModeDef* processing_mode_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.processing_mode_def_);
  }
  if (processing_mode_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(processing_mode_def));
    if (message_arena != submessage_arena) {
      processing_mode_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, processing_mode_def, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.processing_mode_def_ = processing_mode_def;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskDef.processing_mode_def)
}

// int64 num_consumers = 7;
inline bool TaskDef::_internal_has_num_consumers() const {
  return optional_num_consumers_case() == kNumConsumers;
}
inline bool TaskDef::has_num_consumers() const {
  return _internal_has_num_consumers();
}
inline void TaskDef::set_has_num_consumers() {
  _impl_._oneof_case_[1] = kNumConsumers;
}
inline void TaskDef::clear_num_consumers() {
  if (_internal_has_num_consumers()) {
    _impl_.optional_num_consumers_.num_consumers_ = int64_t{0};
    clear_has_optional_num_consumers();
  }
}
inline int64_t TaskDef::_internal_num_consumers() const {
  if (_internal_has_num_consumers()) {
    return _impl_.optional_num_consumers_.num_consumers_;
  }
  return int64_t{0};
}
inline void TaskDef::_internal_set_num_consumers(int64_t value) {
  if (!_internal_has_num_consumers()) {
    clear_optional_num_consumers();
    set_has_num_consumers();
  }
  _impl_.optional_num_consumers_.num_consumers_ = value;
}
inline int64_t TaskDef::num_consumers() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.num_consumers)
  return _internal_num_consumers();
}
inline void TaskDef::set_num_consumers(int64_t value) {
  _internal_set_num_consumers(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.num_consumers)
}

// int64 num_workers = 11;
inline void TaskDef::clear_num_workers() {
  _impl_.num_workers_ = int64_t{0};
}
inline int64_t TaskDef::_internal_num_workers() const {
  return _impl_.num_workers_;
}
inline int64_t TaskDef::num_workers() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.num_workers)
  return _internal_num_workers();
}
inline void TaskDef::_internal_set_num_workers(int64_t value) {
  
  _impl_.num_workers_ = value;
}
inline void TaskDef::set_num_workers(int64_t value) {
  _internal_set_num_workers(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.num_workers)
}

// int64 worker_index = 12;
inline void TaskDef::clear_worker_index() {
  _impl_.worker_index_ = int64_t{0};
}
inline int64_t TaskDef::_internal_worker_index() const {
  return _impl_.worker_index_;
}
inline int64_t TaskDef::worker_index() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.worker_index)
  return _internal_worker_index();
}
inline void TaskDef::_internal_set_worker_index(int64_t value) {
  
  _impl_.worker_index_ = value;
}
inline void TaskDef::set_worker_index(int64_t value) {
  _internal_set_worker_index(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.worker_index)
}

// bool use_cross_trainer_cache = 13;
inline void TaskDef::clear_use_cross_trainer_cache() {
  _impl_.use_cross_trainer_cache_ = false;
}
inline bool TaskDef::_internal_use_cross_trainer_cache() const {
  return _impl_.use_cross_trainer_cache_;
}
inline bool TaskDef::use_cross_trainer_cache() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.use_cross_trainer_cache)
  return _internal_use_cross_trainer_cache();
}
inline void TaskDef::_internal_set_use_cross_trainer_cache(bool value) {
  
  _impl_.use_cross_trainer_cache_ = value;
}
inline void TaskDef::set_use_cross_trainer_cache(bool value) {
  _internal_set_use_cross_trainer_cache(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.use_cross_trainer_cache)
}

inline bool TaskDef::has_dataset() const {
  return dataset_case() != DATASET_NOT_SET;
}
inline void TaskDef::clear_has_dataset() {
  _impl_._oneof_case_[0] = DATASET_NOT_SET;
}
inline bool TaskDef::has_optional_num_consumers() const {
  return optional_num_consumers_case() != OPTIONAL_NUM_CONSUMERS_NOT_SET;
}
inline void TaskDef::clear_has_optional_num_consumers() {
  _impl_._oneof_case_[1] = OPTIONAL_NUM_CONSUMERS_NOT_SET;
}
inline TaskDef::DatasetCase TaskDef::dataset_case() const {
  return TaskDef::DatasetCase(_impl_._oneof_case_[0]);
}
inline TaskDef::OptionalNumConsumersCase TaskDef::optional_num_consumers_case() const {
  return TaskDef::OptionalNumConsumersCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// TaskInfo

// string worker_address = 1;
inline void TaskInfo::clear_worker_address() {
  _impl_.worker_address_.ClearToEmpty();
}
inline const std::string& TaskInfo::worker_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.worker_address)
  return _internal_worker_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskInfo::set_worker_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.worker_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.worker_address)
}
inline std::string* TaskInfo::mutable_worker_address() {
  std::string* _s = _internal_mutable_worker_address();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskInfo.worker_address)
  return _s;
}
inline const std::string& TaskInfo::_internal_worker_address() const {
  return _impl_.worker_address_.Get();
}
inline void TaskInfo::_internal_set_worker_address(const std::string& value) {
  
  _impl_.worker_address_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskInfo::_internal_mutable_worker_address() {
  
  return _impl_.worker_address_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskInfo::release_worker_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskInfo.worker_address)
  return _impl_.worker_address_.Release();
}
inline void TaskInfo::set_allocated_worker_address(std::string* worker_address) {
  if (worker_address != nullptr) {
    
  } else {
    
  }
  _impl_.worker_address_.SetAllocated(worker_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.worker_address_.IsDefault()) {
    _impl_.worker_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskInfo.worker_address)
}

// repeated .tensorflow.data.DataTransferServerInfo transfer_servers = 8;
inline int TaskInfo::_internal_transfer_servers_size() const {
  return _impl_.transfer_servers_.size();
}
inline int TaskInfo::transfer_servers_size() const {
  return _internal_transfer_servers_size();
}
inline void TaskInfo::clear_transfer_servers() {
  _impl_.transfer_servers_.Clear();
}
inline ::tensorflow::data::DataTransferServerInfo* TaskInfo::mutable_transfer_servers(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskInfo.transfer_servers)
  return _impl_.transfer_servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::data::DataTransferServerInfo >*
TaskInfo::mutable_transfer_servers() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.TaskInfo.transfer_servers)
  return &_impl_.transfer_servers_;
}
inline const ::tensorflow::data::DataTransferServerInfo& TaskInfo::_internal_transfer_servers(int index) const {
  return _impl_.transfer_servers_.Get(index);
}
inline const ::tensorflow::data::DataTransferServerInfo& TaskInfo::transfer_servers(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.transfer_servers)
  return _internal_transfer_servers(index);
}
inline ::tensorflow::data::DataTransferServerInfo* TaskInfo::_internal_add_transfer_servers() {
  return _impl_.transfer_servers_.Add();
}
inline ::tensorflow::data::DataTransferServerInfo* TaskInfo::add_transfer_servers() {
  ::tensorflow::data::DataTransferServerInfo* _add = _internal_add_transfer_servers();
  // @@protoc_insertion_point(field_add:tensorflow.data.TaskInfo.transfer_servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::data::DataTransferServerInfo >&
TaskInfo::transfer_servers() const {
  // @@protoc_insertion_point(field_list:tensorflow.data.TaskInfo.transfer_servers)
  return _impl_.transfer_servers_;
}

// repeated string worker_tags = 6;
inline int TaskInfo::_internal_worker_tags_size() const {
  return _impl_.worker_tags_.size();
}
inline int TaskInfo::worker_tags_size() const {
  return _internal_worker_tags_size();
}
inline void TaskInfo::clear_worker_tags() {
  _impl_.worker_tags_.Clear();
}
inline std::string* TaskInfo::add_worker_tags() {
  std::string* _s = _internal_add_worker_tags();
  // @@protoc_insertion_point(field_add_mutable:tensorflow.data.TaskInfo.worker_tags)
  return _s;
}
inline const std::string& TaskInfo::_internal_worker_tags(int index) const {
  return _impl_.worker_tags_.Get(index);
}
inline const std::string& TaskInfo::worker_tags(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.worker_tags)
  return _internal_worker_tags(index);
}
inline std::string* TaskInfo::mutable_worker_tags(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskInfo.worker_tags)
  return _impl_.worker_tags_.Mutable(index);
}
inline void TaskInfo::set_worker_tags(int index, const std::string& value) {
  _impl_.worker_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.worker_tags)
}
inline void TaskInfo::set_worker_tags(int index, std::string&& value) {
  _impl_.worker_tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.worker_tags)
}
inline void TaskInfo::set_worker_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.worker_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.data.TaskInfo.worker_tags)
}
inline void TaskInfo::set_worker_tags(int index, const char* value, size_t size) {
  _impl_.worker_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.TaskInfo.worker_tags)
}
inline std::string* TaskInfo::_internal_add_worker_tags() {
  return _impl_.worker_tags_.Add();
}
inline void TaskInfo::add_worker_tags(const std::string& value) {
  _impl_.worker_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.data.TaskInfo.worker_tags)
}
inline void TaskInfo::add_worker_tags(std::string&& value) {
  _impl_.worker_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.data.TaskInfo.worker_tags)
}
inline void TaskInfo::add_worker_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.worker_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.data.TaskInfo.worker_tags)
}
inline void TaskInfo::add_worker_tags(const char* value, size_t size) {
  _impl_.worker_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.data.TaskInfo.worker_tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TaskInfo::worker_tags() const {
  // @@protoc_insertion_point(field_list:tensorflow.data.TaskInfo.worker_tags)
  return _impl_.worker_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TaskInfo::mutable_worker_tags() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.TaskInfo.worker_tags)
  return &_impl_.worker_tags_;
}

// int64 task_id = 2;
inline void TaskInfo::clear_task_id() {
  _impl_.task_id_ = int64_t{0};
}
inline int64_t TaskInfo::_internal_task_id() const {
  return _impl_.task_id_;
}
inline int64_t TaskInfo::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.task_id)
  return _internal_task_id();
}
inline void TaskInfo::_internal_set_task_id(int64_t value) {
  
  _impl_.task_id_ = value;
}
inline void TaskInfo::set_task_id(int64_t value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.task_id)
}

// int64 iteration_id = 3;
inline void TaskInfo::clear_iteration_id() {
  _impl_.iteration_id_ = int64_t{0};
}
inline int64_t TaskInfo::_internal_iteration_id() const {
  return _impl_.iteration_id_;
}
inline int64_t TaskInfo::iteration_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.iteration_id)
  return _internal_iteration_id();
}
inline void TaskInfo::_internal_set_iteration_id(int64_t value) {
  
  _impl_.iteration_id_ = value;
}
inline void TaskInfo::set_iteration_id(int64_t value) {
  _internal_set_iteration_id(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.iteration_id)
}

// int64 worker_uid = 7;
inline void TaskInfo::clear_worker_uid() {
  _impl_.worker_uid_ = int64_t{0};
}
inline int64_t TaskInfo::_internal_worker_uid() const {
  return _impl_.worker_uid_;
}
inline int64_t TaskInfo::worker_uid() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.worker_uid)
  return _internal_worker_uid();
}
inline void TaskInfo::_internal_set_worker_uid(int64_t value) {
  
  _impl_.worker_uid_ = value;
}
inline void TaskInfo::set_worker_uid(int64_t value) {
  _internal_set_worker_uid(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.worker_uid)
}

// int64 starting_round = 5;
inline void TaskInfo::clear_starting_round() {
  _impl_.starting_round_ = int64_t{0};
}
inline int64_t TaskInfo::_internal_starting_round() const {
  return _impl_.starting_round_;
}
inline int64_t TaskInfo::starting_round() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.starting_round)
  return _internal_starting_round();
}
inline void TaskInfo::_internal_set_starting_round(int64_t value) {
  
  _impl_.starting_round_ = value;
}
inline void TaskInfo::set_starting_round(int64_t value) {
  _internal_set_starting_round(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.starting_round)
}

// -------------------------------------------------------------------

// SnapshotTaskDef

// string base_path = 1;
inline void SnapshotTaskDef::clear_base_path() {
  _impl_.base_path_.ClearToEmpty();
}
inline const std::string& SnapshotTaskDef::base_path() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.SnapshotTaskDef.base_path)
  return _internal_base_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SnapshotTaskDef::set_base_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.base_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tensorflow.data.SnapshotTaskDef.base_path)
}
inline std::string* SnapshotTaskDef::mutable_base_path() {
  std::string* _s = _internal_mutable_base_path();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.SnapshotTaskDef.base_path)
  return _s;
}
inline const std::string& SnapshotTaskDef::_internal_base_path() const {
  return _impl_.base_path_.Get();
}
inline void SnapshotTaskDef::_internal_set_base_path(const std::string& value) {
  
  _impl_.base_path_.Set(value, GetArenaForAllocation());
}
inline std::string* SnapshotTaskDef::_internal_mutable_base_path() {
  
  return _impl_.base_path_.Mutable(GetArenaForAllocation());
}
inline std::string* SnapshotTaskDef::release_base_path() {
  // @@protoc_insertion_point(field_release:tensorflow.data.SnapshotTaskDef.base_path)
  return _impl_.base_path_.Release();
}
inline void SnapshotTaskDef::set_allocated_base_path(std::string* base_path) {
  if (base_path != nullptr) {
    
  } else {
    
  }
  _impl_.base_path_.SetAllocated(base_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_path_.IsDefault()) {
    _impl_.base_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.SnapshotTaskDef.base_path)
}

// int64 stream_index = 2;
inline void SnapshotTaskDef::clear_stream_index() {
  _impl_.stream_index_ = int64_t{0};
}
inline int64_t SnapshotTaskDef::_internal_stream_index() const {
  return _impl_.stream_index_;
}
inline int64_t SnapshotTaskDef::stream_index() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.SnapshotTaskDef.stream_index)
  return _internal_stream_index();
}
inline void SnapshotTaskDef::_internal_set_stream_index(int64_t value) {
  
  _impl_.stream_index_ = value;
}
inline void SnapshotTaskDef::set_stream_index(int64_t value) {
  _internal_set_stream_index(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.SnapshotTaskDef.stream_index)
}

// int64 num_sources = 3;
inline void SnapshotTaskDef::clear_num_sources() {
  _impl_.num_sources_ = int64_t{0};
}
inline int64_t SnapshotTaskDef::_internal_num_sources() const {
  return _impl_.num_sources_;
}
inline int64_t SnapshotTaskDef::num_sources() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.SnapshotTaskDef.num_sources)
  return _internal_num_sources();
}
inline void SnapshotTaskDef::_internal_set_num_sources(int64_t value) {
  
  _impl_.num_sources_ = value;
}
inline void SnapshotTaskDef::set_num_sources(int64_t value) {
  _internal_set_num_sources(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.SnapshotTaskDef.num_sources)
}

// .tensorflow.data.experimental.DistributedSnapshotMetadata metadata = 4;
inline bool SnapshotTaskDef::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool SnapshotTaskDef::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::tensorflow::data::experimental::DistributedSnapshotMetadata& SnapshotTaskDef::_internal_metadata() const {
  const ::tensorflow::data::experimental::DistributedSnapshotMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::data::experimental::DistributedSnapshotMetadata&>(
      ::tensorflow::data::experimental::_DistributedSnapshotMetadata_default_instance_);
}
inline const ::tensorflow::data::experimental::DistributedSnapshotMetadata& SnapshotTaskDef::metadata() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.SnapshotTaskDef.metadata)
  return _internal_metadata();
}
inline void SnapshotTaskDef::unsafe_arena_set_allocated_metadata(
    ::tensorflow::data::experimental::DistributedSnapshotMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.data.SnapshotTaskDef.metadata)
}
inline ::tensorflow::data::experimental::DistributedSnapshotMetadata* SnapshotTaskDef::release_metadata() {
  
  ::tensorflow::data::experimental::DistributedSnapshotMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tensorflow::data::experimental::DistributedSnapshotMetadata* SnapshotTaskDef::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:tensorflow.data.SnapshotTaskDef.metadata)
  
  ::tensorflow::data::experimental::DistributedSnapshotMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::tensorflow::data::experimental::DistributedSnapshotMetadata* SnapshotTaskDef::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::data::experimental::DistributedSnapshotMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::tensorflow::data::experimental::DistributedSnapshotMetadata* SnapshotTaskDef::mutable_metadata() {
  ::tensorflow::data::experimental::DistributedSnapshotMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.SnapshotTaskDef.metadata)
  return _msg;
}
inline void SnapshotTaskDef::set_allocated_metadata(::tensorflow::data::experimental::DistributedSnapshotMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.SnapshotTaskDef.metadata)
}

// -------------------------------------------------------------------

// SnapshotTaskProgress

// .tensorflow.data.SnapshotTaskDef snapshot_task = 1;
inline bool SnapshotTaskProgress::_internal_has_snapshot_task() const {
  return this != internal_default_instance() && _impl_.snapshot_task_ != nullptr;
}
inline bool SnapshotTaskProgress::has_snapshot_task() const {
  return _internal_has_snapshot_task();
}
inline void SnapshotTaskProgress::clear_snapshot_task() {
  if (GetArenaForAllocation() == nullptr && _impl_.snapshot_task_ != nullptr) {
    delete _impl_.snapshot_task_;
  }
  _impl_.snapshot_task_ = nullptr;
}
inline const ::tensorflow::data::SnapshotTaskDef& SnapshotTaskProgress::_internal_snapshot_task() const {
  const ::tensorflow::data::SnapshotTaskDef* p = _impl_.snapshot_task_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::data::SnapshotTaskDef&>(
      ::tensorflow::data::_SnapshotTaskDef_default_instance_);
}
inline const ::tensorflow::data::SnapshotTaskDef& SnapshotTaskProgress::snapshot_task() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.SnapshotTaskProgress.snapshot_task)
  return _internal_snapshot_task();
}
inline void SnapshotTaskProgress::unsafe_arena_set_allocated_snapshot_task(
    ::tensorflow::data::SnapshotTaskDef* snapshot_task) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.snapshot_task_);
  }
  _impl_.snapshot_task_ = snapshot_task;
  if (snapshot_task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.data.SnapshotTaskProgress.snapshot_task)
}
inline ::tensorflow::data::SnapshotTaskDef* SnapshotTaskProgress::release_snapshot_task() {
  
  ::tensorflow::data::SnapshotTaskDef* temp = _impl_.snapshot_task_;
  _impl_.snapshot_task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tensorflow::data::SnapshotTaskDef* SnapshotTaskProgress::unsafe_arena_release_snapshot_task() {
  // @@protoc_insertion_point(field_release:tensorflow.data.SnapshotTaskProgress.snapshot_task)
  
  ::tensorflow::data::SnapshotTaskDef* temp = _impl_.snapshot_task_;
  _impl_.snapshot_task_ = nullptr;
  return temp;
}
inline ::tensorflow::data::SnapshotTaskDef* SnapshotTaskProgress::_internal_mutable_snapshot_task() {
  
  if (_impl_.snapshot_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::data::SnapshotTaskDef>(GetArenaForAllocation());
    _impl_.snapshot_task_ = p;
  }
  return _impl_.snapshot_task_;
}
inline ::tensorflow::data::SnapshotTaskDef* SnapshotTaskProgress::mutable_snapshot_task() {
  ::tensorflow::data::SnapshotTaskDef* _msg = _internal_mutable_snapshot_task();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.SnapshotTaskProgress.snapshot_task)
  return _msg;
}
inline void SnapshotTaskProgress::set_allocated_snapshot_task(::tensorflow::data::SnapshotTaskDef* snapshot_task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.snapshot_task_;
  }
  if (snapshot_task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(snapshot_task);
    if (message_arena != submessage_arena) {
      snapshot_task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshot_task, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.snapshot_task_ = snapshot_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.SnapshotTaskProgress.snapshot_task)
}

// bool completed = 2;
inline void SnapshotTaskProgress::clear_completed() {
  _impl_.completed_ = false;
}
inline bool SnapshotTaskProgress::_internal_completed() const {
  return _impl_.completed_;
}
inline bool SnapshotTaskProgress::completed() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.SnapshotTaskProgress.completed)
  return _internal_completed();
}
inline void SnapshotTaskProgress::_internal_set_completed(bool value) {
  
  _impl_.completed_ = value;
}
inline void SnapshotTaskProgress::set_completed(bool value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.SnapshotTaskProgress.completed)
}

// .tensorflow.StatusProto status = 3;
inline bool SnapshotTaskProgress::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool SnapshotTaskProgress::has_status() const {
  return _internal_has_status();
}
inline const ::tensorflow::StatusProto& SnapshotTaskProgress::_internal_status() const {
  const ::tensorflow::StatusProto* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::StatusProto&>(
      ::tensorflow::_StatusProto_default_instance_);
}
inline const ::tensorflow::StatusProto& SnapshotTaskProgress::status() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.SnapshotTaskProgress.status)
  return _internal_status();
}
inline void SnapshotTaskProgress::unsafe_arena_set_allocated_status(
    ::tensorflow::StatusProto* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.data.SnapshotTaskProgress.status)
}
inline ::tensorflow::StatusProto* SnapshotTaskProgress::release_status() {
  
  ::tensorflow::StatusProto* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tensorflow::StatusProto* SnapshotTaskProgress::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:tensorflow.data.SnapshotTaskProgress.status)
  
  ::tensorflow::StatusProto* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::tensorflow::StatusProto* SnapshotTaskProgress::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::StatusProto>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::tensorflow::StatusProto* SnapshotTaskProgress::mutable_status() {
  ::tensorflow::StatusProto* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.SnapshotTaskProgress.status)
  return _msg;
}
inline void SnapshotTaskProgress::set_allocated_status(::tensorflow::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.SnapshotTaskProgress.status)
}

// -------------------------------------------------------------------

// SnapshotStreamInfo

// int64 index = 1;
inline void SnapshotStreamInfo::clear_index() {
  _impl_.index_ = int64_t{0};
}
inline int64_t SnapshotStreamInfo::_internal_index() const {
  return _impl_.index_;
}
inline int64_t SnapshotStreamInfo::index() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.SnapshotStreamInfo.index)
  return _internal_index();
}
inline void SnapshotStreamInfo::_internal_set_index(int64_t value) {
  
  _impl_.index_ = value;
}
inline void SnapshotStreamInfo::set_index(int64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.SnapshotStreamInfo.index)
}

// .tensorflow.data.SnapshotStreamInfo.State state = 2;
inline void SnapshotStreamInfo::clear_state() {
  _impl_.state_ = 0;
}
inline ::tensorflow::data::SnapshotStreamInfo_State SnapshotStreamInfo::_internal_state() const {
  return static_cast< ::tensorflow::data::SnapshotStreamInfo_State >(_impl_.state_);
}
inline ::tensorflow::data::SnapshotStreamInfo_State SnapshotStreamInfo::state() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.SnapshotStreamInfo.state)
  return _internal_state();
}
inline void SnapshotStreamInfo::_internal_set_state(::tensorflow::data::SnapshotStreamInfo_State value) {
  
  _impl_.state_ = value;
}
inline void SnapshotStreamInfo::set_state(::tensorflow::data::SnapshotStreamInfo_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:tensorflow.data.SnapshotStreamInfo.state)
}

// -------------------------------------------------------------------

// DataTransferServerInfo

// string protocol = 1;
inline void DataTransferServerInfo::clear_protocol() {
  _impl_.protocol_.ClearToEmpty();
}
inline const std::string& DataTransferServerInfo::protocol() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.DataTransferServerInfo.protocol)
  return _internal_protocol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataTransferServerInfo::set_protocol(ArgT0&& arg0, ArgT... args) {
 
 _impl_.protocol_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tensorflow.data.DataTransferServerInfo.protocol)
}
inline std::string* DataTransferServerInfo::mutable_protocol() {
  std::string* _s = _internal_mutable_protocol();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.DataTransferServerInfo.protocol)
  return _s;
}
inline const std::string& DataTransferServerInfo::_internal_protocol() const {
  return _impl_.protocol_.Get();
}
inline void DataTransferServerInfo::_internal_set_protocol(const std::string& value) {
  
  _impl_.protocol_.Set(value, GetArenaForAllocation());
}
inline std::string* DataTransferServerInfo::_internal_mutable_protocol() {
  
  return _impl_.protocol_.Mutable(GetArenaForAllocation());
}
inline std::string* DataTransferServerInfo::release_protocol() {
  // @@protoc_insertion_point(field_release:tensorflow.data.DataTransferServerInfo.protocol)
  return _impl_.protocol_.Release();
}
inline void DataTransferServerInfo::set_allocated_protocol(std::string* protocol) {
  if (protocol != nullptr) {
    
  } else {
    
  }
  _impl_.protocol_.SetAllocated(protocol, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.protocol_.IsDefault()) {
    _impl_.protocol_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.DataTransferServerInfo.protocol)
}

// string address = 2;
inline void DataTransferServerInfo::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& DataTransferServerInfo::address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.DataTransferServerInfo.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataTransferServerInfo::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tensorflow.data.DataTransferServerInfo.address)
}
inline std::string* DataTransferServerInfo::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.DataTransferServerInfo.address)
  return _s;
}
inline const std::string& DataTransferServerInfo::_internal_address() const {
  return _impl_.address_.Get();
}
inline void DataTransferServerInfo::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* DataTransferServerInfo::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* DataTransferServerInfo::release_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.DataTransferServerInfo.address)
  return _impl_.address_.Release();
}
inline void DataTransferServerInfo::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.DataTransferServerInfo.address)
}

// bytes compatibility_info = 3;
inline void DataTransferServerInfo::clear_compatibility_info() {
  _impl_.compatibility_info_.ClearToEmpty();
}
inline const std::string& DataTransferServerInfo::compatibility_info() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.DataTransferServerInfo.compatibility_info)
  return _internal_compatibility_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataTransferServerInfo::set_compatibility_info(ArgT0&& arg0, ArgT... args) {
 
 _impl_.compatibility_info_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tensorflow.data.DataTransferServerInfo.compatibility_info)
}
inline std::string* DataTransferServerInfo::mutable_compatibility_info() {
  std::string* _s = _internal_mutable_compatibility_info();
  // @@protoc_insertion_point(field_mutable:tensorflow.data.DataTransferServerInfo.compatibility_info)
  return _s;
}
inline const std::string& DataTransferServerInfo::_internal_compatibility_info() const {
  return _impl_.compatibility_info_.Get();
}
inline void DataTransferServerInfo::_internal_set_compatibility_info(const std::string& value) {
  
  _impl_.compatibility_info_.Set(value, GetArenaForAllocation());
}
inline std::string* DataTransferServerInfo::_internal_mutable_compatibility_info() {
  
  return _impl_.compatibility_info_.Mutable(GetArenaForAllocation());
}
inline std::string* DataTransferServerInfo::release_compatibility_info() {
  // @@protoc_insertion_point(field_release:tensorflow.data.DataTransferServerInfo.compatibility_info)
  return _impl_.compatibility_info_.Release();
}
inline void DataTransferServerInfo::set_allocated_compatibility_info(std::string* compatibility_info) {
  if (compatibility_info != nullptr) {
    
  } else {
    
  }
  _impl_.compatibility_info_.SetAllocated(compatibility_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.compatibility_info_.IsDefault()) {
    _impl_.compatibility_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.DataTransferServerInfo.compatibility_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace data
}  // namespace tensorflow

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tensorflow::data::SnapshotStreamInfo_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::data::SnapshotStreamInfo_State>() {
  return ::tensorflow::data::SnapshotStreamInfo_State_descriptor();
}
template <> struct is_proto_enum< ::tensorflow::data::TargetWorkers> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::data::TargetWorkers>() {
  return ::tensorflow::data::TargetWorkers_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto
