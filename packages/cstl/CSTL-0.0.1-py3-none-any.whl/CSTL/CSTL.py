# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _CSTL
else:
    import _CSTL

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CSTL.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _CSTL.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _CSTL.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _CSTL.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _CSTL.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _CSTL.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _CSTL.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _CSTL.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _CSTL.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _CSTL.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _CSTL.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _CSTL.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _CSTL.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _CSTL.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _CSTL.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _CSTL.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _CSTL.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _CSTL:
_CSTL.SwigPyIterator_swigregister(SwigPyIterator)

class VecInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.VecInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.VecInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.VecInt___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _CSTL.VecInt___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _CSTL.VecInt___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _CSTL.VecInt___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _CSTL.VecInt___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _CSTL.VecInt___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _CSTL.VecInt___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _CSTL.VecInt___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _CSTL.VecInt_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _CSTL.VecInt_append(self, x)

    def empty(self) -> "bool":
        return _CSTL.VecInt_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _CSTL.VecInt_size(self)

    def swap(self, v: "VecInt") -> "void":
        return _CSTL.VecInt_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _CSTL.VecInt_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _CSTL.VecInt_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _CSTL.VecInt_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _CSTL.VecInt_rend(self)

    def clear(self) -> "void":
        return _CSTL.VecInt_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _CSTL.VecInt_get_allocator(self)

    def pop_back(self) -> "void":
        return _CSTL.VecInt_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _CSTL.VecInt_erase(self, *args)

    def __init__(self, *args):
        _CSTL.VecInt_swiginit(self, _CSTL.new_VecInt(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _CSTL.VecInt_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _CSTL.VecInt_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _CSTL.VecInt_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _CSTL.VecInt_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _CSTL.VecInt_resize(self, *args)

    def insert(self, *args) -> "void":
        return _CSTL.VecInt_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _CSTL.VecInt_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _CSTL.VecInt_capacity(self)
    __swig_destroy__ = _CSTL.delete_VecInt

# Register VecInt in _CSTL:
_CSTL.VecInt_swigregister(VecInt)

class VecStr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.VecStr_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.VecStr___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.VecStr___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _CSTL.VecStr___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _CSTL.VecStr___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _CSTL.VecStr___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _CSTL.VecStr___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _CSTL.VecStr___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _CSTL.VecStr___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _CSTL.VecStr___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _CSTL.VecStr_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _CSTL.VecStr_append(self, x)

    def empty(self) -> "bool":
        return _CSTL.VecStr_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _CSTL.VecStr_size(self)

    def swap(self, v: "VecStr") -> "void":
        return _CSTL.VecStr_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _CSTL.VecStr_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _CSTL.VecStr_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _CSTL.VecStr_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _CSTL.VecStr_rend(self)

    def clear(self) -> "void":
        return _CSTL.VecStr_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _CSTL.VecStr_get_allocator(self)

    def pop_back(self) -> "void":
        return _CSTL.VecStr_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _CSTL.VecStr_erase(self, *args)

    def __init__(self, *args):
        _CSTL.VecStr_swiginit(self, _CSTL.new_VecStr(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _CSTL.VecStr_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _CSTL.VecStr_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _CSTL.VecStr_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _CSTL.VecStr_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _CSTL.VecStr_resize(self, *args)

    def insert(self, *args) -> "void":
        return _CSTL.VecStr_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _CSTL.VecStr_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _CSTL.VecStr_capacity(self)
    __swig_destroy__ = _CSTL.delete_VecStr

# Register VecStr in _CSTL:
_CSTL.VecStr_swigregister(VecStr)

class VecFloat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.VecFloat_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.VecFloat___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.VecFloat___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        return _CSTL.VecFloat___len__(self)

    def __getslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "std::vector< float,std::allocator< float > > *":
        return _CSTL.VecFloat___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _CSTL.VecFloat___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "void":
        return _CSTL.VecFloat___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _CSTL.VecFloat___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        return _CSTL.VecFloat___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _CSTL.VecFloat___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        return _CSTL.VecFloat_pop(self)

    def append(self, x: "std::vector< float >::value_type const &") -> "void":
        return _CSTL.VecFloat_append(self, x)

    def empty(self) -> "bool":
        return _CSTL.VecFloat_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        return _CSTL.VecFloat_size(self)

    def swap(self, v: "VecFloat") -> "void":
        return _CSTL.VecFloat_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        return _CSTL.VecFloat_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        return _CSTL.VecFloat_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        return _CSTL.VecFloat_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        return _CSTL.VecFloat_rend(self)

    def clear(self) -> "void":
        return _CSTL.VecFloat_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        return _CSTL.VecFloat_get_allocator(self)

    def pop_back(self) -> "void":
        return _CSTL.VecFloat_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        return _CSTL.VecFloat_erase(self, *args)

    def __init__(self, *args):
        _CSTL.VecFloat_swiginit(self, _CSTL.new_VecFloat(*args))

    def push_back(self, x: "std::vector< float >::value_type const &") -> "void":
        return _CSTL.VecFloat_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        return _CSTL.VecFloat_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        return _CSTL.VecFloat_back(self)

    def assign(self, n: "std::vector< float >::size_type", x: "std::vector< float >::value_type const &") -> "void":
        return _CSTL.VecFloat_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _CSTL.VecFloat_resize(self, *args)

    def insert(self, *args) -> "void":
        return _CSTL.VecFloat_insert(self, *args)

    def reserve(self, n: "std::vector< float >::size_type") -> "void":
        return _CSTL.VecFloat_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        return _CSTL.VecFloat_capacity(self)
    __swig_destroy__ = _CSTL.delete_VecFloat

# Register VecFloat in _CSTL:
_CSTL.VecFloat_swigregister(VecFloat)

class VecDouble(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.VecDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.VecDouble___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.VecDouble___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _CSTL.VecDouble___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        return _CSTL.VecDouble___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _CSTL.VecDouble___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        return _CSTL.VecDouble___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _CSTL.VecDouble___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _CSTL.VecDouble___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _CSTL.VecDouble___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _CSTL.VecDouble_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        return _CSTL.VecDouble_append(self, x)

    def empty(self) -> "bool":
        return _CSTL.VecDouble_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _CSTL.VecDouble_size(self)

    def swap(self, v: "VecDouble") -> "void":
        return _CSTL.VecDouble_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _CSTL.VecDouble_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _CSTL.VecDouble_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _CSTL.VecDouble_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _CSTL.VecDouble_rend(self)

    def clear(self) -> "void":
        return _CSTL.VecDouble_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _CSTL.VecDouble_get_allocator(self)

    def pop_back(self) -> "void":
        return _CSTL.VecDouble_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _CSTL.VecDouble_erase(self, *args)

    def __init__(self, *args):
        _CSTL.VecDouble_swiginit(self, _CSTL.new_VecDouble(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        return _CSTL.VecDouble_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _CSTL.VecDouble_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _CSTL.VecDouble_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        return _CSTL.VecDouble_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _CSTL.VecDouble_resize(self, *args)

    def insert(self, *args) -> "void":
        return _CSTL.VecDouble_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        return _CSTL.VecDouble_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _CSTL.VecDouble_capacity(self)
    __swig_destroy__ = _CSTL.delete_VecDouble

# Register VecDouble in _CSTL:
_CSTL.VecDouble_swigregister(VecDouble)

class VecBool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.VecBool_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.VecBool___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.VecBool___bool__(self)

    def __len__(self) -> "std::vector< bool >::size_type":
        return _CSTL.VecBool___len__(self)

    def __getslice__(self, i: "std::vector< bool >::difference_type", j: "std::vector< bool >::difference_type") -> "std::vector< bool,std::allocator< bool > > *":
        return _CSTL.VecBool___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _CSTL.VecBool___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< bool >::difference_type", j: "std::vector< bool >::difference_type") -> "void":
        return _CSTL.VecBool___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _CSTL.VecBool___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< bool >::value_type":
        return _CSTL.VecBool___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _CSTL.VecBool___setitem__(self, *args)

    def pop(self) -> "std::vector< bool >::value_type":
        return _CSTL.VecBool_pop(self)

    def append(self, x: "std::vector< bool >::value_type") -> "void":
        return _CSTL.VecBool_append(self, x)

    def empty(self) -> "bool":
        return _CSTL.VecBool_empty(self)

    def size(self) -> "std::vector< bool >::size_type":
        return _CSTL.VecBool_size(self)

    def swap(self, v: "VecBool") -> "void":
        return _CSTL.VecBool_swap(self, v)

    def begin(self) -> "std::vector< bool >::iterator":
        return _CSTL.VecBool_begin(self)

    def end(self) -> "std::vector< bool >::iterator":
        return _CSTL.VecBool_end(self)

    def rbegin(self) -> "std::vector< bool >::reverse_iterator":
        return _CSTL.VecBool_rbegin(self)

    def rend(self) -> "std::vector< bool >::reverse_iterator":
        return _CSTL.VecBool_rend(self)

    def clear(self) -> "void":
        return _CSTL.VecBool_clear(self)

    def get_allocator(self) -> "std::vector< bool >::allocator_type":
        return _CSTL.VecBool_get_allocator(self)

    def pop_back(self) -> "void":
        return _CSTL.VecBool_pop_back(self)

    def erase(self, *args) -> "std::vector< bool >::iterator":
        return _CSTL.VecBool_erase(self, *args)

    def __init__(self, *args):
        _CSTL.VecBool_swiginit(self, _CSTL.new_VecBool(*args))

    def push_back(self, x: "std::vector< bool >::value_type") -> "void":
        return _CSTL.VecBool_push_back(self, x)

    def front(self) -> "std::vector< bool >::value_type":
        return _CSTL.VecBool_front(self)

    def back(self) -> "std::vector< bool >::value_type":
        return _CSTL.VecBool_back(self)

    def assign(self, n: "std::vector< bool >::size_type", x: "std::vector< bool >::value_type") -> "void":
        return _CSTL.VecBool_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _CSTL.VecBool_resize(self, *args)

    def insert(self, *args) -> "void":
        return _CSTL.VecBool_insert(self, *args)

    def reserve(self, n: "std::vector< bool >::size_type") -> "void":
        return _CSTL.VecBool_reserve(self, n)

    def capacity(self) -> "std::vector< bool >::size_type":
        return _CSTL.VecBool_capacity(self)
    __swig_destroy__ = _CSTL.delete_VecBool

# Register VecBool in _CSTL:
_CSTL.VecBool_swigregister(VecBool)

class VecLong(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.VecLong_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.VecLong___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.VecLong___bool__(self)

    def __len__(self) -> "std::vector< std::int64_t >::size_type":
        return _CSTL.VecLong___len__(self)

    def __getslice__(self, i: "std::vector< std::int64_t >::difference_type", j: "std::vector< std::int64_t >::difference_type") -> "std::vector< std::int64_t,std::allocator< std::int64_t > > *":
        return _CSTL.VecLong___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _CSTL.VecLong___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::int64_t >::difference_type", j: "std::vector< std::int64_t >::difference_type") -> "void":
        return _CSTL.VecLong___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _CSTL.VecLong___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::int64_t >::value_type const &":
        return _CSTL.VecLong___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _CSTL.VecLong___setitem__(self, *args)

    def pop(self) -> "std::vector< std::int64_t >::value_type":
        return _CSTL.VecLong_pop(self)

    def append(self, x: "std::vector< std::int64_t >::value_type const &") -> "void":
        return _CSTL.VecLong_append(self, x)

    def empty(self) -> "bool":
        return _CSTL.VecLong_empty(self)

    def size(self) -> "std::vector< std::int64_t >::size_type":
        return _CSTL.VecLong_size(self)

    def swap(self, v: "VecLong") -> "void":
        return _CSTL.VecLong_swap(self, v)

    def begin(self) -> "std::vector< std::int64_t >::iterator":
        return _CSTL.VecLong_begin(self)

    def end(self) -> "std::vector< std::int64_t >::iterator":
        return _CSTL.VecLong_end(self)

    def rbegin(self) -> "std::vector< std::int64_t >::reverse_iterator":
        return _CSTL.VecLong_rbegin(self)

    def rend(self) -> "std::vector< std::int64_t >::reverse_iterator":
        return _CSTL.VecLong_rend(self)

    def clear(self) -> "void":
        return _CSTL.VecLong_clear(self)

    def get_allocator(self) -> "std::vector< std::int64_t >::allocator_type":
        return _CSTL.VecLong_get_allocator(self)

    def pop_back(self) -> "void":
        return _CSTL.VecLong_pop_back(self)

    def erase(self, *args) -> "std::vector< std::int64_t >::iterator":
        return _CSTL.VecLong_erase(self, *args)

    def __init__(self, *args):
        _CSTL.VecLong_swiginit(self, _CSTL.new_VecLong(*args))

    def push_back(self, x: "std::vector< std::int64_t >::value_type const &") -> "void":
        return _CSTL.VecLong_push_back(self, x)

    def front(self) -> "std::vector< std::int64_t >::value_type const &":
        return _CSTL.VecLong_front(self)

    def back(self) -> "std::vector< std::int64_t >::value_type const &":
        return _CSTL.VecLong_back(self)

    def assign(self, n: "std::vector< std::int64_t >::size_type", x: "std::vector< std::int64_t >::value_type const &") -> "void":
        return _CSTL.VecLong_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _CSTL.VecLong_resize(self, *args)

    def insert(self, *args) -> "void":
        return _CSTL.VecLong_insert(self, *args)

    def reserve(self, n: "std::vector< std::int64_t >::size_type") -> "void":
        return _CSTL.VecLong_reserve(self, n)

    def capacity(self) -> "std::vector< std::int64_t >::size_type":
        return _CSTL.VecLong_capacity(self)
    __swig_destroy__ = _CSTL.delete_VecLong

# Register VecLong in _CSTL:
_CSTL.VecLong_swigregister(VecLong)

class SetInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.SetInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.SetInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.SetInt___bool__(self)

    def __len__(self) -> "std::unordered_set< int >::size_type":
        return _CSTL.SetInt___len__(self)

    def append(self, x: "std::unordered_set< int >::value_type") -> "void":
        return _CSTL.SetInt_append(self, x)

    def __contains__(self, x: "std::unordered_set< int >::value_type") -> "bool":
        return _CSTL.SetInt___contains__(self, x)

    def __getitem__(self, i: "std::unordered_set< int >::difference_type") -> "std::unordered_set< int >::value_type":
        return _CSTL.SetInt___getitem__(self, i)

    def __init__(self, *args):
        _CSTL.SetInt_swiginit(self, _CSTL.new_SetInt(*args))

    def empty(self) -> "bool":
        return _CSTL.SetInt_empty(self)

    def size(self) -> "std::unordered_set< int >::size_type":
        return _CSTL.SetInt_size(self)

    def clear(self) -> "void":
        return _CSTL.SetInt_clear(self)

    def swap(self, v: "SetInt") -> "void":
        return _CSTL.SetInt_swap(self, v)

    def count(self, x: "std::unordered_set< int >::key_type const &") -> "std::unordered_set< int >::size_type":
        return _CSTL.SetInt_count(self, x)

    def begin(self) -> "std::unordered_set< int >::iterator":
        return _CSTL.SetInt_begin(self)

    def end(self) -> "std::unordered_set< int >::iterator":
        return _CSTL.SetInt_end(self)

    def erase(self, *args) -> "void":
        return _CSTL.SetInt_erase(self, *args)

    def find(self, x: "std::unordered_set< int >::key_type const &") -> "std::unordered_set< int >::iterator":
        return _CSTL.SetInt_find(self, x)

    def equal_range(self, x: "std::unordered_set< int >::key_type const &") -> "std::pair< std::unordered_set< int >::iterator,std::unordered_set< int >::iterator >":
        return _CSTL.SetInt_equal_range(self, x)

    def insert(self, __x: "std::unordered_set< int >::value_type const &") -> "std::pair< std::unordered_set< int >::iterator,bool >":
        return _CSTL.SetInt_insert(self, __x)
    __swig_destroy__ = _CSTL.delete_SetInt

# Register SetInt in _CSTL:
_CSTL.SetInt_swigregister(SetInt)

class SetStr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.SetStr_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.SetStr___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.SetStr___bool__(self)

    def __len__(self) -> "std::unordered_set< std::string >::size_type":
        return _CSTL.SetStr___len__(self)

    def append(self, x: "std::unordered_set< std::string >::value_type") -> "void":
        return _CSTL.SetStr_append(self, x)

    def __contains__(self, x: "std::unordered_set< std::string >::value_type") -> "bool":
        return _CSTL.SetStr___contains__(self, x)

    def __getitem__(self, i: "std::unordered_set< std::string >::difference_type") -> "std::unordered_set< std::string >::value_type":
        return _CSTL.SetStr___getitem__(self, i)

    def __init__(self, *args):
        _CSTL.SetStr_swiginit(self, _CSTL.new_SetStr(*args))

    def empty(self) -> "bool":
        return _CSTL.SetStr_empty(self)

    def size(self) -> "std::unordered_set< std::string >::size_type":
        return _CSTL.SetStr_size(self)

    def clear(self) -> "void":
        return _CSTL.SetStr_clear(self)

    def swap(self, v: "SetStr") -> "void":
        return _CSTL.SetStr_swap(self, v)

    def count(self, x: "std::unordered_set< std::string >::key_type const &") -> "std::unordered_set< std::string >::size_type":
        return _CSTL.SetStr_count(self, x)

    def begin(self) -> "std::unordered_set< std::string >::iterator":
        return _CSTL.SetStr_begin(self)

    def end(self) -> "std::unordered_set< std::string >::iterator":
        return _CSTL.SetStr_end(self)

    def erase(self, *args) -> "void":
        return _CSTL.SetStr_erase(self, *args)

    def find(self, x: "std::unordered_set< std::string >::key_type const &") -> "std::unordered_set< std::string >::iterator":
        return _CSTL.SetStr_find(self, x)

    def equal_range(self, x: "std::unordered_set< std::string >::key_type const &") -> "std::pair< std::unordered_set< std::string >::iterator,std::unordered_set< std::string >::iterator >":
        return _CSTL.SetStr_equal_range(self, x)

    def insert(self, __x: "std::unordered_set< std::string >::value_type const &") -> "std::pair< std::unordered_set< std::string >::iterator,bool >":
        return _CSTL.SetStr_insert(self, __x)
    __swig_destroy__ = _CSTL.delete_SetStr

# Register SetStr in _CSTL:
_CSTL.SetStr_swigregister(SetStr)

class SetLong(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.SetLong_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.SetLong___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.SetLong___bool__(self)

    def __len__(self) -> "std::unordered_set< std::int64_t >::size_type":
        return _CSTL.SetLong___len__(self)

    def append(self, x: "std::unordered_set< std::int64_t >::value_type") -> "void":
        return _CSTL.SetLong_append(self, x)

    def __contains__(self, x: "std::unordered_set< std::int64_t >::value_type") -> "bool":
        return _CSTL.SetLong___contains__(self, x)

    def __getitem__(self, i: "std::unordered_set< std::int64_t >::difference_type") -> "std::unordered_set< std::int64_t >::value_type":
        return _CSTL.SetLong___getitem__(self, i)

    def __init__(self, *args):
        _CSTL.SetLong_swiginit(self, _CSTL.new_SetLong(*args))

    def empty(self) -> "bool":
        return _CSTL.SetLong_empty(self)

    def size(self) -> "std::unordered_set< std::int64_t >::size_type":
        return _CSTL.SetLong_size(self)

    def clear(self) -> "void":
        return _CSTL.SetLong_clear(self)

    def swap(self, v: "SetLong") -> "void":
        return _CSTL.SetLong_swap(self, v)

    def count(self, x: "std::unordered_set< std::int64_t >::key_type const &") -> "std::unordered_set< std::int64_t >::size_type":
        return _CSTL.SetLong_count(self, x)

    def begin(self) -> "std::unordered_set< std::int64_t >::iterator":
        return _CSTL.SetLong_begin(self)

    def end(self) -> "std::unordered_set< std::int64_t >::iterator":
        return _CSTL.SetLong_end(self)

    def erase(self, *args) -> "void":
        return _CSTL.SetLong_erase(self, *args)

    def find(self, x: "std::unordered_set< std::int64_t >::key_type const &") -> "std::unordered_set< std::int64_t >::iterator":
        return _CSTL.SetLong_find(self, x)

    def equal_range(self, x: "std::unordered_set< std::int64_t >::key_type const &") -> "std::pair< std::unordered_set< std::int64_t >::iterator,std::unordered_set< std::int64_t >::iterator >":
        return _CSTL.SetLong_equal_range(self, x)

    def insert(self, __x: "std::unordered_set< std::int64_t >::value_type const &") -> "std::pair< std::unordered_set< std::int64_t >::iterator,bool >":
        return _CSTL.SetLong_insert(self, __x)
    __swig_destroy__ = _CSTL.delete_SetLong

# Register SetLong in _CSTL:
_CSTL.SetLong_swigregister(SetLong)

class MapIntInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapIntInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapIntInt___bool__(self)

    def __len__(self) -> "std::unordered_map< int,int >::size_type":
        return _CSTL.MapIntInt___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< int,int >::key_type const &") -> "std::unordered_map< int,int >::mapped_type const &":
        return _CSTL.MapIntInt___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< int,int >::key_type const &") -> "void":
        return _CSTL.MapIntInt___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< int,int >::key_type const &") -> "bool":
        return _CSTL.MapIntInt_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapIntInt_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapIntInt_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapIntInt_items(self)

    def __contains__(self, key: "std::unordered_map< int,int >::key_type const &") -> "bool":
        return _CSTL.MapIntInt___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntInt_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntInt_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapIntInt___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapIntInt_asdict(self)

    def __init__(self, *args):
        _CSTL.MapIntInt_swiginit(self, _CSTL.new_MapIntInt(*args))

    def empty(self) -> "bool":
        return _CSTL.MapIntInt_empty(self)

    def size(self) -> "std::unordered_map< int,int >::size_type":
        return _CSTL.MapIntInt_size(self)

    def swap(self, v: "MapIntInt") -> "void":
        return _CSTL.MapIntInt_swap(self, v)

    def begin(self) -> "std::unordered_map< int,int >::iterator":
        return _CSTL.MapIntInt_begin(self)

    def end(self) -> "std::unordered_map< int,int >::iterator":
        return _CSTL.MapIntInt_end(self)

    def clear(self) -> "void":
        return _CSTL.MapIntInt_clear(self)

    def get_allocator(self) -> "std::unordered_map< int,int >::allocator_type":
        return _CSTL.MapIntInt_get_allocator(self)

    def count(self, x: "std::unordered_map< int,int >::key_type const &") -> "std::unordered_map< int,int >::size_type":
        return _CSTL.MapIntInt_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapIntInt_erase(self, *args)

    def find(self, x: "std::unordered_map< int,int >::key_type const &") -> "std::unordered_map< int,int >::iterator":
        return _CSTL.MapIntInt_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapIntInt

# Register MapIntInt in _CSTL:
_CSTL.MapIntInt_swigregister(MapIntInt)

class MapIntStr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntStr_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapIntStr___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapIntStr___bool__(self)

    def __len__(self) -> "std::unordered_map< int,std::string >::size_type":
        return _CSTL.MapIntStr___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< int,std::string >::key_type const &") -> "std::unordered_map< int,std::string >::mapped_type const &":
        return _CSTL.MapIntStr___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< int,std::string >::key_type const &") -> "void":
        return _CSTL.MapIntStr___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< int,std::string >::key_type const &") -> "bool":
        return _CSTL.MapIntStr_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapIntStr_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapIntStr_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapIntStr_items(self)

    def __contains__(self, key: "std::unordered_map< int,std::string >::key_type const &") -> "bool":
        return _CSTL.MapIntStr___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntStr_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntStr_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapIntStr___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapIntStr_asdict(self)

    def __init__(self, *args):
        _CSTL.MapIntStr_swiginit(self, _CSTL.new_MapIntStr(*args))

    def empty(self) -> "bool":
        return _CSTL.MapIntStr_empty(self)

    def size(self) -> "std::unordered_map< int,std::string >::size_type":
        return _CSTL.MapIntStr_size(self)

    def swap(self, v: "MapIntStr") -> "void":
        return _CSTL.MapIntStr_swap(self, v)

    def begin(self) -> "std::unordered_map< int,std::string >::iterator":
        return _CSTL.MapIntStr_begin(self)

    def end(self) -> "std::unordered_map< int,std::string >::iterator":
        return _CSTL.MapIntStr_end(self)

    def clear(self) -> "void":
        return _CSTL.MapIntStr_clear(self)

    def get_allocator(self) -> "std::unordered_map< int,std::string >::allocator_type":
        return _CSTL.MapIntStr_get_allocator(self)

    def count(self, x: "std::unordered_map< int,std::string >::key_type const &") -> "std::unordered_map< int,std::string >::size_type":
        return _CSTL.MapIntStr_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapIntStr_erase(self, *args)

    def find(self, x: "std::unordered_map< int,std::string >::key_type const &") -> "std::unordered_map< int,std::string >::iterator":
        return _CSTL.MapIntStr_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapIntStr

# Register MapIntStr in _CSTL:
_CSTL.MapIntStr_swigregister(MapIntStr)

class MapIntFloat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntFloat_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapIntFloat___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapIntFloat___bool__(self)

    def __len__(self) -> "std::unordered_map< int,float >::size_type":
        return _CSTL.MapIntFloat___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< int,float >::key_type const &") -> "std::unordered_map< int,float >::mapped_type const &":
        return _CSTL.MapIntFloat___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< int,float >::key_type const &") -> "void":
        return _CSTL.MapIntFloat___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< int,float >::key_type const &") -> "bool":
        return _CSTL.MapIntFloat_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapIntFloat_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapIntFloat_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapIntFloat_items(self)

    def __contains__(self, key: "std::unordered_map< int,float >::key_type const &") -> "bool":
        return _CSTL.MapIntFloat___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntFloat_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntFloat_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapIntFloat___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapIntFloat_asdict(self)

    def __init__(self, *args):
        _CSTL.MapIntFloat_swiginit(self, _CSTL.new_MapIntFloat(*args))

    def empty(self) -> "bool":
        return _CSTL.MapIntFloat_empty(self)

    def size(self) -> "std::unordered_map< int,float >::size_type":
        return _CSTL.MapIntFloat_size(self)

    def swap(self, v: "MapIntFloat") -> "void":
        return _CSTL.MapIntFloat_swap(self, v)

    def begin(self) -> "std::unordered_map< int,float >::iterator":
        return _CSTL.MapIntFloat_begin(self)

    def end(self) -> "std::unordered_map< int,float >::iterator":
        return _CSTL.MapIntFloat_end(self)

    def clear(self) -> "void":
        return _CSTL.MapIntFloat_clear(self)

    def get_allocator(self) -> "std::unordered_map< int,float >::allocator_type":
        return _CSTL.MapIntFloat_get_allocator(self)

    def count(self, x: "std::unordered_map< int,float >::key_type const &") -> "std::unordered_map< int,float >::size_type":
        return _CSTL.MapIntFloat_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapIntFloat_erase(self, *args)

    def find(self, x: "std::unordered_map< int,float >::key_type const &") -> "std::unordered_map< int,float >::iterator":
        return _CSTL.MapIntFloat_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapIntFloat

# Register MapIntFloat in _CSTL:
_CSTL.MapIntFloat_swigregister(MapIntFloat)

class MapIntDouble(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapIntDouble___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapIntDouble___bool__(self)

    def __len__(self) -> "std::unordered_map< int,double >::size_type":
        return _CSTL.MapIntDouble___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< int,double >::key_type const &") -> "std::unordered_map< int,double >::mapped_type const &":
        return _CSTL.MapIntDouble___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< int,double >::key_type const &") -> "void":
        return _CSTL.MapIntDouble___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< int,double >::key_type const &") -> "bool":
        return _CSTL.MapIntDouble_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapIntDouble_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapIntDouble_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapIntDouble_items(self)

    def __contains__(self, key: "std::unordered_map< int,double >::key_type const &") -> "bool":
        return _CSTL.MapIntDouble___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntDouble_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntDouble_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapIntDouble___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapIntDouble_asdict(self)

    def __init__(self, *args):
        _CSTL.MapIntDouble_swiginit(self, _CSTL.new_MapIntDouble(*args))

    def empty(self) -> "bool":
        return _CSTL.MapIntDouble_empty(self)

    def size(self) -> "std::unordered_map< int,double >::size_type":
        return _CSTL.MapIntDouble_size(self)

    def swap(self, v: "MapIntDouble") -> "void":
        return _CSTL.MapIntDouble_swap(self, v)

    def begin(self) -> "std::unordered_map< int,double >::iterator":
        return _CSTL.MapIntDouble_begin(self)

    def end(self) -> "std::unordered_map< int,double >::iterator":
        return _CSTL.MapIntDouble_end(self)

    def clear(self) -> "void":
        return _CSTL.MapIntDouble_clear(self)

    def get_allocator(self) -> "std::unordered_map< int,double >::allocator_type":
        return _CSTL.MapIntDouble_get_allocator(self)

    def count(self, x: "std::unordered_map< int,double >::key_type const &") -> "std::unordered_map< int,double >::size_type":
        return _CSTL.MapIntDouble_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapIntDouble_erase(self, *args)

    def find(self, x: "std::unordered_map< int,double >::key_type const &") -> "std::unordered_map< int,double >::iterator":
        return _CSTL.MapIntDouble_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapIntDouble

# Register MapIntDouble in _CSTL:
_CSTL.MapIntDouble_swigregister(MapIntDouble)

class MapIntBool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntBool_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapIntBool___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapIntBool___bool__(self)

    def __len__(self) -> "std::unordered_map< int,bool >::size_type":
        return _CSTL.MapIntBool___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< int,bool >::key_type const &") -> "std::unordered_map< int,bool >::mapped_type const &":
        return _CSTL.MapIntBool___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< int,bool >::key_type const &") -> "void":
        return _CSTL.MapIntBool___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< int,bool >::key_type const &") -> "bool":
        return _CSTL.MapIntBool_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapIntBool_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapIntBool_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapIntBool_items(self)

    def __contains__(self, key: "std::unordered_map< int,bool >::key_type const &") -> "bool":
        return _CSTL.MapIntBool___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntBool_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntBool_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapIntBool___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapIntBool_asdict(self)

    def __init__(self, *args):
        _CSTL.MapIntBool_swiginit(self, _CSTL.new_MapIntBool(*args))

    def empty(self) -> "bool":
        return _CSTL.MapIntBool_empty(self)

    def size(self) -> "std::unordered_map< int,bool >::size_type":
        return _CSTL.MapIntBool_size(self)

    def swap(self, v: "MapIntBool") -> "void":
        return _CSTL.MapIntBool_swap(self, v)

    def begin(self) -> "std::unordered_map< int,bool >::iterator":
        return _CSTL.MapIntBool_begin(self)

    def end(self) -> "std::unordered_map< int,bool >::iterator":
        return _CSTL.MapIntBool_end(self)

    def clear(self) -> "void":
        return _CSTL.MapIntBool_clear(self)

    def get_allocator(self) -> "std::unordered_map< int,bool >::allocator_type":
        return _CSTL.MapIntBool_get_allocator(self)

    def count(self, x: "std::unordered_map< int,bool >::key_type const &") -> "std::unordered_map< int,bool >::size_type":
        return _CSTL.MapIntBool_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapIntBool_erase(self, *args)

    def find(self, x: "std::unordered_map< int,bool >::key_type const &") -> "std::unordered_map< int,bool >::iterator":
        return _CSTL.MapIntBool_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapIntBool

# Register MapIntBool in _CSTL:
_CSTL.MapIntBool_swigregister(MapIntBool)

class MapIntLong(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntLong_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapIntLong___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapIntLong___bool__(self)

    def __len__(self) -> "std::unordered_map< int,std::int64_t >::size_type":
        return _CSTL.MapIntLong___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< int,std::int64_t >::key_type const &") -> "std::unordered_map< int,std::int64_t >::mapped_type const &":
        return _CSTL.MapIntLong___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< int,std::int64_t >::key_type const &") -> "void":
        return _CSTL.MapIntLong___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< int,std::int64_t >::key_type const &") -> "bool":
        return _CSTL.MapIntLong_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapIntLong_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapIntLong_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapIntLong_items(self)

    def __contains__(self, key: "std::unordered_map< int,std::int64_t >::key_type const &") -> "bool":
        return _CSTL.MapIntLong___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntLong_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapIntLong_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapIntLong___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapIntLong_asdict(self)

    def __init__(self, *args):
        _CSTL.MapIntLong_swiginit(self, _CSTL.new_MapIntLong(*args))

    def empty(self) -> "bool":
        return _CSTL.MapIntLong_empty(self)

    def size(self) -> "std::unordered_map< int,std::int64_t >::size_type":
        return _CSTL.MapIntLong_size(self)

    def swap(self, v: "MapIntLong") -> "void":
        return _CSTL.MapIntLong_swap(self, v)

    def begin(self) -> "std::unordered_map< int,std::int64_t >::iterator":
        return _CSTL.MapIntLong_begin(self)

    def end(self) -> "std::unordered_map< int,std::int64_t >::iterator":
        return _CSTL.MapIntLong_end(self)

    def clear(self) -> "void":
        return _CSTL.MapIntLong_clear(self)

    def get_allocator(self) -> "std::unordered_map< int,std::int64_t >::allocator_type":
        return _CSTL.MapIntLong_get_allocator(self)

    def count(self, x: "std::unordered_map< int,std::int64_t >::key_type const &") -> "std::unordered_map< int,std::int64_t >::size_type":
        return _CSTL.MapIntLong_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapIntLong_erase(self, *args)

    def find(self, x: "std::unordered_map< int,std::int64_t >::key_type const &") -> "std::unordered_map< int,std::int64_t >::iterator":
        return _CSTL.MapIntLong_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapIntLong

# Register MapIntLong in _CSTL:
_CSTL.MapIntLong_swigregister(MapIntLong)

class MapStrInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapStrInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapStrInt___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,int >::size_type":
        return _CSTL.MapStrInt___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,int >::key_type const &") -> "std::unordered_map< std::string,int >::mapped_type const &":
        return _CSTL.MapStrInt___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,int >::key_type const &") -> "void":
        return _CSTL.MapStrInt___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,int >::key_type const &") -> "bool":
        return _CSTL.MapStrInt_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapStrInt_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapStrInt_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapStrInt_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,int >::key_type const &") -> "bool":
        return _CSTL.MapStrInt___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrInt_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrInt_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapStrInt___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapStrInt_asdict(self)

    def __init__(self, *args):
        _CSTL.MapStrInt_swiginit(self, _CSTL.new_MapStrInt(*args))

    def empty(self) -> "bool":
        return _CSTL.MapStrInt_empty(self)

    def size(self) -> "std::unordered_map< std::string,int >::size_type":
        return _CSTL.MapStrInt_size(self)

    def swap(self, v: "MapStrInt") -> "void":
        return _CSTL.MapStrInt_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,int >::iterator":
        return _CSTL.MapStrInt_begin(self)

    def end(self) -> "std::unordered_map< std::string,int >::iterator":
        return _CSTL.MapStrInt_end(self)

    def clear(self) -> "void":
        return _CSTL.MapStrInt_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,int >::allocator_type":
        return _CSTL.MapStrInt_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,int >::key_type const &") -> "std::unordered_map< std::string,int >::size_type":
        return _CSTL.MapStrInt_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapStrInt_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,int >::key_type const &") -> "std::unordered_map< std::string,int >::iterator":
        return _CSTL.MapStrInt_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapStrInt

# Register MapStrInt in _CSTL:
_CSTL.MapStrInt_swigregister(MapStrInt)

class MapStrStr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrStr_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapStrStr___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapStrStr___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,std::string >::size_type":
        return _CSTL.MapStrStr___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,std::string >::key_type const &") -> "std::unordered_map< std::string,std::string >::mapped_type const &":
        return _CSTL.MapStrStr___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,std::string >::key_type const &") -> "void":
        return _CSTL.MapStrStr___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,std::string >::key_type const &") -> "bool":
        return _CSTL.MapStrStr_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapStrStr_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapStrStr_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapStrStr_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,std::string >::key_type const &") -> "bool":
        return _CSTL.MapStrStr___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrStr_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrStr_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapStrStr___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapStrStr_asdict(self)

    def __init__(self, *args):
        _CSTL.MapStrStr_swiginit(self, _CSTL.new_MapStrStr(*args))

    def empty(self) -> "bool":
        return _CSTL.MapStrStr_empty(self)

    def size(self) -> "std::unordered_map< std::string,std::string >::size_type":
        return _CSTL.MapStrStr_size(self)

    def swap(self, v: "MapStrStr") -> "void":
        return _CSTL.MapStrStr_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,std::string >::iterator":
        return _CSTL.MapStrStr_begin(self)

    def end(self) -> "std::unordered_map< std::string,std::string >::iterator":
        return _CSTL.MapStrStr_end(self)

    def clear(self) -> "void":
        return _CSTL.MapStrStr_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,std::string >::allocator_type":
        return _CSTL.MapStrStr_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,std::string >::key_type const &") -> "std::unordered_map< std::string,std::string >::size_type":
        return _CSTL.MapStrStr_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapStrStr_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,std::string >::key_type const &") -> "std::unordered_map< std::string,std::string >::iterator":
        return _CSTL.MapStrStr_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapStrStr

# Register MapStrStr in _CSTL:
_CSTL.MapStrStr_swigregister(MapStrStr)

class MapStrFloat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrFloat_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapStrFloat___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapStrFloat___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,float >::size_type":
        return _CSTL.MapStrFloat___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,float >::key_type const &") -> "std::unordered_map< std::string,float >::mapped_type const &":
        return _CSTL.MapStrFloat___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,float >::key_type const &") -> "void":
        return _CSTL.MapStrFloat___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,float >::key_type const &") -> "bool":
        return _CSTL.MapStrFloat_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapStrFloat_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapStrFloat_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapStrFloat_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,float >::key_type const &") -> "bool":
        return _CSTL.MapStrFloat___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrFloat_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrFloat_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapStrFloat___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapStrFloat_asdict(self)

    def __init__(self, *args):
        _CSTL.MapStrFloat_swiginit(self, _CSTL.new_MapStrFloat(*args))

    def empty(self) -> "bool":
        return _CSTL.MapStrFloat_empty(self)

    def size(self) -> "std::unordered_map< std::string,float >::size_type":
        return _CSTL.MapStrFloat_size(self)

    def swap(self, v: "MapStrFloat") -> "void":
        return _CSTL.MapStrFloat_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,float >::iterator":
        return _CSTL.MapStrFloat_begin(self)

    def end(self) -> "std::unordered_map< std::string,float >::iterator":
        return _CSTL.MapStrFloat_end(self)

    def clear(self) -> "void":
        return _CSTL.MapStrFloat_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,float >::allocator_type":
        return _CSTL.MapStrFloat_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,float >::key_type const &") -> "std::unordered_map< std::string,float >::size_type":
        return _CSTL.MapStrFloat_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapStrFloat_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,float >::key_type const &") -> "std::unordered_map< std::string,float >::iterator":
        return _CSTL.MapStrFloat_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapStrFloat

# Register MapStrFloat in _CSTL:
_CSTL.MapStrFloat_swigregister(MapStrFloat)

class MapStrDouble(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapStrDouble___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapStrDouble___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,double >::size_type":
        return _CSTL.MapStrDouble___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,double >::key_type const &") -> "std::unordered_map< std::string,double >::mapped_type const &":
        return _CSTL.MapStrDouble___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,double >::key_type const &") -> "void":
        return _CSTL.MapStrDouble___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,double >::key_type const &") -> "bool":
        return _CSTL.MapStrDouble_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapStrDouble_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapStrDouble_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapStrDouble_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,double >::key_type const &") -> "bool":
        return _CSTL.MapStrDouble___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrDouble_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrDouble_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapStrDouble___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapStrDouble_asdict(self)

    def __init__(self, *args):
        _CSTL.MapStrDouble_swiginit(self, _CSTL.new_MapStrDouble(*args))

    def empty(self) -> "bool":
        return _CSTL.MapStrDouble_empty(self)

    def size(self) -> "std::unordered_map< std::string,double >::size_type":
        return _CSTL.MapStrDouble_size(self)

    def swap(self, v: "MapStrDouble") -> "void":
        return _CSTL.MapStrDouble_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,double >::iterator":
        return _CSTL.MapStrDouble_begin(self)

    def end(self) -> "std::unordered_map< std::string,double >::iterator":
        return _CSTL.MapStrDouble_end(self)

    def clear(self) -> "void":
        return _CSTL.MapStrDouble_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,double >::allocator_type":
        return _CSTL.MapStrDouble_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,double >::key_type const &") -> "std::unordered_map< std::string,double >::size_type":
        return _CSTL.MapStrDouble_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapStrDouble_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,double >::key_type const &") -> "std::unordered_map< std::string,double >::iterator":
        return _CSTL.MapStrDouble_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapStrDouble

# Register MapStrDouble in _CSTL:
_CSTL.MapStrDouble_swigregister(MapStrDouble)

class MapStrBool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrBool_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapStrBool___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapStrBool___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,bool >::size_type":
        return _CSTL.MapStrBool___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,bool >::key_type const &") -> "std::unordered_map< std::string,bool >::mapped_type const &":
        return _CSTL.MapStrBool___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,bool >::key_type const &") -> "void":
        return _CSTL.MapStrBool___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,bool >::key_type const &") -> "bool":
        return _CSTL.MapStrBool_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapStrBool_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapStrBool_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapStrBool_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,bool >::key_type const &") -> "bool":
        return _CSTL.MapStrBool___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrBool_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrBool_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapStrBool___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapStrBool_asdict(self)

    def __init__(self, *args):
        _CSTL.MapStrBool_swiginit(self, _CSTL.new_MapStrBool(*args))

    def empty(self) -> "bool":
        return _CSTL.MapStrBool_empty(self)

    def size(self) -> "std::unordered_map< std::string,bool >::size_type":
        return _CSTL.MapStrBool_size(self)

    def swap(self, v: "MapStrBool") -> "void":
        return _CSTL.MapStrBool_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,bool >::iterator":
        return _CSTL.MapStrBool_begin(self)

    def end(self) -> "std::unordered_map< std::string,bool >::iterator":
        return _CSTL.MapStrBool_end(self)

    def clear(self) -> "void":
        return _CSTL.MapStrBool_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,bool >::allocator_type":
        return _CSTL.MapStrBool_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,bool >::key_type const &") -> "std::unordered_map< std::string,bool >::size_type":
        return _CSTL.MapStrBool_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapStrBool_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,bool >::key_type const &") -> "std::unordered_map< std::string,bool >::iterator":
        return _CSTL.MapStrBool_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapStrBool

# Register MapStrBool in _CSTL:
_CSTL.MapStrBool_swigregister(MapStrBool)

class MapStrLong(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrLong_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapStrLong___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapStrLong___bool__(self)

    def __len__(self) -> "std::unordered_map< std::string,std::int64_t >::size_type":
        return _CSTL.MapStrLong___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::string,std::int64_t >::key_type const &") -> "std::unordered_map< std::string,std::int64_t >::mapped_type const &":
        return _CSTL.MapStrLong___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::string,std::int64_t >::key_type const &") -> "void":
        return _CSTL.MapStrLong___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::string,std::int64_t >::key_type const &") -> "bool":
        return _CSTL.MapStrLong_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapStrLong_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapStrLong_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapStrLong_items(self)

    def __contains__(self, key: "std::unordered_map< std::string,std::int64_t >::key_type const &") -> "bool":
        return _CSTL.MapStrLong___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrLong_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapStrLong_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapStrLong___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapStrLong_asdict(self)

    def __init__(self, *args):
        _CSTL.MapStrLong_swiginit(self, _CSTL.new_MapStrLong(*args))

    def empty(self) -> "bool":
        return _CSTL.MapStrLong_empty(self)

    def size(self) -> "std::unordered_map< std::string,std::int64_t >::size_type":
        return _CSTL.MapStrLong_size(self)

    def swap(self, v: "MapStrLong") -> "void":
        return _CSTL.MapStrLong_swap(self, v)

    def begin(self) -> "std::unordered_map< std::string,std::int64_t >::iterator":
        return _CSTL.MapStrLong_begin(self)

    def end(self) -> "std::unordered_map< std::string,std::int64_t >::iterator":
        return _CSTL.MapStrLong_end(self)

    def clear(self) -> "void":
        return _CSTL.MapStrLong_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::string,std::int64_t >::allocator_type":
        return _CSTL.MapStrLong_get_allocator(self)

    def count(self, x: "std::unordered_map< std::string,std::int64_t >::key_type const &") -> "std::unordered_map< std::string,std::int64_t >::size_type":
        return _CSTL.MapStrLong_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapStrLong_erase(self, *args)

    def find(self, x: "std::unordered_map< std::string,std::int64_t >::key_type const &") -> "std::unordered_map< std::string,std::int64_t >::iterator":
        return _CSTL.MapStrLong_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapStrLong

# Register MapStrLong in _CSTL:
_CSTL.MapStrLong_swigregister(MapStrLong)

class MapLongInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapLongInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapLongInt___bool__(self)

    def __len__(self) -> "std::unordered_map< std::int64_t,int >::size_type":
        return _CSTL.MapLongInt___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::int64_t,int >::key_type const &") -> "std::unordered_map< std::int64_t,int >::mapped_type const &":
        return _CSTL.MapLongInt___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::int64_t,int >::key_type const &") -> "void":
        return _CSTL.MapLongInt___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::int64_t,int >::key_type const &") -> "bool":
        return _CSTL.MapLongInt_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapLongInt_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapLongInt_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapLongInt_items(self)

    def __contains__(self, key: "std::unordered_map< std::int64_t,int >::key_type const &") -> "bool":
        return _CSTL.MapLongInt___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongInt_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongInt_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapLongInt___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapLongInt_asdict(self)

    def __init__(self, *args):
        _CSTL.MapLongInt_swiginit(self, _CSTL.new_MapLongInt(*args))

    def empty(self) -> "bool":
        return _CSTL.MapLongInt_empty(self)

    def size(self) -> "std::unordered_map< std::int64_t,int >::size_type":
        return _CSTL.MapLongInt_size(self)

    def swap(self, v: "MapLongInt") -> "void":
        return _CSTL.MapLongInt_swap(self, v)

    def begin(self) -> "std::unordered_map< std::int64_t,int >::iterator":
        return _CSTL.MapLongInt_begin(self)

    def end(self) -> "std::unordered_map< std::int64_t,int >::iterator":
        return _CSTL.MapLongInt_end(self)

    def clear(self) -> "void":
        return _CSTL.MapLongInt_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::int64_t,int >::allocator_type":
        return _CSTL.MapLongInt_get_allocator(self)

    def count(self, x: "std::unordered_map< std::int64_t,int >::key_type const &") -> "std::unordered_map< std::int64_t,int >::size_type":
        return _CSTL.MapLongInt_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapLongInt_erase(self, *args)

    def find(self, x: "std::unordered_map< std::int64_t,int >::key_type const &") -> "std::unordered_map< std::int64_t,int >::iterator":
        return _CSTL.MapLongInt_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapLongInt

# Register MapLongInt in _CSTL:
_CSTL.MapLongInt_swigregister(MapLongInt)

class MapLongStr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongStr_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapLongStr___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapLongStr___bool__(self)

    def __len__(self) -> "std::unordered_map< std::int64_t,std::string >::size_type":
        return _CSTL.MapLongStr___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::int64_t,std::string >::key_type const &") -> "std::unordered_map< std::int64_t,std::string >::mapped_type const &":
        return _CSTL.MapLongStr___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::int64_t,std::string >::key_type const &") -> "void":
        return _CSTL.MapLongStr___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::int64_t,std::string >::key_type const &") -> "bool":
        return _CSTL.MapLongStr_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapLongStr_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapLongStr_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapLongStr_items(self)

    def __contains__(self, key: "std::unordered_map< std::int64_t,std::string >::key_type const &") -> "bool":
        return _CSTL.MapLongStr___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongStr_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongStr_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapLongStr___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapLongStr_asdict(self)

    def __init__(self, *args):
        _CSTL.MapLongStr_swiginit(self, _CSTL.new_MapLongStr(*args))

    def empty(self) -> "bool":
        return _CSTL.MapLongStr_empty(self)

    def size(self) -> "std::unordered_map< std::int64_t,std::string >::size_type":
        return _CSTL.MapLongStr_size(self)

    def swap(self, v: "MapLongStr") -> "void":
        return _CSTL.MapLongStr_swap(self, v)

    def begin(self) -> "std::unordered_map< std::int64_t,std::string >::iterator":
        return _CSTL.MapLongStr_begin(self)

    def end(self) -> "std::unordered_map< std::int64_t,std::string >::iterator":
        return _CSTL.MapLongStr_end(self)

    def clear(self) -> "void":
        return _CSTL.MapLongStr_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::int64_t,std::string >::allocator_type":
        return _CSTL.MapLongStr_get_allocator(self)

    def count(self, x: "std::unordered_map< std::int64_t,std::string >::key_type const &") -> "std::unordered_map< std::int64_t,std::string >::size_type":
        return _CSTL.MapLongStr_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapLongStr_erase(self, *args)

    def find(self, x: "std::unordered_map< std::int64_t,std::string >::key_type const &") -> "std::unordered_map< std::int64_t,std::string >::iterator":
        return _CSTL.MapLongStr_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapLongStr

# Register MapLongStr in _CSTL:
_CSTL.MapLongStr_swigregister(MapLongStr)

class MapLongFloat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongFloat_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapLongFloat___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapLongFloat___bool__(self)

    def __len__(self) -> "std::unordered_map< std::int64_t,float >::size_type":
        return _CSTL.MapLongFloat___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::int64_t,float >::key_type const &") -> "std::unordered_map< std::int64_t,float >::mapped_type const &":
        return _CSTL.MapLongFloat___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::int64_t,float >::key_type const &") -> "void":
        return _CSTL.MapLongFloat___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::int64_t,float >::key_type const &") -> "bool":
        return _CSTL.MapLongFloat_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapLongFloat_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapLongFloat_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapLongFloat_items(self)

    def __contains__(self, key: "std::unordered_map< std::int64_t,float >::key_type const &") -> "bool":
        return _CSTL.MapLongFloat___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongFloat_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongFloat_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapLongFloat___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapLongFloat_asdict(self)

    def __init__(self, *args):
        _CSTL.MapLongFloat_swiginit(self, _CSTL.new_MapLongFloat(*args))

    def empty(self) -> "bool":
        return _CSTL.MapLongFloat_empty(self)

    def size(self) -> "std::unordered_map< std::int64_t,float >::size_type":
        return _CSTL.MapLongFloat_size(self)

    def swap(self, v: "MapLongFloat") -> "void":
        return _CSTL.MapLongFloat_swap(self, v)

    def begin(self) -> "std::unordered_map< std::int64_t,float >::iterator":
        return _CSTL.MapLongFloat_begin(self)

    def end(self) -> "std::unordered_map< std::int64_t,float >::iterator":
        return _CSTL.MapLongFloat_end(self)

    def clear(self) -> "void":
        return _CSTL.MapLongFloat_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::int64_t,float >::allocator_type":
        return _CSTL.MapLongFloat_get_allocator(self)

    def count(self, x: "std::unordered_map< std::int64_t,float >::key_type const &") -> "std::unordered_map< std::int64_t,float >::size_type":
        return _CSTL.MapLongFloat_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapLongFloat_erase(self, *args)

    def find(self, x: "std::unordered_map< std::int64_t,float >::key_type const &") -> "std::unordered_map< std::int64_t,float >::iterator":
        return _CSTL.MapLongFloat_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapLongFloat

# Register MapLongFloat in _CSTL:
_CSTL.MapLongFloat_swigregister(MapLongFloat)

class MapLongDouble(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapLongDouble___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapLongDouble___bool__(self)

    def __len__(self) -> "std::unordered_map< std::int64_t,double >::size_type":
        return _CSTL.MapLongDouble___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::int64_t,double >::key_type const &") -> "std::unordered_map< std::int64_t,double >::mapped_type const &":
        return _CSTL.MapLongDouble___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::int64_t,double >::key_type const &") -> "void":
        return _CSTL.MapLongDouble___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::int64_t,double >::key_type const &") -> "bool":
        return _CSTL.MapLongDouble_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapLongDouble_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapLongDouble_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapLongDouble_items(self)

    def __contains__(self, key: "std::unordered_map< std::int64_t,double >::key_type const &") -> "bool":
        return _CSTL.MapLongDouble___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongDouble_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongDouble_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapLongDouble___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapLongDouble_asdict(self)

    def __init__(self, *args):
        _CSTL.MapLongDouble_swiginit(self, _CSTL.new_MapLongDouble(*args))

    def empty(self) -> "bool":
        return _CSTL.MapLongDouble_empty(self)

    def size(self) -> "std::unordered_map< std::int64_t,double >::size_type":
        return _CSTL.MapLongDouble_size(self)

    def swap(self, v: "MapLongDouble") -> "void":
        return _CSTL.MapLongDouble_swap(self, v)

    def begin(self) -> "std::unordered_map< std::int64_t,double >::iterator":
        return _CSTL.MapLongDouble_begin(self)

    def end(self) -> "std::unordered_map< std::int64_t,double >::iterator":
        return _CSTL.MapLongDouble_end(self)

    def clear(self) -> "void":
        return _CSTL.MapLongDouble_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::int64_t,double >::allocator_type":
        return _CSTL.MapLongDouble_get_allocator(self)

    def count(self, x: "std::unordered_map< std::int64_t,double >::key_type const &") -> "std::unordered_map< std::int64_t,double >::size_type":
        return _CSTL.MapLongDouble_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapLongDouble_erase(self, *args)

    def find(self, x: "std::unordered_map< std::int64_t,double >::key_type const &") -> "std::unordered_map< std::int64_t,double >::iterator":
        return _CSTL.MapLongDouble_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapLongDouble

# Register MapLongDouble in _CSTL:
_CSTL.MapLongDouble_swigregister(MapLongDouble)

class MapLongBool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongBool_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapLongBool___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapLongBool___bool__(self)

    def __len__(self) -> "std::unordered_map< std::int64_t,bool >::size_type":
        return _CSTL.MapLongBool___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::int64_t,bool >::key_type const &") -> "std::unordered_map< std::int64_t,bool >::mapped_type const &":
        return _CSTL.MapLongBool___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::int64_t,bool >::key_type const &") -> "void":
        return _CSTL.MapLongBool___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::int64_t,bool >::key_type const &") -> "bool":
        return _CSTL.MapLongBool_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapLongBool_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapLongBool_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapLongBool_items(self)

    def __contains__(self, key: "std::unordered_map< std::int64_t,bool >::key_type const &") -> "bool":
        return _CSTL.MapLongBool___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongBool_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongBool_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapLongBool___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapLongBool_asdict(self)

    def __init__(self, *args):
        _CSTL.MapLongBool_swiginit(self, _CSTL.new_MapLongBool(*args))

    def empty(self) -> "bool":
        return _CSTL.MapLongBool_empty(self)

    def size(self) -> "std::unordered_map< std::int64_t,bool >::size_type":
        return _CSTL.MapLongBool_size(self)

    def swap(self, v: "MapLongBool") -> "void":
        return _CSTL.MapLongBool_swap(self, v)

    def begin(self) -> "std::unordered_map< std::int64_t,bool >::iterator":
        return _CSTL.MapLongBool_begin(self)

    def end(self) -> "std::unordered_map< std::int64_t,bool >::iterator":
        return _CSTL.MapLongBool_end(self)

    def clear(self) -> "void":
        return _CSTL.MapLongBool_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::int64_t,bool >::allocator_type":
        return _CSTL.MapLongBool_get_allocator(self)

    def count(self, x: "std::unordered_map< std::int64_t,bool >::key_type const &") -> "std::unordered_map< std::int64_t,bool >::size_type":
        return _CSTL.MapLongBool_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapLongBool_erase(self, *args)

    def find(self, x: "std::unordered_map< std::int64_t,bool >::key_type const &") -> "std::unordered_map< std::int64_t,bool >::iterator":
        return _CSTL.MapLongBool_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapLongBool

# Register MapLongBool in _CSTL:
_CSTL.MapLongBool_swigregister(MapLongBool)

class MapLongLong(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongLong_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _CSTL.MapLongLong___nonzero__(self)

    def __bool__(self) -> "bool":
        return _CSTL.MapLongLong___bool__(self)

    def __len__(self) -> "std::unordered_map< std::int64_t,std::int64_t >::size_type":
        return _CSTL.MapLongLong___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::unordered_map< std::int64_t,std::int64_t >::key_type const &") -> "std::unordered_map< std::int64_t,std::int64_t >::mapped_type const &":
        return _CSTL.MapLongLong___getitem__(self, key)

    def __delitem__(self, key: "std::unordered_map< std::int64_t,std::int64_t >::key_type const &") -> "void":
        return _CSTL.MapLongLong___delitem__(self, key)

    def has_key(self, key: "std::unordered_map< std::int64_t,std::int64_t >::key_type const &") -> "bool":
        return _CSTL.MapLongLong_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _CSTL.MapLongLong_keys(self)

    def values(self) -> "PyObject *":
        return _CSTL.MapLongLong_values(self)

    def items(self) -> "PyObject *":
        return _CSTL.MapLongLong_items(self)

    def __contains__(self, key: "std::unordered_map< std::int64_t,std::int64_t >::key_type const &") -> "bool":
        return _CSTL.MapLongLong___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongLong_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _CSTL.MapLongLong_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _CSTL.MapLongLong___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _CSTL.MapLongLong_asdict(self)

    def __init__(self, *args):
        _CSTL.MapLongLong_swiginit(self, _CSTL.new_MapLongLong(*args))

    def empty(self) -> "bool":
        return _CSTL.MapLongLong_empty(self)

    def size(self) -> "std::unordered_map< std::int64_t,std::int64_t >::size_type":
        return _CSTL.MapLongLong_size(self)

    def swap(self, v: "MapLongLong") -> "void":
        return _CSTL.MapLongLong_swap(self, v)

    def begin(self) -> "std::unordered_map< std::int64_t,std::int64_t >::iterator":
        return _CSTL.MapLongLong_begin(self)

    def end(self) -> "std::unordered_map< std::int64_t,std::int64_t >::iterator":
        return _CSTL.MapLongLong_end(self)

    def clear(self) -> "void":
        return _CSTL.MapLongLong_clear(self)

    def get_allocator(self) -> "std::unordered_map< std::int64_t,std::int64_t >::allocator_type":
        return _CSTL.MapLongLong_get_allocator(self)

    def count(self, x: "std::unordered_map< std::int64_t,std::int64_t >::key_type const &") -> "std::unordered_map< std::int64_t,std::int64_t >::size_type":
        return _CSTL.MapLongLong_count(self, x)

    def erase(self, *args) -> "void":
        return _CSTL.MapLongLong_erase(self, *args)

    def find(self, x: "std::unordered_map< std::int64_t,std::int64_t >::key_type const &") -> "std::unordered_map< std::int64_t,std::int64_t >::iterator":
        return _CSTL.MapLongLong_find(self, x)
    __swig_destroy__ = _CSTL.delete_MapLongLong

# Register MapLongLong in _CSTL:
_CSTL.MapLongLong_swigregister(MapLongLong)



