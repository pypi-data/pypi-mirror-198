{"version":3,"file":"0f51b263.js","mappings":";;;AAsGA;;;;;AC+dA","sources":["webpack://home-assistant-frontend/./src/components/ha-color-picker.js","webpack://home-assistant-frontend/./src/dialogs/more-info/components/lights/ha-more-info-view-light-color-picker.ts"],"sourcesContent":["import { html } from \"@polymer/polymer/lib/utils/html-tag\";\n/* eslint-plugin-disable lit */\nimport { PolymerElement } from \"@polymer/polymer/polymer-element\";\nimport { hs2rgb, rgb2hs } from \"../common/color/convert-color\";\nimport { EventsMixin } from \"../mixins/events-mixin\";\n/**\n * Color-picker custom element\n *\n * @appliesMixin EventsMixin\n */\nclass HaColorPicker extends EventsMixin(PolymerElement) {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          user-select: none;\n          -webkit-user-select: none;\n        }\n\n        #canvas {\n          position: relative;\n          width: 100%;\n          max-width: 330px;\n        }\n        #canvas > * {\n          display: block;\n        }\n        #interactionLayer {\n          color: white;\n          position: absolute;\n          cursor: crosshair;\n          width: 100%;\n          height: 100%;\n          overflow: visible;\n        }\n        #backgroundLayer {\n          width: 100%;\n          overflow: visible;\n          --wheel-bordercolor: var(--ha-color-picker-wheel-bordercolor, white);\n          --wheel-borderwidth: var(--ha-color-picker-wheel-borderwidth, 3);\n          --wheel-shadow: var(\n            --ha-color-picker-wheel-shadow,\n            rgb(15, 15, 15) 10px 5px 5px 0px\n          );\n        }\n\n        #marker {\n          fill: currentColor;\n          stroke: var(--ha-color-picker-marker-bordercolor, white);\n          stroke-width: var(--ha-color-picker-marker-borderwidth, 3);\n          filter: url(#marker-shadow);\n        }\n        .dragging #marker {\n        }\n\n        #colorTooltip {\n          display: none;\n          fill: currentColor;\n          stroke: var(--ha-color-picker-tooltip-bordercolor, white);\n          stroke-width: var(--ha-color-picker-tooltip-borderwidth, 3);\n        }\n\n        .touch.dragging #colorTooltip {\n          display: inherit;\n        }\n      </style>\n      <div id=\"canvas\">\n        <svg id=\"interactionLayer\">\n          <defs>\n            <filter\n              id=\"marker-shadow\"\n              x=\"-50%\"\n              y=\"-50%\"\n              width=\"200%\"\n              height=\"200%\"\n              filterUnits=\"objectBoundingBox\"\n            >\n              <feOffset\n                result=\"offOut\"\n                in=\"SourceAlpha\"\n                dx=\"2\"\n                dy=\"2\"\n              ></feOffset>\n              <feGaussianBlur\n                result=\"blurOut\"\n                in=\"offOut\"\n                stdDeviation=\"2\"\n              ></feGaussianBlur>\n              <feComponentTransfer in=\"blurOut\" result=\"alphaOut\">\n                <feFuncA type=\"linear\" slope=\"0.3\"></feFuncA>\n              </feComponentTransfer>\n              <feBlend\n                in=\"SourceGraphic\"\n                in2=\"alphaOut\"\n                mode=\"normal\"\n              ></feBlend>\n            </filter>\n          </defs>\n        </svg>\n        <canvas id=\"backgroundLayer\"></canvas>\n      </div>\n    `;\n  }\n\n  static get properties() {\n    return {\n      hsColor: {\n        type: Object,\n      },\n\n      // use these properties to update the state via attributes\n      desiredHsColor: {\n        type: Object,\n        observer: \"applyHsColor\",\n      },\n\n      // use these properties to update the state via attributes\n      desiredRgbColor: {\n        type: Object,\n        observer: \"applyRgbColor\",\n      },\n\n      // width, height and radius apply to the coordinates of\n      // of the canvas.\n      // border width are relative to these numbers\n      // the onscreen displayed size should be controlled with css\n      // and should be the same or smaller\n      width: {\n        type: Number,\n        value: 500,\n      },\n\n      height: {\n        type: Number,\n        value: 500,\n      },\n\n      radius: {\n        type: Number,\n        value: 225,\n      },\n\n      // the amount segments for the hue\n      // 0 = continuous gradient\n      // other than 0 gives 'pie-pieces'\n      hueSegments: {\n        type: Number,\n        value: 0,\n        observer: \"segmentationChange\",\n      },\n\n      // the amount segments for the hue\n      // 0 = continuous gradient\n      // 1 = only fully saturated\n      // > 1 = segments from white to fully saturated\n      saturationSegments: {\n        type: Number,\n        value: 0,\n        observer: \"segmentationChange\",\n      },\n\n      // set to true to make the segments purely esthetical\n      // this allows selection off all collors, also\n      // interpolated between the segments\n      ignoreSegments: {\n        type: Boolean,\n        value: false,\n      },\n\n      // throttle te amount of 'colorselected' events fired\n      // value is timeout in milliseconds\n      throttle: {\n        type: Number,\n        value: 500,\n      },\n    };\n  }\n\n  ready() {\n    super.ready();\n    this.setupLayers();\n    this.drawColorWheel();\n    this.drawMarker();\n\n    if (this.desiredHsColor) {\n      this.applyHsColor(this.desiredHsColor);\n    }\n\n    if (this.desiredRgbColor) {\n      this.applyRgbColor(this.desiredRgbColor);\n    }\n\n    this.interactionLayer.addEventListener(\"mousedown\", (ev) =>\n      this.onMouseDown(ev)\n    );\n    this.interactionLayer.addEventListener(\"touchstart\", (ev) =>\n      this.onTouchStart(ev)\n    );\n  }\n\n  // converts browser coordinates to canvas canvas coordinates\n  // origin is wheel center\n  // returns {x: X, y: Y} object\n  convertToCanvasCoordinates(clientX, clientY) {\n    const svgPoint = this.interactionLayer.createSVGPoint();\n    svgPoint.x = clientX;\n    svgPoint.y = clientY;\n    const cc = svgPoint.matrixTransform(\n      this.interactionLayer.getScreenCTM().inverse()\n    );\n    return { x: cc.x, y: cc.y };\n  }\n\n  // Mouse events\n\n  onMouseDown(ev) {\n    const cc = this.convertToCanvasCoordinates(ev.clientX, ev.clientY);\n    // return if we're not on the wheel\n    if (!this.isInWheel(cc.x, cc.y)) {\n      return;\n    }\n    // a mousedown in wheel is always a color select action\n    this.onMouseSelect(ev);\n    // allow dragging\n    this.canvas.classList.add(\"mouse\", \"dragging\");\n    this.addEventListener(\"mousemove\", this.onMouseSelect);\n    this.addEventListener(\"mouseup\", this.onMouseUp);\n  }\n\n  onMouseUp() {\n    this.canvas.classList.remove(\"mouse\", \"dragging\");\n    this.removeEventListener(\"mousemove\", this.onMouseSelect);\n  }\n\n  onMouseSelect(ev) {\n    requestAnimationFrame(() => this.processUserSelect(ev));\n  }\n\n  // Touch events\n\n  onTouchStart(ev) {\n    const touch = ev.changedTouches[0];\n    const cc = this.convertToCanvasCoordinates(touch.clientX, touch.clientY);\n    // return if we're not on the wheel\n    if (!this.isInWheel(cc.x, cc.y)) {\n      return;\n    }\n    if (ev.target === this.marker) {\n      // drag marker\n      ev.preventDefault();\n      this.canvas.classList.add(\"touch\", \"dragging\");\n      this.addEventListener(\"touchmove\", this.onTouchSelect);\n      this.addEventListener(\"touchend\", this.onTouchEnd);\n      return;\n    }\n    // don't fire color selection immediately,\n    // wait for touchend and invalidate when we scroll\n    this.tapBecameScroll = false;\n    this.addEventListener(\"touchend\", this.onTap);\n    this.addEventListener(\n      \"touchmove\",\n      () => {\n        this.tapBecameScroll = true;\n      },\n      { passive: true }\n    );\n  }\n\n  onTap(ev) {\n    if (this.tapBecameScroll) {\n      return;\n    }\n    ev.preventDefault();\n    this.onTouchSelect(ev);\n  }\n\n  onTouchEnd() {\n    this.canvas.classList.remove(\"touch\", \"dragging\");\n    this.removeEventListener(\"touchmove\", this.onTouchSelect);\n  }\n\n  onTouchSelect(ev) {\n    requestAnimationFrame(() => this.processUserSelect(ev.changedTouches[0]));\n  }\n\n  /*\n   * General event/selection handling\n   */\n\n  // Process user input to color\n  processUserSelect(ev) {\n    const canvasXY = this.convertToCanvasCoordinates(ev.clientX, ev.clientY);\n    const hs = this.getColor(canvasXY.x, canvasXY.y);\n    let rgb;\n    if (!this.isInWheel(canvasXY.x, canvasXY.y)) {\n      const [r, g, b] = hs2rgb([hs.h, hs.s]);\n      rgb = { r, g, b };\n    } else {\n      rgb = this.getRgbColor(canvasXY.x, canvasXY.y);\n    }\n    this.onColorSelect(hs, rgb);\n  }\n\n  // apply color to marker position and canvas\n  onColorSelect(hs, rgb) {\n    this.setMarkerOnColor(hs); // marker always follows mouse 'raw' hs value (= mouse position)\n    if (!this.ignoreSegments) {\n      // apply segments if needed\n      hs = this.applySegmentFilter(hs);\n    }\n    // always apply the new color to the interface / canvas\n    this.applyColorToCanvas(hs);\n    // throttling is applied to updating the exposed colors (properties)\n    // and firing of events\n    if (this.colorSelectIsThrottled) {\n      // make sure we apply the last selected color\n      // eventually after throttle limit has passed\n      clearTimeout(this.ensureFinalSelect);\n      this.ensureFinalSelect = setTimeout(() => {\n        this.fireColorSelected(hs, rgb); // do it for the final time\n      }, this.throttle);\n      return;\n    }\n    this.fireColorSelected(hs, rgb); // do it\n    this.colorSelectIsThrottled = true;\n    setTimeout(() => {\n      this.colorSelectIsThrottled = false;\n    }, this.throttle);\n  }\n\n  // set color values and fire colorselected event\n  fireColorSelected(hs, rgb) {\n    this.hsColor = hs;\n    this.fire(\"colorselected\", { hs, rgb });\n  }\n\n  /*\n   * Interface updating\n   */\n\n  // set marker position to the given color\n  setMarkerOnColor(hs) {\n    if (!this.marker || !this.tooltip) {\n      return;\n    }\n    const dist = hs.s * this.radius;\n    const theta = ((hs.h - 180) / 180) * Math.PI;\n    const markerdX = -dist * Math.cos(theta);\n    const markerdY = -dist * Math.sin(theta);\n    const translateString = `translate(${markerdX},${markerdY})`;\n    this.marker.setAttribute(\"transform\", translateString);\n    this.tooltip.setAttribute(\"transform\", translateString);\n  }\n\n  // apply given color to interface elements\n  applyColorToCanvas(hs) {\n    if (!this.interactionLayer) {\n      return;\n    }\n    // we're not really converting hs to hsl here, but we keep it cheap\n    // setting the color on the interactionLayer, the svg elements can inherit\n    this.interactionLayer.style.color = `hsl(${hs.h}, 100%, ${\n      100 - hs.s * 50\n    }%)`;\n  }\n\n  applyHsColor(hs) {\n    // do nothing is we already have the same color\n    if (this.hsColor && this.hsColor.h === hs.h && this.hsColor.s === hs.s) {\n      return;\n    }\n    this.setMarkerOnColor(hs); // marker is always set on 'raw' hs position\n    if (!this.ignoreSegments) {\n      // apply segments if needed\n      hs = this.applySegmentFilter(hs);\n    }\n    this.hsColor = hs;\n    // always apply the new color to the interface / canvas\n    this.applyColorToCanvas(hs);\n  }\n\n  applyRgbColor(rgb) {\n    const [h, s] = rgb2hs(rgb);\n    this.applyHsColor({ h, s });\n  }\n\n  /*\n   * input processing helpers\n   */\n\n  // get angle (degrees)\n  getAngle(dX, dY) {\n    const theta = Math.atan2(-dY, -dX); // radians from the left edge, clockwise = positive\n    const angle = (theta / Math.PI) * 180 + 180; // degrees, clockwise from right\n    return angle;\n  }\n\n  // returns true when coordinates are in the colorwheel\n  isInWheel(x, y) {\n    return this.getDistance(x, y) <= 1;\n  }\n\n  // returns distance from wheel center, 0 = center, 1 = edge, >1 = outside\n  getDistance(dX, dY) {\n    return Math.sqrt(dX * dX + dY * dY) / this.radius;\n  }\n\n  /*\n   * Getting colors\n   */\n\n  getColor(x, y) {\n    const hue = this.getAngle(x, y); // degrees, clockwise from right\n    const relativeDistance = this.getDistance(x, y); // edge of radius = 1\n    const sat = Math.min(relativeDistance, 1); // Distance from center\n    return { h: hue, s: sat };\n  }\n\n  getRgbColor(x, y) {\n    // get current pixel\n    const imageData = this.backgroundLayer\n      .getContext(\"2d\")\n      .getImageData(x + 250, y + 250, 1, 1);\n    const pixel = imageData.data;\n    return { r: pixel[0], g: pixel[1], b: pixel[2] };\n  }\n\n  applySegmentFilter(hs) {\n    // apply hue segment steps\n    if (this.hueSegments) {\n      const angleStep = 360 / this.hueSegments;\n      const halfAngleStep = angleStep / 2;\n      hs.h -= halfAngleStep; // take the 'centered segemnts' into account\n      if (hs.h < 0) {\n        hs.h += 360;\n      } // don't end up below 0\n      const rest = hs.h % angleStep;\n      hs.h -= rest - angleStep;\n    }\n\n    // apply saturation segment steps\n    if (this.saturationSegments) {\n      if (this.saturationSegments === 1) {\n        hs.s = 1;\n      } else {\n        const segmentSize = 1 / this.saturationSegments;\n        const saturationStep = 1 / (this.saturationSegments - 1);\n        const calculatedSat = Math.floor(hs.s / segmentSize) * saturationStep;\n        hs.s = Math.min(calculatedSat, 1);\n      }\n    }\n    return hs;\n  }\n\n  /*\n   * Drawing related stuff\n   */\n\n  setupLayers() {\n    this.canvas = this.$.canvas;\n    this.backgroundLayer = this.$.backgroundLayer;\n    this.interactionLayer = this.$.interactionLayer;\n\n    // coordinate origin position (center of the wheel)\n    this.originX = this.width / 2;\n    this.originY = this.originX;\n\n    // synchronise width/height coordinates\n    this.backgroundLayer.width = this.width;\n    this.backgroundLayer.height = this.height;\n    this.interactionLayer.setAttribute(\n      \"viewBox\",\n      `${-this.originX} ${-this.originY} ${this.width} ${this.height}`\n    );\n  }\n\n  drawColorWheel() {\n    /*\n     *  Setting up all paremeters\n     */\n    let shadowColor;\n    let shadowOffsetX;\n    let shadowOffsetY;\n    let shadowBlur;\n    const context = this.backgroundLayer.getContext(\"2d\");\n    // postioning and sizing\n    const cX = this.originX;\n    const cY = this.originY;\n    const radius = this.radius;\n    const counterClockwise = false;\n    // styling of the wheel\n    const wheelStyle = window.getComputedStyle(this.backgroundLayer, null);\n    const borderWidth = parseInt(\n      wheelStyle.getPropertyValue(\"--wheel-borderwidth\"),\n      10\n    );\n    const borderColor = wheelStyle\n      .getPropertyValue(\"--wheel-bordercolor\")\n      .trim();\n    const wheelShadow = wheelStyle.getPropertyValue(\"--wheel-shadow\").trim();\n    // extract shadow properties from CSS variable\n    // the shadow should be defined as: \"10px 5px 5px 0px COLOR\"\n    if (wheelShadow !== \"none\") {\n      const values = wheelShadow.split(\"px \");\n      shadowColor = values.pop();\n      shadowOffsetX = parseInt(values[0], 10);\n      shadowOffsetY = parseInt(values[1], 10);\n      shadowBlur = parseInt(values[2], 10) || 0;\n    }\n    const borderRadius = radius + borderWidth / 2;\n    const wheelRadius = radius;\n    const shadowRadius = radius + borderWidth;\n\n    /*\n     *  Drawing functions\n     */\n    function drawCircle(hueSegments, saturationSegments) {\n      hueSegments = hueSegments || 360; // reset 0 segments to 360\n      const angleStep = 360 / hueSegments;\n      const halfAngleStep = angleStep / 2; // center segments on color\n      for (let angle = 0; angle <= 360; angle += angleStep) {\n        const startAngle = (angle - halfAngleStep) * (Math.PI / 180);\n        const endAngle = (angle + halfAngleStep + 1) * (Math.PI / 180);\n        context.beginPath();\n        context.moveTo(cX, cY);\n        context.arc(\n          cX,\n          cY,\n          wheelRadius,\n          startAngle,\n          endAngle,\n          counterClockwise\n        );\n        context.closePath();\n        // gradient\n        const gradient = context.createRadialGradient(\n          cX,\n          cY,\n          0,\n          cX,\n          cY,\n          wheelRadius\n        );\n        let lightness = 100;\n        // first gradient stop\n        gradient.addColorStop(0, `hsl(${angle}, 100%, ${lightness}%)`);\n        // segment gradient stops\n        if (saturationSegments > 0) {\n          const ratioStep = 1 / saturationSegments;\n          let ratio = 0;\n          for (let stop = 1; stop < saturationSegments; stop += 1) {\n            const prevLighness = lightness;\n            ratio = stop * ratioStep;\n            lightness = 100 - 50 * ratio;\n            gradient.addColorStop(\n              ratio,\n              `hsl(${angle}, 100%, ${prevLighness}%)`\n            );\n            gradient.addColorStop(ratio, `hsl(${angle}, 100%, ${lightness}%)`);\n          }\n          gradient.addColorStop(ratio, `hsl(${angle}, 100%, 50%)`);\n        }\n        // last gradient stop\n        gradient.addColorStop(1, `hsl(${angle}, 100%, 50%)`);\n\n        context.fillStyle = gradient;\n        context.fill();\n      }\n    }\n\n    function drawShadow() {\n      context.save();\n      context.beginPath();\n      context.arc(cX, cY, shadowRadius, 0, 2 * Math.PI, false);\n      context.shadowColor = shadowColor;\n      context.shadowOffsetX = shadowOffsetX;\n      context.shadowOffsetY = shadowOffsetY;\n      context.shadowBlur = shadowBlur;\n      context.fillStyle = \"white\";\n      context.fill();\n      context.restore();\n    }\n\n    function drawBorder() {\n      context.beginPath();\n      context.arc(cX, cY, borderRadius, 0, 2 * Math.PI, false);\n      context.lineWidth = borderWidth;\n      context.strokeStyle = borderColor;\n      context.stroke();\n    }\n\n    /*\n     *   Call the drawing functions\n     *   draws the shadow, wheel and border\n     */\n    if (wheelStyle.shadow !== \"none\") {\n      drawShadow();\n    }\n    drawCircle(this.hueSegments, this.saturationSegments);\n    if (borderWidth > 0) {\n      drawBorder();\n    }\n  }\n\n  /*\n   *   Draw the (draggable) marker and tooltip\n   *   on the interactionLayer)\n   */\n\n  drawMarker() {\n    const svgElement = this.interactionLayer;\n    const markerradius = this.radius * 0.08;\n    const tooltipradius = this.radius * 0.15;\n    const TooltipOffsetY = -(tooltipradius * 3);\n    const TooltipOffsetX = 0;\n\n    svgElement.marker = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"circle\"\n    );\n    svgElement.marker.setAttribute(\"id\", \"marker\");\n    svgElement.marker.setAttribute(\"r\", markerradius);\n    this.marker = svgElement.marker;\n    svgElement.appendChild(svgElement.marker);\n\n    svgElement.tooltip = document.createElementNS(\n      \"http://www.w3.org/2000/svg\",\n      \"circle\"\n    );\n    svgElement.tooltip.setAttribute(\"id\", \"colorTooltip\");\n    svgElement.tooltip.setAttribute(\"r\", tooltipradius);\n    svgElement.tooltip.setAttribute(\"cx\", TooltipOffsetX);\n    svgElement.tooltip.setAttribute(\"cy\", TooltipOffsetY);\n    this.tooltip = svgElement.tooltip;\n    svgElement.appendChild(svgElement.tooltip);\n  }\n\n  segmentationChange() {\n    if (this.backgroundLayer) {\n      this.drawColorWheel();\n    }\n  }\n}\ncustomElements.define(\"ha-color-picker\", HaColorPicker);\n","import \"@material/mwc-button\";\nimport \"@material/mwc-tab-bar/mwc-tab-bar\";\nimport \"@material/mwc-tab/mwc-tab\";\nimport { mdiPalette } from \"@mdi/js\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  nothing,\n  PropertyValues,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport \"../../../../components/ha-button-toggle-group\";\nimport \"../../../../components/ha-color-picker\";\nimport \"../../../../components/ha-control-slider\";\nimport \"../../../../components/ha-icon-button-prev\";\nimport \"../../../../components/ha-labeled-slider\";\nimport {\n  getLightCurrentModeRgbColor,\n  LightColorMode,\n  LightEntity,\n  lightSupportsColor,\n  lightSupportsColorMode,\n} from \"../../../../data/light\";\nimport { HomeAssistant } from \"../../../../types\";\nimport { LightColorPickerViewParams } from \"./show-view-light-color-picker\";\n\ntype Mode = \"color_temp\" | \"color\";\n\n@customElement(\"ha-more-info-view-light-color-picker\")\nclass MoreInfoViewLightColorPicker extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public params?: LightColorPickerViewParams;\n\n  @state() private _ctSliderValue?: number;\n\n  @state() private _cwSliderValue?: number;\n\n  @state() private _wwSliderValue?: number;\n\n  @state() private _wvSliderValue?: number;\n\n  @state() private _colorBrightnessSliderValue?: number;\n\n  @state() private _brightnessAdjusted?: number;\n\n  @state() private _hueSegments = 24;\n\n  @state() private _saturationSegments = 8;\n\n  @state() private _colorPickerColor?: [number, number, number];\n\n  @state() private _mode?: Mode;\n\n  @state() private _modes: Mode[] = [];\n\n  get stateObj() {\n    return this.params\n      ? (this.hass.states[this.params.entityId] as LightEntity)\n      : undefined;\n  }\n\n  protected render() {\n    if (!this.params || !this.stateObj) {\n      return nothing;\n    }\n\n    const supportsRgbww = lightSupportsColorMode(\n      this.stateObj,\n      LightColorMode.RGBWW\n    );\n\n    const supportsRgbw =\n      !supportsRgbww &&\n      lightSupportsColorMode(this.stateObj, LightColorMode.RGBW);\n\n    return html`\n      ${this._modes.length > 1\n        ? html`\n            <mwc-tab-bar\n              .activeIndex=${this._mode ? this._modes.indexOf(this._mode) : 0}\n              @MDCTabBar:activated=${this._handleTabChanged}\n            >\n              ${this._modes.map(\n                (value) =>\n                  html`<mwc-tab\n                    .label=${this.hass.localize(\n                      `ui.dialogs.more_info_control.light.color_picker.mode.${value}`\n                    )}\n                  ></mwc-tab>`\n              )}\n            </mwc-tab-bar>\n          `\n        : \"\"}\n      <div class=\"content\">\n        ${this._mode === LightColorMode.COLOR_TEMP\n          ? html`\n              <p class=\"color-temp-value\">\n                ${this._ctSliderValue ? `${this._ctSliderValue} K` : nothing}\n              </p>\n              <ha-control-slider\n                vertical\n                class=\"color-temp\"\n                label=${this.hass.localize(\"ui.card.light.color_temperature\")}\n                min=\"1\"\n                max=\"100\"\n                mode=\"cursor\"\n                .value=${this._ctSliderValue}\n                @value-changed=${this._ctSliderChanged}\n                @slider-moved=${this._ctSliderMoved}\n                .min=${this.stateObj.attributes.min_color_temp_kelvin!}\n                .max=${this.stateObj.attributes.max_color_temp_kelvin!}\n              >\n              </ha-control-slider>\n            `\n          : \"\"}\n        ${this._mode === \"color\"\n          ? html`\n              <div class=\"segmentation-container\">\n                <ha-color-picker\n                  class=\"color\"\n                  @colorselected=${this._colorPicked}\n                  .desiredRgbColor=${this._colorPickerColor}\n                  throttle=\"500\"\n                  .hueSegments=${this._hueSegments}\n                  .saturationSegments=${this._saturationSegments}\n                >\n                </ha-color-picker>\n                <ha-icon-button\n                  .path=${mdiPalette}\n                  @click=${this._segmentClick}\n                  class=\"segmentation-button\"\n                ></ha-icon-button>\n              </div>\n\n              ${supportsRgbw || supportsRgbww\n                ? html`<ha-labeled-slider\n                    .caption=${this.hass.localize(\n                      \"ui.card.light.color_brightness\"\n                    )}\n                    icon=\"hass:brightness-7\"\n                    max=\"100\"\n                    .value=${this._colorBrightnessSliderValue}\n                    @change=${this._colorBrightnessSliderChanged}\n                    pin\n                  ></ha-labeled-slider>`\n                : \"\"}\n              ${supportsRgbw\n                ? html`\n                    <ha-labeled-slider\n                      .caption=${this.hass.localize(\n                        \"ui.card.light.white_value\"\n                      )}\n                      icon=\"hass:file-word-box\"\n                      max=\"100\"\n                      .name=${\"wv\"}\n                      .value=${this._wvSliderValue}\n                      @change=${this._wvSliderChanged}\n                      pin\n                    ></ha-labeled-slider>\n                  `\n                : \"\"}\n              ${supportsRgbww\n                ? html`\n                    <ha-labeled-slider\n                      .caption=${this.hass.localize(\n                        \"ui.card.light.cold_white_value\"\n                      )}\n                      icon=\"hass:file-word-box-outline\"\n                      max=\"100\"\n                      .name=${\"cw\"}\n                      .value=${this._cwSliderValue}\n                      @change=${this._wvSliderChanged}\n                      pin\n                    ></ha-labeled-slider>\n                    <ha-labeled-slider\n                      .caption=${this.hass.localize(\n                        \"ui.card.light.warm_white_value\"\n                      )}\n                      icon=\"hass:file-word-box\"\n                      max=\"100\"\n                      .name=${\"ww\"}\n                      .value=${this._wwSliderValue}\n                      @change=${this._wvSliderChanged}\n                      pin\n                    ></ha-labeled-slider>\n                  `\n                : \"\"}\n            `\n          : \"\"}\n      </div>\n    `;\n  }\n\n  public _updateSliderValues() {\n    const stateObj = this.stateObj;\n\n    if (stateObj?.state === \"on\") {\n      this._brightnessAdjusted = undefined;\n      if (\n        stateObj.attributes.color_mode === LightColorMode.RGB &&\n        stateObj.attributes.rgb_color &&\n        !lightSupportsColorMode(stateObj, LightColorMode.RGBWW) &&\n        !lightSupportsColorMode(stateObj, LightColorMode.RGBW)\n      ) {\n        const maxVal = Math.max(...stateObj.attributes.rgb_color);\n\n        if (maxVal < 255) {\n          this._brightnessAdjusted = maxVal;\n        }\n      }\n      this._ctSliderValue =\n        stateObj.attributes.color_mode === LightColorMode.COLOR_TEMP\n          ? stateObj.attributes.color_temp_kelvin\n          : undefined;\n\n      this._wvSliderValue =\n        stateObj.attributes.color_mode === LightColorMode.RGBW &&\n        stateObj.attributes.rgbw_color\n          ? Math.round((stateObj.attributes.rgbw_color[3] * 100) / 255)\n          : undefined;\n      this._cwSliderValue =\n        stateObj.attributes.color_mode === LightColorMode.RGBWW &&\n        stateObj.attributes.rgbww_color\n          ? Math.round((stateObj.attributes.rgbww_color[3] * 100) / 255)\n          : undefined;\n      this._wwSliderValue =\n        stateObj.attributes.color_mode === LightColorMode.RGBWW &&\n        stateObj.attributes.rgbww_color\n          ? Math.round((stateObj.attributes.rgbww_color[4] * 100) / 255)\n          : undefined;\n\n      const currentRgbColor = getLightCurrentModeRgbColor(stateObj);\n\n      this._colorBrightnessSliderValue = currentRgbColor\n        ? Math.round((Math.max(...currentRgbColor.slice(0, 3)) * 100) / 255)\n        : undefined;\n\n      this._colorPickerColor = currentRgbColor?.slice(0, 3) as [\n        number,\n        number,\n        number\n      ];\n    } else {\n      this._colorPickerColor = [0, 0, 0];\n      this._ctSliderValue = undefined;\n      this._wvSliderValue = undefined;\n      this._cwSliderValue = undefined;\n      this._wwSliderValue = undefined;\n    }\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    super.willUpdate(changedProps);\n\n    if (!changedProps.has(\"params\") && !changedProps.has(\"hass\")) {\n      return;\n    }\n\n    if (changedProps.has(\"params\")) {\n      const supportsTemp = lightSupportsColorMode(\n        this.stateObj!,\n        LightColorMode.COLOR_TEMP\n      );\n\n      const supportsColor = lightSupportsColor(this.stateObj!);\n\n      const modes: Mode[] = [];\n      if (supportsColor) {\n        modes.push(\"color\");\n      }\n      if (supportsTemp) {\n        modes.push(\"color_temp\");\n      }\n\n      this._modes = modes;\n      this._mode = this.stateObj!.attributes.color_mode\n        ? this.stateObj!.attributes.color_mode === LightColorMode.COLOR_TEMP\n          ? LightColorMode.COLOR_TEMP\n          : \"color\"\n        : this._modes[0];\n    }\n\n    this._updateSliderValues();\n  }\n\n  private _handleTabChanged(ev: CustomEvent): void {\n    const newMode = this._modes[ev.detail.index];\n    if (newMode === this._mode) {\n      return;\n    }\n    this._mode = newMode;\n  }\n\n  private _ctSliderMoved(ev: CustomEvent) {\n    const ct = ev.detail.value;\n\n    if (isNaN(ct)) {\n      return;\n    }\n\n    this._ctSliderValue = ct;\n  }\n\n  private _ctSliderChanged(ev: CustomEvent) {\n    const ct = ev.detail.value;\n\n    if (isNaN(ct)) {\n      return;\n    }\n\n    this._ctSliderValue = ct;\n\n    this.hass.callService(\"light\", \"turn_on\", {\n      entity_id: this.stateObj!.entity_id,\n      color_temp_kelvin: ct,\n    });\n  }\n\n  private _wvSliderChanged(ev: CustomEvent) {\n    const target = ev.target as any;\n    let wv = Number(target.value);\n    const name = target.name;\n\n    if (isNaN(wv)) {\n      return;\n    }\n\n    if (name === \"wv\") {\n      this._wvSliderValue = wv;\n    } else if (name === \"cw\") {\n      this._cwSliderValue = wv;\n    } else if (name === \"ww\") {\n      this._wwSliderValue = wv;\n    }\n\n    wv = Math.min(255, Math.round((wv * 255) / 100));\n\n    const rgb = getLightCurrentModeRgbColor(this.stateObj!);\n\n    if (name === \"wv\") {\n      const rgbw_color = rgb || [0, 0, 0, 0];\n      rgbw_color[3] = wv;\n      this.hass.callService(\"light\", \"turn_on\", {\n        entity_id: this.stateObj!.entity_id,\n        rgbw_color,\n      });\n      return;\n    }\n\n    const rgbww_color = rgb || [0, 0, 0, 0, 0];\n    while (rgbww_color.length < 5) {\n      rgbww_color.push(0);\n    }\n    rgbww_color[name === \"cw\" ? 3 : 4] = wv;\n    this.hass.callService(\"light\", \"turn_on\", {\n      entity_id: this.stateObj!.entity_id,\n      rgbww_color,\n    });\n  }\n\n  private _colorBrightnessSliderChanged(ev: CustomEvent) {\n    const target = ev.target as any;\n    let value = Number(target.value);\n\n    if (isNaN(value)) {\n      return;\n    }\n\n    const oldValue = this._colorBrightnessSliderValue;\n    this._colorBrightnessSliderValue = value;\n\n    value = (value * 255) / 100;\n\n    const rgb = (getLightCurrentModeRgbColor(this.stateObj!)?.slice(0, 3) || [\n      255, 255, 255,\n    ]) as [number, number, number];\n\n    this._setRgbWColor(\n      this._adjustColorBrightness(\n        // first normalize the value\n        oldValue\n          ? this._adjustColorBrightness(rgb, (oldValue * 255) / 100, true)\n          : rgb,\n        value\n      )\n    );\n  }\n\n  private _segmentClick() {\n    if (this._hueSegments === 24 && this._saturationSegments === 8) {\n      this._hueSegments = 0;\n      this._saturationSegments = 0;\n    } else {\n      this._hueSegments = 24;\n      this._saturationSegments = 8;\n    }\n  }\n\n  private _adjustColorBrightness(\n    rgbColor: [number, number, number],\n    value?: number,\n    invert = false\n  ) {\n    if (value !== undefined && value !== 255) {\n      let ratio = value / 255;\n      if (invert) {\n        ratio = 1 / ratio;\n      }\n      rgbColor[0] = Math.min(255, Math.round(rgbColor[0] * ratio));\n      rgbColor[1] = Math.min(255, Math.round(rgbColor[1] * ratio));\n      rgbColor[2] = Math.min(255, Math.round(rgbColor[2] * ratio));\n    }\n    return rgbColor;\n  }\n\n  private _setRgbWColor(rgbColor: [number, number, number]) {\n    if (lightSupportsColorMode(this.stateObj!, LightColorMode.RGBWW)) {\n      const rgbww_color: [number, number, number, number, number] = this\n        .stateObj!.attributes.rgbww_color\n        ? [...this.stateObj!.attributes.rgbww_color]\n        : [0, 0, 0, 0, 0];\n      this.hass.callService(\"light\", \"turn_on\", {\n        entity_id: this.stateObj!.entity_id,\n        rgbww_color: rgbColor.concat(rgbww_color.slice(3)),\n      });\n    } else if (lightSupportsColorMode(this.stateObj!, LightColorMode.RGBW)) {\n      const rgbw_color: [number, number, number, number] = this.stateObj!\n        .attributes.rgbw_color\n        ? [...this.stateObj!.attributes.rgbw_color]\n        : [0, 0, 0, 0];\n      this.hass.callService(\"light\", \"turn_on\", {\n        entity_id: this.stateObj!.entity_id,\n        rgbw_color: rgbColor.concat(rgbw_color.slice(3)),\n      });\n    }\n  }\n\n  /**\n   * Called when a new color has been picked.\n   * should be throttled with the 'throttle=' attribute of the color picker\n   */\n  private _colorPicked(\n    ev: CustomEvent<{\n      hs: { h: number; s: number };\n      rgb: { r: number; g: number; b: number };\n    }>\n  ) {\n    this._colorPickerColor = [\n      ev.detail.rgb.r,\n      ev.detail.rgb.g,\n      ev.detail.rgb.b,\n    ];\n\n    if (\n      lightSupportsColorMode(this.stateObj!, LightColorMode.RGBWW) ||\n      lightSupportsColorMode(this.stateObj!, LightColorMode.RGBW)\n    ) {\n      this._setRgbWColor(\n        this._colorBrightnessSliderValue\n          ? this._adjustColorBrightness(\n              [ev.detail.rgb.r, ev.detail.rgb.g, ev.detail.rgb.b],\n              (this._colorBrightnessSliderValue * 255) / 100\n            )\n          : [ev.detail.rgb.r, ev.detail.rgb.g, ev.detail.rgb.b]\n      );\n    } else if (lightSupportsColorMode(this.stateObj!, LightColorMode.RGB)) {\n      const rgb_color: [number, number, number] = [\n        ev.detail.rgb.r,\n        ev.detail.rgb.g,\n        ev.detail.rgb.b,\n      ];\n      if (this._brightnessAdjusted) {\n        const brightnessAdjust = (this._brightnessAdjusted / 255) * 100;\n        const brightnessPercentage = Math.round(\n          ((this.stateObj!.attributes.brightness || 0) * brightnessAdjust) / 255\n        );\n        this.hass.callService(\"light\", \"turn_on\", {\n          entity_id: this.stateObj!.entity_id,\n          brightness_pct: brightnessPercentage,\n          rgb_color: this._adjustColorBrightness(\n            rgb_color,\n            this._brightnessAdjusted,\n            true\n          ),\n        });\n      } else {\n        this.hass.callService(\"light\", \"turn_on\", {\n          entity_id: this.stateObj!.entity_id,\n          rgb_color,\n        });\n      }\n    } else {\n      this.hass.callService(\"light\", \"turn_on\", {\n        entity_id: this.stateObj!.entity_id,\n        hs_color: [ev.detail.hs.h, ev.detail.hs.s * 100],\n      });\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      css`\n        :host {\n          display: flex;\n          flex-direction: column;\n        }\n        .content {\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          justify-content: center;\n          padding: 24px;\n          flex: 1;\n        }\n\n        .segmentation-container {\n          position: relative;\n          max-height: 500px;\n          display: flex;\n          justify-content: center;\n        }\n\n        .segmentation-button {\n          position: absolute;\n          top: 5%;\n          left: 0;\n          color: var(--secondary-text-color);\n        }\n\n        ha-color-picker {\n          --ha-color-picker-wheel-borderwidth: 5;\n          --ha-color-picker-wheel-bordercolor: white;\n          --ha-color-picker-wheel-shadow: none;\n          --ha-color-picker-marker-borderwidth: 2;\n          --ha-color-picker-marker-bordercolor: white;\n        }\n\n        ha-control-slider {\n          height: 45vh;\n          max-height: 320px;\n          min-height: 200px;\n          margin: 20px 0;\n          --control-slider-thickness: 100px;\n          --control-slider-border-radius: 24px;\n        }\n\n        ha-labeled-slider {\n          width: 100%;\n        }\n\n        .color-temp-value {\n          font-style: normal;\n          font-weight: 500;\n          font-size: 16px;\n          height: 24px;\n          line-height: 24px;\n          letter-spacing: 0.1px;\n          margin: 0;\n        }\n\n        .color-temp {\n          --control-slider-background: -webkit-linear-gradient(\n            top,\n            rgb(166, 209, 255) 0%,\n            white 50%,\n            rgb(255, 160, 0) 100%\n          );\n          --control-slider-background-opacity: 1;\n          margin-bottom: 44px;\n        }\n\n        hr {\n          border-color: var(--divider-color);\n          border-bottom: none;\n          margin: 16px 0;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-more-info-view-light-color-picker\": MoreInfoViewLightColorPicker;\n  }\n}\n"],"names":[],"sourceRoot":""}