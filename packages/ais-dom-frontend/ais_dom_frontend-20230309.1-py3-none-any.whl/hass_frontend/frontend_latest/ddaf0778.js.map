{"version":3,"file":"ddaf0778.js","mappings":";;;;;;;;;AAoGA;;;ACmnBA","sources":["webpack://home-assistant-frontend/./src/layouts/ha-app-layout.js","webpack://home-assistant-frontend/./src/panels/media-browser/ha-bar-media-player.ts"],"sourcesContent":["/* eslint-plugin-disable lit */\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/*\nThis code is copied from app-header-layout.\n'fullbleed' support is removed as Home Assisstant doesn't use it.\ntransform: translate(0) is added.\n*/\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\nimport \"@polymer/app-layout/app-header-layout/app-header-layout\";\nimport { html } from \"@polymer/polymer/lib/utils/html-tag\";\nimport \"@polymer/polymer/polymer-element\";\n\nclass HaAppLayout extends customElements.get(\"app-header-layout\") {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: block;\n          /**\n         * Force app-header-layout to have its own stacking context so that its parent can\n         * control the stacking of it relative to other elements (e.g. app-drawer-layout).\n         * This could be done using \\`isolation: isolate\\`, but that's not well supported\n         * across browsers.\n         */\n          position: relative;\n          z-index: 0;\n        }\n\n        #wrapper ::slotted([slot=\"header\"]) {\n          @apply --layout-fixed-top;\n          z-index: 1;\n        }\n\n        #wrapper.initializing ::slotted([slot=\"header\"]) {\n          position: relative;\n        }\n\n        :host([has-scrolling-region]) {\n          height: 100%;\n        }\n\n        :host([has-scrolling-region]) #wrapper ::slotted([slot=\"header\"]) {\n          position: absolute;\n        }\n\n        :host([has-scrolling-region])\n          #wrapper.initializing\n          ::slotted([slot=\"header\"]) {\n          position: relative;\n        }\n\n        :host([has-scrolling-region]) #wrapper #contentContainer {\n          @apply --layout-fit;\n          overflow-y: auto;\n          -webkit-overflow-scrolling: touch;\n        }\n\n        :host([has-scrolling-region]) #wrapper.initializing #contentContainer {\n          position: relative;\n        }\n\n        #contentContainer {\n          /* Create a stacking context here so that all children appear below the header. */\n          position: relative;\n          z-index: 0;\n          /* Using 'transform' will cause 'position: fixed' elements to behave like\n           'position: absolute' relative to this element. */\n          transform: translate(0);\n          margin-left: env(safe-area-inset-left);\n          margin-right: env(safe-area-inset-right);\n          padding-top: env(safe-area-inset-top);\n          padding-bottom: env(safe-area-inset-bottom);\n        }\n\n        @media print {\n          :host([has-scrolling-region]) #wrapper #contentContainer {\n            overflow-y: visible;\n          }\n        }\n      </style>\n\n      <div id=\"wrapper\" class=\"initializing\">\n        <slot id=\"headerSlot\" name=\"header\"></slot>\n\n        <div id=\"contentContainer\"><slot></slot></div>\n        <slot id=\"fab\" name=\"fab\"></slot>\n      </div>\n    `;\n  }\n}\ncustomElements.define(\"ha-app-layout\", HaAppLayout);\n","import \"@material/mwc-button/mwc-button\";\nimport \"@material/mwc-linear-progress/mwc-linear-progress\";\nimport type { LinearProgress } from \"@material/mwc-linear-progress/mwc-linear-progress\";\nimport \"@material/mwc-list/mwc-list-item\";\nimport {\n  mdiChevronDown,\n  mdiMonitor,\n  mdiPause,\n  mdiPlay,\n  mdiPlayPause,\n  mdiStop,\n  mdiVolumeHigh,\n} from \"@mdi/js\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  nothing,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { until } from \"lit/directives/until\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport { domainIcon } from \"../../common/entity/domain_icon\";\nimport { supportsFeature } from \"../../common/entity/supports-feature\";\nimport \"../../components/ha-button\";\nimport \"../../components/ha-button-menu\";\nimport \"../../components/ha-circular-progress\";\nimport \"../../components/ha-icon-button\";\nimport { UNAVAILABLE } from \"../../data/entity\";\nimport { subscribeEntityRegistry } from \"../../data/entity_registry\";\nimport {\n  BROWSER_PLAYER,\n  cleanupMediaTitle,\n  computeMediaControls,\n  computeMediaDescription,\n  ControlButton,\n  formatMediaTime,\n  getCurrentProgress,\n  handleMediaControlClick,\n  MediaPlayerEntity,\n  MediaPlayerEntityFeature,\n  MediaPlayerItem,\n  setMediaPlayerVolume,\n} from \"../../data/media-player\";\nimport { ResolvedMediaSource } from \"../../data/media_source\";\nimport { showAlertDialog } from \"../../dialogs/generic/show-dialog-box\";\nimport { SubscribeMixin } from \"../../mixins/subscribe-mixin\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"../lovelace/components/hui-marquee\";\nimport {\n  BrowserMediaPlayer,\n  ERR_UNSUPPORTED_MEDIA,\n} from \"./browser-media-player\";\n\ndeclare global {\n  interface HASSDomEvents {\n    \"player-picked\": { entityId: string };\n  }\n}\n\n@customElement(\"ha-bar-media-player\")\nexport class BarMediaPlayer extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public entityId!: string;\n\n  @property({ type: Boolean, reflect: true })\n  public narrow!: boolean;\n\n  @query(\"mwc-linear-progress\") private _progressBar?: LinearProgress;\n\n  @query(\"#CurrentProgress\") private _currentProgress?: HTMLElement;\n\n  @state() private _marqueeActive = false;\n\n  @state() private _newMediaExpected = false;\n\n  @state() private _browserPlayer?: BrowserMediaPlayer;\n\n  @state()\n  private _hiddenEntities = new Set<string>();\n\n  private _progressInterval?: number;\n\n  private _browserPlayerVolume = 0.8;\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n\n    const stateObj = this._stateObj;\n\n    if (!stateObj) {\n      return;\n    }\n\n    if (\n      !this._progressInterval &&\n      this._showProgressBar &&\n      stateObj.state === \"playing\"\n    ) {\n      this._progressInterval = window.setInterval(\n        () => this._updateProgressBar(),\n        1000\n      );\n    }\n  }\n\n  public disconnectedCallback(): void {\n    if (this._progressInterval) {\n      clearInterval(this._progressInterval);\n      this._progressInterval = undefined;\n    }\n    this._tearDownBrowserPlayer();\n  }\n\n  public showResolvingNewMediaPicked() {\n    this._tearDownBrowserPlayer();\n    this._newMediaExpected = true;\n  }\n\n  public hideResolvingNewMediaPicked() {\n    this._newMediaExpected = false;\n  }\n\n  public playItem(item: MediaPlayerItem, resolved: ResolvedMediaSource) {\n    if (this.entityId !== BROWSER_PLAYER) {\n      throw Error(\"Only browser supported\");\n    }\n    this._tearDownBrowserPlayer();\n    try {\n      this._browserPlayer = new BrowserMediaPlayer(\n        this.hass,\n        item,\n        resolved,\n        this._browserPlayerVolume,\n        () => this.requestUpdate(\"_browserPlayer\")\n      );\n    } catch (err: any) {\n      if (err.message === ERR_UNSUPPORTED_MEDIA) {\n        showAlertDialog(this, {\n          text: this.hass.localize(\n            \"ui.components.media-browser.media_not_supported\"\n          ),\n        });\n      } else {\n        throw err;\n      }\n    }\n    this._newMediaExpected = false;\n  }\n\n  protected render() {\n    if (this._newMediaExpected) {\n      return html`\n        <div class=\"controls-progress\">\n          ${until(\n            // Only show spinner after 500ms\n            new Promise((resolve) => {\n              setTimeout(resolve, 500);\n            }).then(\n              () => html`<ha-circular-progress active></ha-circular-progress>`\n            )\n          )}\n        </div>\n      `;\n    }\n\n    const isBrowser = this.entityId === BROWSER_PLAYER;\n    const stateObj = this._stateObj;\n\n    if (!stateObj) {\n      return this._renderChoosePlayer(stateObj);\n    }\n\n    const controls: ControlButton[] | undefined = !this.narrow\n      ? computeMediaControls(stateObj, true)\n      : (stateObj.state === \"playing\" &&\n          (supportsFeature(stateObj, MediaPlayerEntityFeature.PAUSE) ||\n            supportsFeature(stateObj, MediaPlayerEntityFeature.STOP))) ||\n        ((stateObj.state === \"paused\" || stateObj.state === \"idle\") &&\n          supportsFeature(stateObj, MediaPlayerEntityFeature.PLAY)) ||\n        (stateObj.state === \"on\" &&\n          (supportsFeature(stateObj, MediaPlayerEntityFeature.PLAY) ||\n            supportsFeature(stateObj, MediaPlayerEntityFeature.PAUSE)))\n      ? [\n          {\n            icon:\n              stateObj.state === \"on\"\n                ? mdiPlayPause\n                : stateObj.state !== \"playing\"\n                ? mdiPlay\n                : supportsFeature(stateObj, MediaPlayerEntityFeature.PAUSE)\n                ? mdiPause\n                : mdiStop,\n            action:\n              stateObj.state !== \"playing\"\n                ? \"media_play\"\n                : supportsFeature(stateObj, MediaPlayerEntityFeature.PAUSE)\n                ? \"media_pause\"\n                : \"media_stop\",\n          },\n        ]\n      : undefined;\n    const mediaDescription = computeMediaDescription(stateObj);\n    const mediaDuration = formatMediaTime(stateObj.attributes.media_duration);\n    const mediaTitleClean = cleanupMediaTitle(\n      stateObj.attributes.media_title || stateObj.attributes.media_content_id\n    );\n    const mediaArt =\n      stateObj.attributes.entity_picture_local ||\n      stateObj.attributes.entity_picture;\n\n    return html`\n      <div\n        class=${classMap({\n          info: true,\n          pointer: !isBrowser,\n          app: this._browserPlayer?.item.media_class === \"app\",\n        })}\n        @click=${this._openMoreInfo}\n      >\n        ${mediaArt\n          ? html`<img alt=\"\" src=${this.hass.hassUrl(mediaArt)} />`\n          : \"\"}\n        <div class=\"media-info\">\n          <hui-marquee\n            .text=${mediaTitleClean ||\n            mediaDescription ||\n            (stateObj.state !== \"playing\" && stateObj.state !== \"on\"\n              ? this.hass.localize(`ui.card.media_player.nothing_playing`)\n              : \"\")}\n            .active=${this._marqueeActive}\n            @mouseover=${this._marqueeMouseOver}\n            @mouseleave=${this._marqueeMouseLeave}\n          ></hui-marquee>\n          <span class=\"secondary\">\n            ${mediaTitleClean ? mediaDescription : \"\"}\n          </span>\n        </div>\n      </div>\n      <div class=\"controls-progress\">\n        ${stateObj.state === \"buffering\"\n          ? html` <ha-circular-progress active></ha-circular-progress> `\n          : html`\n              <div class=\"controls\">\n                ${controls === undefined\n                  ? \"\"\n                  : controls.map(\n                      (control) => html`\n                        <ha-icon-button\n                          .label=${this.hass.localize(\n                            `ui.card.media_player.${control.action}`\n                          )}\n                          .path=${control.icon}\n                          action=${control.action}\n                          @click=${this._handleControlClick}\n                        >\n                        </ha-icon-button>\n                      `\n                    )}\n              </div>\n              ${stateObj.attributes.media_duration === Infinity\n                ? nothing\n                : this.narrow\n                ? html`<mwc-linear-progress></mwc-linear-progress>`\n                : html`\n                    <div class=\"progress\">\n                      <div id=\"CurrentProgress\"></div>\n                      <mwc-linear-progress wide></mwc-linear-progress>\n                      <div>${mediaDuration}</div>\n                    </div>\n                  `}\n            `}\n      </div>\n      ${this._renderChoosePlayer(stateObj)}\n    `;\n  }\n\n  private _renderChoosePlayer(stateObj: MediaPlayerEntity | undefined) {\n    const isBrowser = this.entityId === BROWSER_PLAYER;\n    return html`\n    <div class=\"choose-player ${isBrowser ? \"browser\" : \"\"}\">\n      ${\n        !this.narrow &&\n        stateObj &&\n        supportsFeature(stateObj, MediaPlayerEntityFeature.VOLUME_SET)\n          ? html`\n              <ha-button-menu corner=\"BOTTOM_START\" y=\"0\" x=\"76\">\n                <ha-icon-button\n                  slot=\"trigger\"\n                  .path=${mdiVolumeHigh}\n                ></ha-icon-button>\n                <ha-slider\n                  min=\"0\"\n                  max=\"100\"\n                  step=\"1\"\n                  .value=${stateObj.attributes.volume_level! * 100}\n                  @change=${this._handleVolumeChange}\n                >\n                </ha-slider>\n              </ha-button-menu>\n            `\n          : \"\"\n      }\n\n          <ha-button-menu corner=\"BOTTOM_START\">\n            ${\n              this.narrow\n                ? html`\n                    <ha-icon-button\n                      slot=\"trigger\"\n                      .path=${isBrowser\n                        ? mdiMonitor\n                        : domainIcon(computeDomain(this.entityId), stateObj)}\n                    ></ha-icon-button>\n                  `\n                : html`\n                    <ha-button\n                      slot=\"trigger\"\n                      .label=${this.narrow\n                        ? \"\"\n                        : `${\n                            stateObj\n                              ? computeStateName(stateObj)\n                              : this.entityId\n                          }\n                `}\n                    >\n                      <ha-svg-icon\n                        slot=\"icon\"\n                        .path=${isBrowser\n                          ? mdiMonitor\n                          : domainIcon(computeDomain(this.entityId), stateObj)}\n                      ></ha-svg-icon>\n                      <ha-svg-icon\n                        slot=\"trailingIcon\"\n                        .path=${mdiChevronDown}\n                      ></ha-svg-icon>\n                    </ha-button>\n                  `\n            }\n            <mwc-list-item\n              .player=${BROWSER_PLAYER}\n              ?selected=${isBrowser}\n              @click=${this._selectPlayer}\n            >\n              ${this.hass.localize(\"ui.components.media-browser.web-browser\")}\n            </mwc-list-item>\n            ${this._mediaPlayerEntities.map(\n              (source) => html`\n                <mwc-list-item\n                  ?selected=${source.entity_id === this.entityId}\n                  .disabled=${source.state === UNAVAILABLE}\n                  .player=${source.entity_id}\n                  @click=${this._selectPlayer}\n                >\n                  ${computeStateName(source)}\n                </mwc-list-item>\n              `\n            )}\n          </ha-button-menu>\n        </div>\n      </div>\n\n    `;\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    super.willUpdate(changedProps);\n    if (changedProps.has(\"entityId\")) {\n      this._tearDownBrowserPlayer();\n    }\n    if (!changedProps.has(\"hass\") || this.entityId === BROWSER_PLAYER) {\n      return;\n    }\n    // Reset new media expected if media player state changes\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n    if (\n      !oldHass ||\n      oldHass.states[this.entityId] !== this.hass.states[this.entityId]\n    ) {\n      this._newMediaExpected = false;\n    }\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    super.updated(changedProps);\n\n    if (this.entityId === BROWSER_PLAYER) {\n      if (!changedProps.has(\"_browserPlayer\")) {\n        return;\n      }\n    } else {\n      const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n      if (oldHass && oldHass.states[this.entityId] === this._stateObj) {\n        return;\n      }\n    }\n\n    const stateObj = this._stateObj;\n\n    this._updateProgressBar();\n\n    if (\n      !this._progressInterval &&\n      this._showProgressBar &&\n      stateObj?.state === \"playing\"\n    ) {\n      this._progressInterval = window.setInterval(\n        () => this._updateProgressBar(),\n        1000\n      );\n    } else if (\n      this._progressInterval &&\n      (!this._showProgressBar || stateObj?.state !== \"playing\")\n    ) {\n      clearInterval(this._progressInterval);\n      this._progressInterval = undefined;\n    }\n  }\n\n  private get _stateObj(): MediaPlayerEntity | undefined {\n    if (this.entityId === BROWSER_PLAYER) {\n      return this._browserPlayer\n        ? this._browserPlayer.toStateObj()\n        : BrowserMediaPlayer.idleStateObj();\n    }\n    return this.hass!.states[this.entityId] as MediaPlayerEntity | undefined;\n  }\n\n  private _tearDownBrowserPlayer() {\n    if (this._browserPlayer) {\n      this._browserPlayer.remove();\n      this._browserPlayer = undefined;\n    }\n  }\n\n  private _openMoreInfo() {\n    if (this._browserPlayer) {\n      return;\n    }\n    fireEvent(this, \"hass-more-info\", { entityId: this.entityId });\n  }\n\n  private get _showProgressBar() {\n    if (!this.hass) {\n      return false;\n    }\n\n    const stateObj = this._stateObj;\n\n    return (\n      stateObj &&\n      (stateObj.state === \"playing\" || stateObj.state === \"paused\") &&\n      \"media_duration\" in stateObj.attributes &&\n      \"media_position\" in stateObj.attributes\n    );\n  }\n\n  private get _mediaPlayerEntities() {\n    return Object.values(this.hass!.states).filter(\n      (entity) =>\n        computeStateDomain(entity) === \"media_player\" &&\n        supportsFeature(entity, MediaPlayerEntityFeature.BROWSE_MEDIA) &&\n        !this._hiddenEntities.has(entity.entity_id)\n    );\n  }\n\n  private _updateProgressBar(): void {\n    const stateObj = this._stateObj;\n\n    if (!this._progressBar || !this._currentProgress || !stateObj) {\n      return;\n    }\n\n    if (!stateObj.attributes.media_duration) {\n      this._progressBar.progress = 0;\n      this._currentProgress.innerHTML = \"\";\n      return;\n    }\n\n    const currentProgress = getCurrentProgress(stateObj);\n    this._progressBar.progress =\n      currentProgress / stateObj.attributes.media_duration;\n\n    if (this._currentProgress) {\n      this._currentProgress.innerHTML = formatMediaTime(currentProgress);\n    }\n  }\n\n  protected override hassSubscribe(): (\n    | UnsubscribeFunc\n    | Promise<UnsubscribeFunc>\n  )[] {\n    return [\n      subscribeEntityRegistry(this.hass.connection, (entries) => {\n        const hiddenEntities = new Set<string>();\n\n        for (const entry of entries) {\n          if (\n            entry.hidden_by &&\n            computeDomain(entry.entity_id) === \"media_player\"\n          ) {\n            hiddenEntities.add(entry.entity_id);\n          }\n        }\n\n        this._hiddenEntities = hiddenEntities;\n      }),\n    ];\n  }\n\n  private _handleControlClick(e: MouseEvent): void {\n    const action = (e.currentTarget! as HTMLElement).getAttribute(\"action\")!;\n\n    if (!this._browserPlayer) {\n      handleMediaControlClick(\n        this.hass!,\n        this._stateObj!,\n        (e.currentTarget as HTMLElement).getAttribute(\"action\")!\n      );\n      return;\n    }\n    if (action === \"media_pause\") {\n      this._browserPlayer.pause();\n    } else if (action === \"media_play\") {\n      this._browserPlayer.play();\n    }\n  }\n\n  private _marqueeMouseOver(): void {\n    if (!this._marqueeActive) {\n      this._marqueeActive = true;\n    }\n  }\n\n  private _marqueeMouseLeave(): void {\n    if (this._marqueeActive) {\n      this._marqueeActive = false;\n    }\n  }\n\n  private _selectPlayer(ev: CustomEvent): void {\n    const entityId = (ev.currentTarget as any).player;\n    fireEvent(this, \"player-picked\", { entityId });\n  }\n\n  private async _handleVolumeChange(ev) {\n    ev.stopPropagation();\n    const value = Number(ev.target.value) / 100;\n    if (this._browserPlayer) {\n      this._browserPlayerVolume = value;\n      this._browserPlayer.setVolume(value);\n    } else {\n      await setMediaPlayerVolume(this.hass, this.entityId, value);\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: flex;\n        min-height: 100px;\n        background: var(\n          --ha-card-background,\n          var(--card-background-color, white)\n        );\n        border-top: 1px solid var(--divider-color);\n        padding-bottom: env(safe-area-inset-bottom);\n      }\n\n      mwc-linear-progress {\n        width: 100%;\n        padding: 0 4px;\n        --mdc-theme-primary: var(--secondary-text-color);\n      }\n\n      mwc-button[slot=\"trigger\"] {\n        --mdc-theme-primary: var(--primary-text-color);\n        --mdc-icon-size: 36px;\n      }\n\n      .info {\n        flex: 1;\n        display: flex;\n        align-items: center;\n        width: 100%;\n        margin-right: 16px;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        overflow: hidden;\n      }\n\n      .pointer {\n        cursor: pointer;\n      }\n\n      .secondary,\n      .progress {\n        color: var(--secondary-text-color);\n      }\n\n      .choose-player {\n        flex: 1;\n        display: flex;\n        justify-content: flex-end;\n        align-items: center;\n        padding: 16px;\n      }\n\n      .controls {\n        height: 48px;\n        padding-bottom: 4px;\n      }\n\n      .controls-progress {\n        flex: 2;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-direction: column;\n        direction: ltr;\n      }\n\n      .progress {\n        display: flex;\n        width: 100%;\n        align-items: center;\n      }\n\n      mwc-linear-progress[wide] {\n        margin: 0 4px;\n      }\n\n      .media-info {\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        overflow: hidden;\n        padding-left: 16px;\n        width: 100%;\n      }\n\n      hui-marquee {\n        font-size: 1.2em;\n        margin: 0px 0 4px;\n      }\n\n      img {\n        max-height: 100px;\n        max-width: 100px;\n      }\n\n      .app img {\n        max-height: 68px;\n        margin: 16px 0 16px 16px;\n      }\n\n      ha-button-menu mwc-button {\n        line-height: 1;\n      }\n\n      :host([narrow]) {\n        min-height: 56px;\n        max-height: 56px;\n      }\n\n      :host([narrow]) .controls-progress {\n        flex: unset;\n        min-width: 48px;\n      }\n\n      :host([narrow]) .media-info {\n        padding-left: 8px;\n      }\n\n      :host([narrow]) .controls {\n        display: flex;\n        padding-bottom: 0;\n        --mdc-icon-size: 30px;\n      }\n\n      :host([narrow]) .choose-player {\n        padding-left: 0;\n        padding-right: 8px;\n        min-width: 48px;\n        flex: unset;\n        justify-content: center;\n      }\n\n      :host([narrow]) .choose-player.browser {\n        justify-content: flex-end;\n      }\n\n      :host([narrow]) img {\n        max-height: 56px;\n        max-width: 56px;\n      }\n\n      :host([narrow]) .blank-image {\n        height: 56px;\n        width: 56px;\n      }\n\n      :host([narrow]) mwc-linear-progress {\n        padding: 0;\n        position: absolute;\n        top: -4px;\n        left: 0;\n      }\n\n      mwc-list-item[selected] {\n        font-weight: bold;\n      }\n\n      ha-svg-icon[slot=\"trailingIcon\"] {\n        margin-inline-start: 8px !important;\n        margin-inline-end: 0px !important;\n        direction: var(--direction);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-bar-media-player\": BarMediaPlayer;\n  }\n}\n"],"names":[],"sourceRoot":""}