"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
JijZept SDK Terms of Use

Please read these terms and conditions carefully before using JijZept SDK.

1. Interpretation and Definitions

The words in which the initial letter is capitalized have meanings defined under the following conditions. The following definitions shall have the same meaning regardless of whether they appear in singular or in the plural.

For these Terms and Conditions:

(a) "JijZept Service" means a cloud service for optimization calculation infrastructure provided by Jij Inc.
(b) "JijZept SDK" represents a set of software tools including "JijZept-Client", "JijModeling", and "JijModelingSchema" for developing programs that access the JijZept Services. This term includes sample programs provided by us.
(c) Company (referred to as either "the Company", "We", "Us" or "Our" in this Agreement) refers to Jij Inc., 1-4-6 Nezu, Bunkyo-Ku, Tokyo 113-0031.
(d) "Access Token" means a token necessary for connecting to the JijZept service.

2. Acknowledgment

These are the Terms and Conditions governing the use of JijZept SDK and the agreement that operates between the User and the Company.
These Terms and Conditions set out the rights and obligations of all users regarding the use of JijZept SDK.

Your use of JijZept SDK is conditioned on Your acceptance of and compliance with these Terms and Conditions. These Terms and Conditions apply to all users who use JijZept SDK.

3. Copyright

(a) All intellectual property rights, including copyrights (the rights outlined in Articles 27 and 28 of the Copyright Act of Japan), trademarks, patents, etc., related to the Service and JijZept SDK belong to the Company or third parties who have granted licenses to us and are not transferred to you by agreeing to these Terms of Use. 
(b) This license does not entitle you to receive provision or disclosure of source code for any part of JijZept SDK. However, this does not apply to sample programs, OSS, etc., that we voluntarily release to the public or that we are required to release based on a license from third parties.

4. JijZept Service

You must enter into a separate JijZept service agreement to access the JijZept Service using the JijZept SDK.

5. Prohibitions

(a) Analyzing the structure, functions of JijZept Service and JijZept SDK by reverse engineering, decompiling, disassembling, or other means or to obtain the source code of JijZept SDK.
(b) Duplicating or adapting all or part of the client software contained in the Software without the Company's prior consent.
(c) Publishing a copy of the JijZept SDK on a computer network that can be accessible by a third party.
(d) Disclosing access tokens to a third party or publishing them.
(e) Other use beyond the scope permitted by these Terms of Use.

6.  Limitation of liability

(a) The Company does not guarantee the accuracy, effectiveness, or optimality of the calculation results of JijZept SDK and JijZept Service.
(b) The Company shall not be liable for any failure of the Software to operate when the User uses or uses the Software for the User's customer by incorporating or linking it with the User-provided Software.
(c) The User shall be responsible for confirming and examining the suitability of the relevant foreign laws and regulations applicable to the use of the Software. The Company shall not be liable for any legal liabilities related to the appropriate foreign laws and regulations.

Enacted 1 July 2021.
"""
import array_length_pb2
import binary_op_pb2
import builtins
import collections.abc
import commutative_op_pb2
import decision_var_pb2
import element_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import number_lit_pb2
import placeholder_pb2
import reduction_op_pb2
import subscript_pb2
import sys
import unary_op_pb2

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class Expression(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class ExprNodeMapEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___ExpressionKind: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___ExpressionKind | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    EXPR_NODE_MAP_FIELD_NUMBER: builtins.int
    id: builtins.str
    @property
    def expr_node_map(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___ExpressionKind]: ...
    def __init__(
        self,
        *,
        id: builtins.str = ...,
        expr_node_map: collections.abc.Mapping[builtins.str, global___ExpressionKind] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["expr_node_map", b"expr_node_map", "id", b"id"]) -> None: ...

global___Expression = Expression

@typing_extensions.final
class ExpressionKind(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NUMBER_LIT_FIELD_NUMBER: builtins.int
    PLACEHOLDER_FIELD_NUMBER: builtins.int
    DECISION_VAR_FIELD_NUMBER: builtins.int
    ARRAY_LENGTH_FIELD_NUMBER: builtins.int
    UNARY_OP_FIELD_NUMBER: builtins.int
    BINARY_OP_FIELD_NUMBER: builtins.int
    COMMUTATIVE_OP_FIELD_NUMBER: builtins.int
    ELEMENT_FIELD_NUMBER: builtins.int
    SUBSCRIPT_FIELD_NUMBER: builtins.int
    REDUCTION_OP_FIELD_NUMBER: builtins.int
    @property
    def number_lit(self) -> number_lit_pb2.NumberLit:
        """No child node"""
    @property
    def placeholder(self) -> placeholder_pb2.Placeholder: ...
    @property
    def decision_var(self) -> decision_var_pb2.DecisionVar: ...
    @property
    def array_length(self) -> array_length_pb2.ArrayLength:
        """One child node"""
    @property
    def unary_op(self) -> unary_op_pb2.UnaryOp: ...
    @property
    def binary_op(self) -> binary_op_pb2.BinaryOp:
        """Two children nodes"""
    @property
    def commutative_op(self) -> commutative_op_pb2.CommutativeOp:
        """Multiple children nodes"""
    @property
    def element(self) -> element_pb2.Element: ...
    @property
    def subscript(self) -> subscript_pb2.Subscript: ...
    @property
    def reduction_op(self) -> reduction_op_pb2.ReductionOp: ...
    def __init__(
        self,
        *,
        number_lit: number_lit_pb2.NumberLit | None = ...,
        placeholder: placeholder_pb2.Placeholder | None = ...,
        decision_var: decision_var_pb2.DecisionVar | None = ...,
        array_length: array_length_pb2.ArrayLength | None = ...,
        unary_op: unary_op_pb2.UnaryOp | None = ...,
        binary_op: binary_op_pb2.BinaryOp | None = ...,
        commutative_op: commutative_op_pb2.CommutativeOp | None = ...,
        element: element_pb2.Element | None = ...,
        subscript: subscript_pb2.Subscript | None = ...,
        reduction_op: reduction_op_pb2.ReductionOp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["array_length", b"array_length", "binary_op", b"binary_op", "commutative_op", b"commutative_op", "decision_var", b"decision_var", "element", b"element", "kind", b"kind", "number_lit", b"number_lit", "placeholder", b"placeholder", "reduction_op", b"reduction_op", "subscript", b"subscript", "unary_op", b"unary_op"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["array_length", b"array_length", "binary_op", b"binary_op", "commutative_op", b"commutative_op", "decision_var", b"decision_var", "element", b"element", "kind", b"kind", "number_lit", b"number_lit", "placeholder", b"placeholder", "reduction_op", b"reduction_op", "subscript", b"subscript", "unary_op", b"unary_op"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["kind", b"kind"]) -> typing_extensions.Literal["number_lit", "placeholder", "decision_var", "array_length", "unary_op", "binary_op", "commutative_op", "element", "subscript", "reduction_op"] | None: ...

global___ExpressionKind = ExpressionKind
