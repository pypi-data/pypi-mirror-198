"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
JijZept SDK Terms of Use

Please read these terms and conditions carefully before using JijZept SDK.

1. Interpretation and Definitions

The words in which the initial letter is capitalized have meanings defined under the following conditions. The following definitions shall have the same meaning regardless of whether they appear in singular or in the plural.

For these Terms and Conditions:

(a) "JijZept Service" means a cloud service for optimization calculation infrastructure provided by Jij Inc.
(b) "JijZept SDK" represents a set of software tools including "JijZept-Client", "JijModeling", and "JijModelingSchema" for developing programs that access the JijZept Services. This term includes sample programs provided by us.
(c) Company (referred to as either "the Company", "We", "Us" or "Our" in this Agreement) refers to Jij Inc., 1-4-6 Nezu, Bunkyo-Ku, Tokyo 113-0031.
(d) "Access Token" means a token necessary for connecting to the JijZept service.

2. Acknowledgment

These are the Terms and Conditions governing the use of JijZept SDK and the agreement that operates between the User and the Company.
These Terms and Conditions set out the rights and obligations of all users regarding the use of JijZept SDK.

Your use of JijZept SDK is conditioned on Your acceptance of and compliance with these Terms and Conditions. These Terms and Conditions apply to all users who use JijZept SDK.

3. Copyright

(a) All intellectual property rights, including copyrights (the rights outlined in Articles 27 and 28 of the Copyright Act of Japan), trademarks, patents, etc., related to the Service and JijZept SDK belong to the Company or third parties who have granted licenses to us and are not transferred to you by agreeing to these Terms of Use. 
(b) This license does not entitle you to receive provision or disclosure of source code for any part of JijZept SDK. However, this does not apply to sample programs, OSS, etc., that we voluntarily release to the public or that we are required to release based on a license from third parties.

4. JijZept Service

You must enter into a separate JijZept service agreement to access the JijZept Service using the JijZept SDK.

5. Prohibitions

(a) Analyzing the structure, functions of JijZept Service and JijZept SDK by reverse engineering, decompiling, disassembling, or other means or to obtain the source code of JijZept SDK.
(b) Duplicating or adapting all or part of the client software contained in the Software without the Company's prior consent.
(c) Publishing a copy of the JijZept SDK on a computer network that can be accessible by a third party.
(d) Disclosing access tokens to a third party or publishing them.
(e) Other use beyond the scope permitted by these Terms of Use.

6.  Limitation of liability

(a) The Company does not guarantee the accuracy, effectiveness, or optimality of the calculation results of JijZept SDK and JijZept Service.
(b) The Company shall not be liable for any failure of the Software to operate when the User uses or uses the Software for the User's customer by incorporating or linking it with the User-provided Software.
(c) The User shall be responsible for confirming and examining the suitability of the relevant foreign laws and regulations applicable to the use of the Software. The Company shall not be liable for any legal liabilities related to the appropriate foreign laws and regulations.

Enacted 1 July 2021.
"""
import builtins
import collections.abc
import constraint_pb2
import custom_penalty_term_pb2
import expression_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class Problem(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Sense:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _SenseEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Problem._Sense.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        MIN: Problem._Sense.ValueType  # 0
        MAX: Problem._Sense.ValueType  # 1

    class Sense(_Sense, metaclass=_SenseEnumTypeWrapper): ...
    MIN: Problem.Sense.ValueType  # 0
    MAX: Problem.Sense.ValueType  # 1

    @typing_extensions.final
    class ConstraintMapEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> constraint_pb2.Constraint: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: constraint_pb2.Constraint | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    @typing_extensions.final
    class CustomPenaltyTermMapEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> custom_penalty_term_pb2.CustomPenaltyTerm: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: custom_penalty_term_pb2.CustomPenaltyTerm | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    SENSE_FIELD_NUMBER: builtins.int
    OBJECTIVE_FUNCTION_FIELD_NUMBER: builtins.int
    CONSTRAINT_MAP_FIELD_NUMBER: builtins.int
    CUSTOM_PENALTY_TERM_MAP_FIELD_NUMBER: builtins.int
    id: builtins.str
    name: builtins.str
    sense: global___Problem.Sense.ValueType
    @property
    def objective_function(self) -> expression_pb2.Expression: ...
    @property
    def constraint_map(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, constraint_pb2.Constraint]: ...
    @property
    def custom_penalty_term_map(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, custom_penalty_term_pb2.CustomPenaltyTerm]: ...
    def __init__(
        self,
        *,
        id: builtins.str = ...,
        name: builtins.str = ...,
        sense: global___Problem.Sense.ValueType = ...,
        objective_function: expression_pb2.Expression | None = ...,
        constraint_map: collections.abc.Mapping[builtins.str, constraint_pb2.Constraint] | None = ...,
        custom_penalty_term_map: collections.abc.Mapping[builtins.str, custom_penalty_term_pb2.CustomPenaltyTerm] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["objective_function", b"objective_function"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["constraint_map", b"constraint_map", "custom_penalty_term_map", b"custom_penalty_term_map", "id", b"id", "name", b"name", "objective_function", b"objective_function", "sense", b"sense"]) -> None: ...

global___Problem = Problem
