<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>socialization.bot API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>socialization.bot</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .base_bot import BaseBot
from .. import codes
from .json_socket_user import JSONSocketUser, MessageType, Message, rel

__all__ = [&#39;BaseBot&#39;, &#39;codes&#39;, &#39;JSONSocketUser&#39;, &#39;Message&#39;, &#39;MessageType&#39;, &#39;rel&#39;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="socialization.bot.base_bot" href="base_bot.html">socialization.bot.base_bot</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="socialization.bot.json_socket_user" href="json_socket_user.html">socialization.bot.json_socket_user</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="socialization.bot.message" href="message.html">socialization.bot.message</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="socialization.bot.BaseBot"><code class="flex name class">
<span>class <span class="ident">BaseBot</span></span>
<span>(</span><span>user_id: str, password: str, path: str = None, reconnect: int = None, pre_analyse: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the base of bot, deriving from which you can define automation of
all behavior that a bot will abey.
For basic use, what you need to do is only overriding <code>on_receive_message</code>
to define the behaviour when receive a message. For example, you
are definately allowed to broadcast the message to everyone in the channel
where you receive it by overriding <code>on_receive_message</code> and call
<code>send_message</code> with message you received send it to all users in the channel.</p>
<pre><code>We wraps the message data into a Message object.
</code></pre>
<p>For better performance(not indeed), you could set
<code>pre_analyse</code> to be <code>False</code> to get raw data of message(dict).</p>
<p>Initialize a Bot instance.</p>
<h2 id="args">Args</h2>
<p>user_id : str
User ID of the account you wanna set as a bot.
password : str
Password of that account referred above.
path : str : optional
Location of server the bot will be running on.
reconnect : int : optional
Max pending time for stalling. Reconnection will launch if stalls
outlong this time.
pre_analyse : bool : optional
Trigger for pre-analysing message by wrapping it into a Message object.
If turned off, data param in on_receive_data() will be raw dict!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseBot(JSONSocketUser):
        &#34;&#34;&#34;
        This is the base of bot, deriving from which you can define automation of 
        all behavior that a bot will abey. 
        For basic use, what you need to do is only overriding `on_receive_message`
        to define the behaviour when receive a message. For example, you
        are definately allowed to broadcast the message to everyone in the channel 
        where you receive it by overriding `on_receive_message` and call 
        `send_message` with message you received send it to all users in the channel.

        We wraps the message data into a Message object.
    For better performance(not indeed), you could set
    `pre_analyse` to be `False` to get raw data of message(dict).
        &#34;&#34;&#34;
        def __init__(self, user_id:str, password:str, path:str=None, reconnect:int=None, pre_analyse:bool=True) -&gt; None:
                &#34;&#34;&#34;
                Initialize a Bot instance.

                Args:
                        user_id : str
                                User ID of the account you wanna set as a bot.
                        password : str
                                Password of that account referred above.
                        path : str : optional
                                Location of server the bot will be running on.
                        reconnect : int : optional
                                Max pending time for stalling. Reconnection will launch if stalls
                                outlong this time.
                        pre_analyse : bool : optional
                                Trigger for pre-analysing message by wrapping it into a Message object.
                                If turned off, data param in on_receive_data() will be raw dict!
                &#34;&#34;&#34;
                self.cached = False
                super().__init__(path=path, reconnect=reconnect, pre_analyse=pre_analyse)
                self.codes = codes
                self.channel_list = []
                self.user_lists = {}
                self.user_id = user_id
                self.password = password

        def on_receive_status(self, data):
                &#34;&#34;&#34;
                Behaviour when receives status from server(6xxxx).

                By default, we would update channel_list and user_list
                on sereval cases. Therefore, if you want to customize
                behaviour receive status while keeping these properties
                up to date, override this function and **call**
                **super().on_receive_status** to keep them.

                Args:
                        data : dict
                                WS data in the format definde by `codes.md`
                &#34;&#34;&#34;
                code = data[&#39;code&#39;]

                if code == self.codes.STATUS_INFO_USER_CHANNEL_LIST:
                        self._update_channel_list(data)
                elif code == self.codes.STATUS_INFO_CREATE_CHANNEL_SUCCESS or code == self.codes.STATUS_INFO_JOIN_SUCCESS:
                        self._append_channel_list(data)
                elif code == self.codes.STATUS_INFO_LEAVE_SUCCESS:
                        self._pop_channel_list(data)
                else:
                        super().on_receive_status(data)

        def on_receive_message(self, data):
                &#34;&#34;&#34;
                Behaviour when receives message from server(3xxxx).
                Override this to customize what to do when receives
                a message!

                Args:
                        data : dict || Message
                                Wrapped Message object of message received.
                                If pre-analyse is turned off, it would be 
                                raw WS data in the format definde by `codes.md`
                &#34;&#34;&#34;
                print(&#39;Bot received message: {}&#39;.format(data))
                super().on_receive_message(data)

        def on_receive_command(self, data):
                &#34;&#34;&#34;
                Behaviour when receives commands from server(4xxxx).
                It&#39;s crucial for keeping channel_list up to date. If
                you want to customize the behaviour, please **call**
                **super().on_receive_command** to keep those properties.

                Args:
                        data : dict
                                WS data in the format definde by `codes.md`
                &#34;&#34;&#34;
                code = data[&#39;code&#39;]

                if code == self.codes.COMMAND_DOWN_UPDATE_CHANNEL_USER_LIST:
                        self._update_user_lists(data)
                else:
                        super().on_receive_command(data)

        def on_open(self, ws):
                &#34;&#34;&#34;
                Behaviour at the time websocket connection is created.

                Args:
                        ws : websocket.WebSocketApp
                Connection object.
                &#34;&#34;&#34;
                if self.cached:
                        self.login()
                print(&#39;Bot.open!&#39;)
        
        def on_close(self, ws, close_status_code, close_msg):
                &#34;&#34;&#34;
                Behaviour at the time websocket connection is closed.

                Args:
                        ws : websocket.WebSocketApp
                Connection object.
                &#34;&#34;&#34;
                print(f&#39;Bot.close: {ws} closed with status code {close_status_code} and message {close_msg}&#39;)

        def on_error(self, ws, error):
                &#34;&#34;&#34;
                Behaviour at the time error occur on websocket connection.

                Args:
                        ws : websocket.WebSocketApp
                Connection object.
                &#34;&#34;&#34;
                print(f&#39;Bot.error: {error}&#39;)
        
        def on_message(self, ws, message):
                &#34;&#34;&#34;
                Behaviour at the time receive message from websocket connection.
        
                Warning:
                        Do not re-write this if you have no idea what will happen!

                Args:
                        ws : websocket.WebSocketApp
                Connection object.
                        message : jstr
                                Raw message json string from ws connection.
                &#34;&#34;&#34;
                print(f&#39;Bot.message: {message}&#39;)
                self._safe_handle(ws, message)

        def _update_channel_list(self, data):
                &#34;&#34;&#34;
                Utility function to update current channel_list.
                If such properties are useless to you, and for
                better time performance(not that good though)
                you could re-write this to no-op.

                Args:
                        data : dict
                                WS data in the format definde by `codes.md`
                &#34;&#34;&#34;
                self.channel_list = data[&#39;extra&#39;][&#39;channel_ids&#39;]

                for channel_id in self.channel_list:
                        self._command_fetch_channel_user_list(self.user_id, channel_id)

        def _update_user_lists(self, data):
                &#34;&#34;&#34;
                Utility function to update current user_lists.
                If such properties are useless to you, and for
                better time performance(not that good though)
                you could re-write this to no-op.

                Args:
                        data : dict
                                WS data in the format definde by `codes.md`
                &#34;&#34;&#34;
                self.user_lists[data[&#39;extra&#39;][&#39;channel_id&#39;]] = data[&#39;extra&#39;][&#39;user_ids&#39;]

        def _append_channel_list(self, data):
                &#34;&#34;&#34;
                Utility function to update current channel_list.
                If such properties are useless to you, and for
                better time performance(not that good though)
                you could re-write this to no-op.

                Args:
                        data : dict
                                WS data in the format definde by `codes.md`
                &#34;&#34;&#34;
                self.channel_list.append(data[&#39;extra&#39;][&#39;channel_id&#39;])
                self._command_fetch_channel_user_list(self.user_id, data[&#39;extra&#39;][&#39;channel_id&#39;])

        def _pop_channel_list(self, data):
                &#34;&#34;&#34;
                Utility function to update current channel_list.
                If such properties are useless to you, and for
                better time performance(not that good though)
                you could re-write this to no-op.

                Args:
                        data : dict
                                WS data in the format definde by `codes.md`
                &#34;&#34;&#34;
                self.channel_list.remove(data[&#39;extra&#39;][&#39;channel_id&#39;])
                self.user_lists.pop(data[&#39;extra&#39;][&#39;channel_id&#39;])

        def login(self):
                &#34;&#34;&#34;
                Wrapped login function. Call this to login.
                If you wanna customize login behaviour, call
                `_command_login()` to send command to login.
                &#34;&#34;&#34;
                print(&#34;Bot login!&#34;)
                self.cached = True
                self._command_login(self.user_id, self.password)

        def logout(self):
                &#34;&#34;&#34;
                Wrapped logout function. Call this to logout.
                If you wanna customize logout behaviour, call
                `_command_logout()` to send command to logout.
                &#34;&#34;&#34;
                print(&#34;Bot logout!&#34;)
                self._command_logout(self.user_id)

        def register(self, email:str, password:str):
                &#34;&#34;&#34;
                Wrapped register function. Call this to register.
                If you wanna customize register behaviour, call
                `_command_register()` to send command to register.

                Args:
                        email : str
                                Email to register an account.
                        password : str
                                Password for that new account.
                &#34;&#34;&#34;
                print(&#34;Bot register&#34;)
                self._command_register(email, password)

        def reset_password(self, email:str, password:str):
                &#34;&#34;&#34;
                Wrapped reset password function. Call this to reset password.
                If you wanna customize reset password behaviour, call
                `_command_reset_password()` to send command to reset password.

                Args:
                        email : str
                                Email of the account to reset pw.
                        password : str
                                New password for that account.
                &#34;&#34;&#34;
                print(&#34;Bot reset password&#34;)
                self._command_reset_password(email, password)

        def join_channel(self, channel_id:str):
                &#34;&#34;&#34;
                Wrapped join channel function. Call this to join channel.
                If you wanna customize join channel behaviour, call
                `_command_join_channel()` to send command to join channel.

                Args:
                        channel_id : str
                                ID of channel to join.
                &#34;&#34;&#34;
                print(&#34;Bot join channel: {}&#34;.format(channel_id))
                self._command_join_channel(self.user_id, channel_id)

        def leave_channel(self, channel_id:str):
                &#34;&#34;&#34;
                Wrapped leave channel function. Call this to leave channel.
                If you wanna customize leave channel behaviour, call
                `_command_leave_channel()` to send command to leave channel.

                Args:
                        channel_id : str
                                ID of channel to leave.
                &#34;&#34;&#34;
                print(&#34;Bot leave channel: {}&#34;.format(channel_id))
                self._command_leave_channel(self.user_id, channel_id)

        def fetch_offline_message(self):
                &#34;&#34;&#34;
                Wrapped fetch ofl-message function. Call this to fetch ofl-message.
                If you wanna customize fetch ofl-message behaviour, call
                `_command_fetch_offline_message()` to send command to fetch ofl-message.
                &#34;&#34;&#34;
                print(&#34;Bot fetch offline message!&#34;)
                self._command_fetch_offline_message(self.user_id)

        def fetch_bot_channels(self):
                &#34;&#34;&#34;
                Wrapped fetch bot channels function. Call this to fetch bot channels.
                If you wanna customize fetch bot channels behaviour, call
                `_command_fetch_user_channels()` to send command to fetch bot channels.
                &#34;&#34;&#34;
                print(&#39;Bot fetch channels!&#39;)
                self._command_fetch_user_channels(self.user_id)

        def create_channel(self, channel_id):
                &#34;&#34;&#34;
                Wrapped create channel function. Call this to create channel.
                If you wanna customize create channel behaviour, call
                `_command_create_channel()` to send command to create channel.
                
                Args:
                        channel_id : str
                                ID of the new channel.
                &#34;&#34;&#34;
                print(&#39;Bot create channel: {}&#39;.format(channel_id))
                self._command_create_channel(self.user_id, channel_id)

        def fetch_channel_command_list(self, channel_id):
                &#34;&#34;&#34;
                Wrapped fetch channel cmd list function. Call this to fetch channel cmd list.
                If you wanna customize fetch channel cmd list behaviour, call
                `_command_fetch_channel_command_list()` to send command to fetch channel cmd list.

                Args:
                        channel_id : str
                                ID of the channel to fetch command list.
                &#34;&#34;&#34;
                print(&#39;Bot fetch command list of channel : {}&#39;.format(channel_id))
                self._command_fetch_channel_command_list(self.user_id, channel_id)

        def fetch_recipients(self, message_id):
                &#34;&#34;&#34;
                Wrapped fetch recipients function. Call this to fetch recipients of 
                a certain message. If you wanna customize fetch recipients behaviour, 
                call `_command_fetch_recipients()` to send command to fetch recipients.

                Args:
                        message_id : str
                                ID of the message to look up for recipients.
                &#34;&#34;&#34;
                print(&#39;Bot fetch recipients of message : {}&#39;.format(message_id))
                self._command_fetch_recipient_list(self.user_id, message_id)
        
        def send_message(self, message:Message):
                &#34;&#34;&#34;
                Wrapped send message function. Call this to send message.
                If you wanna customize send message behaviour, call
                `_command_send_message()` to send command to send message.

                Args:
                        message : Message
                                Wrapped message object contains message body, receivers,
                                target channel and sender information.
                &#34;&#34;&#34;
                temp_msg_id = f&#34;temp_{datetime.datetime.now().timestamp()}_{str(random.randint(0, 100000)).zfill(5)}&#34;
                print(&#39;Bot send message: {}\nto: {}\n at channel: {}&#39;.format(message.body, message.to, message.channel))
                self._command_send_message(temp_msg_id=temp_msg_id, message=message)

        def run(self):
                &#34;&#34;&#34;
                Behaviour to run bot. 
                By default, it will login and update several properties
                of bot like channel_list .etc. Then it will hang this
                process up and reconnect when error occurs.
                
                Warning:
                        Don&#39;t re-write this if you have no idea what will happen!
                &#34;&#34;&#34;
                self.login()
                self.fetch_bot_channels()
                rel.signal(2, rel.abort)
                rel.dispatch()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="socialization.bot.json_socket_user.JSONSocketUser" href="json_socket_user.html#socialization.bot.json_socket_user.JSONSocketUser">JSONSocketUser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="socialization.bot.BaseBot.create_channel"><code class="name flex">
<span>def <span class="ident">create_channel</span></span>(<span>self, channel_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped create channel function. Call this to create channel.
If you wanna customize create channel behaviour, call
<code>_command_create_channel()</code> to send command to create channel.</p>
<h2 id="args">Args</h2>
<p>channel_id : str
ID of the new channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_channel(self, channel_id):
        &#34;&#34;&#34;
        Wrapped create channel function. Call this to create channel.
        If you wanna customize create channel behaviour, call
        `_command_create_channel()` to send command to create channel.
        
        Args:
                channel_id : str
                        ID of the new channel.
        &#34;&#34;&#34;
        print(&#39;Bot create channel: {}&#39;.format(channel_id))
        self._command_create_channel(self.user_id, channel_id)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.fetch_bot_channels"><code class="name flex">
<span>def <span class="ident">fetch_bot_channels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped fetch bot channels function. Call this to fetch bot channels.
If you wanna customize fetch bot channels behaviour, call
<code>_command_fetch_user_channels()</code> to send command to fetch bot channels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_bot_channels(self):
        &#34;&#34;&#34;
        Wrapped fetch bot channels function. Call this to fetch bot channels.
        If you wanna customize fetch bot channels behaviour, call
        `_command_fetch_user_channels()` to send command to fetch bot channels.
        &#34;&#34;&#34;
        print(&#39;Bot fetch channels!&#39;)
        self._command_fetch_user_channels(self.user_id)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.fetch_channel_command_list"><code class="name flex">
<span>def <span class="ident">fetch_channel_command_list</span></span>(<span>self, channel_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped fetch channel cmd list function. Call this to fetch channel cmd list.
If you wanna customize fetch channel cmd list behaviour, call
<code>_command_fetch_channel_command_list()</code> to send command to fetch channel cmd list.</p>
<h2 id="args">Args</h2>
<p>channel_id : str
ID of the channel to fetch command list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_channel_command_list(self, channel_id):
        &#34;&#34;&#34;
        Wrapped fetch channel cmd list function. Call this to fetch channel cmd list.
        If you wanna customize fetch channel cmd list behaviour, call
        `_command_fetch_channel_command_list()` to send command to fetch channel cmd list.

        Args:
                channel_id : str
                        ID of the channel to fetch command list.
        &#34;&#34;&#34;
        print(&#39;Bot fetch command list of channel : {}&#39;.format(channel_id))
        self._command_fetch_channel_command_list(self.user_id, channel_id)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.fetch_offline_message"><code class="name flex">
<span>def <span class="ident">fetch_offline_message</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped fetch ofl-message function. Call this to fetch ofl-message.
If you wanna customize fetch ofl-message behaviour, call
<code>_command_fetch_offline_message()</code> to send command to fetch ofl-message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_offline_message(self):
        &#34;&#34;&#34;
        Wrapped fetch ofl-message function. Call this to fetch ofl-message.
        If you wanna customize fetch ofl-message behaviour, call
        `_command_fetch_offline_message()` to send command to fetch ofl-message.
        &#34;&#34;&#34;
        print(&#34;Bot fetch offline message!&#34;)
        self._command_fetch_offline_message(self.user_id)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.fetch_recipients"><code class="name flex">
<span>def <span class="ident">fetch_recipients</span></span>(<span>self, message_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped fetch recipients function. Call this to fetch recipients of
a certain message. If you wanna customize fetch recipients behaviour,
call <code>_command_fetch_recipients()</code> to send command to fetch recipients.</p>
<h2 id="args">Args</h2>
<p>message_id : str
ID of the message to look up for recipients.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_recipients(self, message_id):
        &#34;&#34;&#34;
        Wrapped fetch recipients function. Call this to fetch recipients of 
        a certain message. If you wanna customize fetch recipients behaviour, 
        call `_command_fetch_recipients()` to send command to fetch recipients.

        Args:
                message_id : str
                        ID of the message to look up for recipients.
        &#34;&#34;&#34;
        print(&#39;Bot fetch recipients of message : {}&#39;.format(message_id))
        self._command_fetch_recipient_list(self.user_id, message_id)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.join_channel"><code class="name flex">
<span>def <span class="ident">join_channel</span></span>(<span>self, channel_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped join channel function. Call this to join channel.
If you wanna customize join channel behaviour, call
<code>_command_join_channel()</code> to send command to join channel.</p>
<h2 id="args">Args</h2>
<p>channel_id : str
ID of channel to join.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join_channel(self, channel_id:str):
        &#34;&#34;&#34;
        Wrapped join channel function. Call this to join channel.
        If you wanna customize join channel behaviour, call
        `_command_join_channel()` to send command to join channel.

        Args:
                channel_id : str
                        ID of channel to join.
        &#34;&#34;&#34;
        print(&#34;Bot join channel: {}&#34;.format(channel_id))
        self._command_join_channel(self.user_id, channel_id)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.leave_channel"><code class="name flex">
<span>def <span class="ident">leave_channel</span></span>(<span>self, channel_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped leave channel function. Call this to leave channel.
If you wanna customize leave channel behaviour, call
<code>_command_leave_channel()</code> to send command to leave channel.</p>
<h2 id="args">Args</h2>
<p>channel_id : str
ID of channel to leave.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def leave_channel(self, channel_id:str):
        &#34;&#34;&#34;
        Wrapped leave channel function. Call this to leave channel.
        If you wanna customize leave channel behaviour, call
        `_command_leave_channel()` to send command to leave channel.

        Args:
                channel_id : str
                        ID of channel to leave.
        &#34;&#34;&#34;
        print(&#34;Bot leave channel: {}&#34;.format(channel_id))
        self._command_leave_channel(self.user_id, channel_id)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.login"><code class="name flex">
<span>def <span class="ident">login</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped login function. Call this to login.
If you wanna customize login behaviour, call
<code>_command_login()</code> to send command to login.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def login(self):
        &#34;&#34;&#34;
        Wrapped login function. Call this to login.
        If you wanna customize login behaviour, call
        `_command_login()` to send command to login.
        &#34;&#34;&#34;
        print(&#34;Bot login!&#34;)
        self.cached = True
        self._command_login(self.user_id, self.password)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.logout"><code class="name flex">
<span>def <span class="ident">logout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped logout function. Call this to logout.
If you wanna customize logout behaviour, call
<code>_command_logout()</code> to send command to logout.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logout(self):
        &#34;&#34;&#34;
        Wrapped logout function. Call this to logout.
        If you wanna customize logout behaviour, call
        `_command_logout()` to send command to logout.
        &#34;&#34;&#34;
        print(&#34;Bot logout!&#34;)
        self._command_logout(self.user_id)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.on_close"><code class="name flex">
<span>def <span class="ident">on_close</span></span>(<span>self, ws, close_status_code, close_msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Behaviour at the time websocket connection is closed.</p>
<h2 id="args">Args</h2>
<p>ws : websocket.WebSocketApp
Connection object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_close(self, ws, close_status_code, close_msg):
        &#34;&#34;&#34;
        Behaviour at the time websocket connection is closed.

        Args:
                ws : websocket.WebSocketApp
        Connection object.
        &#34;&#34;&#34;
        print(f&#39;Bot.close: {ws} closed with status code {close_status_code} and message {close_msg}&#39;)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.on_error"><code class="name flex">
<span>def <span class="ident">on_error</span></span>(<span>self, ws, error)</span>
</code></dt>
<dd>
<div class="desc"><p>Behaviour at the time error occur on websocket connection.</p>
<h2 id="args">Args</h2>
<p>ws : websocket.WebSocketApp
Connection object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_error(self, ws, error):
        &#34;&#34;&#34;
        Behaviour at the time error occur on websocket connection.

        Args:
                ws : websocket.WebSocketApp
        Connection object.
        &#34;&#34;&#34;
        print(f&#39;Bot.error: {error}&#39;)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.on_message"><code class="name flex">
<span>def <span class="ident">on_message</span></span>(<span>self, ws, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Behaviour at the time receive message from websocket connection.</p>
<h2 id="warning">Warning</h2>
<p>Do not re-write this if you have no idea what will happen!</p>
<h2 id="args">Args</h2>
<p>ws : websocket.WebSocketApp
Connection object.
message : jstr
Raw message json string from ws connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_message(self, ws, message):
        &#34;&#34;&#34;
        Behaviour at the time receive message from websocket connection.

        Warning:
                Do not re-write this if you have no idea what will happen!

        Args:
                ws : websocket.WebSocketApp
        Connection object.
                message : jstr
                        Raw message json string from ws connection.
        &#34;&#34;&#34;
        print(f&#39;Bot.message: {message}&#39;)
        self._safe_handle(ws, message)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.on_open"><code class="name flex">
<span>def <span class="ident">on_open</span></span>(<span>self, ws)</span>
</code></dt>
<dd>
<div class="desc"><p>Behaviour at the time websocket connection is created.</p>
<h2 id="args">Args</h2>
<p>ws : websocket.WebSocketApp
Connection object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_open(self, ws):
        &#34;&#34;&#34;
        Behaviour at the time websocket connection is created.

        Args:
                ws : websocket.WebSocketApp
        Connection object.
        &#34;&#34;&#34;
        if self.cached:
                self.login()
        print(&#39;Bot.open!&#39;)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.on_receive_command"><code class="name flex">
<span>def <span class="ident">on_receive_command</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Behaviour when receives commands from server(4xxxx).
It's crucial for keeping channel_list up to date. If
you want to customize the behaviour, please <strong>call</strong>
<strong>super().on_receive_command</strong> to keep those properties.</p>
<h2 id="args">Args</h2>
<p>data : dict
WS data in the format definde by <code>codes.md</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_receive_command(self, data):
        &#34;&#34;&#34;
        Behaviour when receives commands from server(4xxxx).
        It&#39;s crucial for keeping channel_list up to date. If
        you want to customize the behaviour, please **call**
        **super().on_receive_command** to keep those properties.

        Args:
                data : dict
                        WS data in the format definde by `codes.md`
        &#34;&#34;&#34;
        code = data[&#39;code&#39;]

        if code == self.codes.COMMAND_DOWN_UPDATE_CHANNEL_USER_LIST:
                self._update_user_lists(data)
        else:
                super().on_receive_command(data)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.on_receive_message"><code class="name flex">
<span>def <span class="ident">on_receive_message</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Behaviour when receives message from server(3xxxx).
Override this to customize what to do when receives
a message!</p>
<h2 id="args">Args</h2>
<p>data : dict || Message
Wrapped Message object of message received.
If pre-analyse is turned off, it would be
raw WS data in the format definde by <code>codes.md</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_receive_message(self, data):
        &#34;&#34;&#34;
        Behaviour when receives message from server(3xxxx).
        Override this to customize what to do when receives
        a message!

        Args:
                data : dict || Message
                        Wrapped Message object of message received.
                        If pre-analyse is turned off, it would be 
                        raw WS data in the format definde by `codes.md`
        &#34;&#34;&#34;
        print(&#39;Bot received message: {}&#39;.format(data))
        super().on_receive_message(data)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.on_receive_status"><code class="name flex">
<span>def <span class="ident">on_receive_status</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Behaviour when receives status from server(6xxxx).</p>
<p>By default, we would update channel_list and user_list
on sereval cases. Therefore, if you want to customize
behaviour receive status while keeping these properties
up to date, override this function and <strong>call</strong>
<strong>super().on_receive_status</strong> to keep them.</p>
<h2 id="args">Args</h2>
<p>data : dict
WS data in the format definde by <code>codes.md</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_receive_status(self, data):
        &#34;&#34;&#34;
        Behaviour when receives status from server(6xxxx).

        By default, we would update channel_list and user_list
        on sereval cases. Therefore, if you want to customize
        behaviour receive status while keeping these properties
        up to date, override this function and **call**
        **super().on_receive_status** to keep them.

        Args:
                data : dict
                        WS data in the format definde by `codes.md`
        &#34;&#34;&#34;
        code = data[&#39;code&#39;]

        if code == self.codes.STATUS_INFO_USER_CHANNEL_LIST:
                self._update_channel_list(data)
        elif code == self.codes.STATUS_INFO_CREATE_CHANNEL_SUCCESS or code == self.codes.STATUS_INFO_JOIN_SUCCESS:
                self._append_channel_list(data)
        elif code == self.codes.STATUS_INFO_LEAVE_SUCCESS:
                self._pop_channel_list(data)
        else:
                super().on_receive_status(data)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, email: str, password: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped register function. Call this to register.
If you wanna customize register behaviour, call
<code>_command_register()</code> to send command to register.</p>
<h2 id="args">Args</h2>
<p>email : str
Email to register an account.
password : str
Password for that new account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self, email:str, password:str):
        &#34;&#34;&#34;
        Wrapped register function. Call this to register.
        If you wanna customize register behaviour, call
        `_command_register()` to send command to register.

        Args:
                email : str
                        Email to register an account.
                password : str
                        Password for that new account.
        &#34;&#34;&#34;
        print(&#34;Bot register&#34;)
        self._command_register(email, password)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.reset_password"><code class="name flex">
<span>def <span class="ident">reset_password</span></span>(<span>self, email: str, password: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped reset password function. Call this to reset password.
If you wanna customize reset password behaviour, call
<code>_command_reset_password()</code> to send command to reset password.</p>
<h2 id="args">Args</h2>
<p>email : str
Email of the account to reset pw.
password : str
New password for that account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_password(self, email:str, password:str):
        &#34;&#34;&#34;
        Wrapped reset password function. Call this to reset password.
        If you wanna customize reset password behaviour, call
        `_command_reset_password()` to send command to reset password.

        Args:
                email : str
                        Email of the account to reset pw.
                password : str
                        New password for that account.
        &#34;&#34;&#34;
        print(&#34;Bot reset password&#34;)
        self._command_reset_password(email, password)</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Behaviour to run bot.
By default, it will login and update several properties
of bot like channel_list .etc. Then it will hang this
process up and reconnect when error occurs.</p>
<h2 id="warning">Warning</h2>
<p>Don't re-write this if you have no idea what will happen!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
        &#34;&#34;&#34;
        Behaviour to run bot. 
        By default, it will login and update several properties
        of bot like channel_list .etc. Then it will hang this
        process up and reconnect when error occurs.
        
        Warning:
                Don&#39;t re-write this if you have no idea what will happen!
        &#34;&#34;&#34;
        self.login()
        self.fetch_bot_channels()
        rel.signal(2, rel.abort)
        rel.dispatch()</code></pre>
</details>
</dd>
<dt id="socialization.bot.BaseBot.send_message"><code class="name flex">
<span>def <span class="ident">send_message</span></span>(<span>self, message: <a title="socialization.bot.message.Message" href="message.html#socialization.bot.message.Message">Message</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapped send message function. Call this to send message.
If you wanna customize send message behaviour, call
<code>_command_send_message()</code> to send command to send message.</p>
<h2 id="args">Args</h2>
<p>message : Message
Wrapped message object contains message body, receivers,
target channel and sender information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_message(self, message:Message):
        &#34;&#34;&#34;
        Wrapped send message function. Call this to send message.
        If you wanna customize send message behaviour, call
        `_command_send_message()` to send command to send message.

        Args:
                message : Message
                        Wrapped message object contains message body, receivers,
                        target channel and sender information.
        &#34;&#34;&#34;
        temp_msg_id = f&#34;temp_{datetime.datetime.now().timestamp()}_{str(random.randint(0, 100000)).zfill(5)}&#34;
        print(&#39;Bot send message: {}\nto: {}\n at channel: {}&#39;.format(message.body, message.to, message.channel))
        self._command_send_message(temp_msg_id=temp_msg_id, message=message)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="socialization.bot.json_socket_user.JSONSocketUser" href="json_socket_user.html#socialization.bot.json_socket_user.JSONSocketUser">JSONSocketUser</a></b></code>:
<ul class="hlist">
<li><code><a title="socialization.bot.json_socket_user.JSONSocketUser.create_connection" href="json_socket_user.html#socialization.bot.json_socket_user.JSONSocketUser.create_connection">create_connection</a></code></li>
<li><code><a title="socialization.bot.json_socket_user.JSONSocketUser.on_receive_other" href="json_socket_user.html#socialization.bot.json_socket_user.JSONSocketUser.on_receive_other">on_receive_other</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="socialization.bot.JSONSocketUser"><code class="flex name class">
<span>class <span class="ident">JSONSocketUser</span></span>
<span>(</span><span>path: str = None, reconnect: int = None, pre_analyse: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>This is basic class of socket client user, which
implements fundamental interfaces that you can
reach as a user.
We wraps the message data into a Message object.
For better performance(not indeed), you could set
<code>pre_analyse</code> to be <code>False</code> to get raw data of message(dict).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONSocketUser:
    &#34;&#34;&#34;
    This is basic class of socket client user, which 
    implements fundamental interfaces that you can 
    reach as a user.
    We wraps the message data into a Message object.
    For better performance(not indeed), you could set
    `pre_analyse` to be `False` to get raw data of message(dict).
    &#34;&#34;&#34;

    def __init__(self, path:str=None, reconnect:int=None, pre_analyse:bool=True) -&gt; None:
        self.path = path if path else &#39;wss://frog.4fun.chat/social&#39;
        self.reconnect = reconnect if reconnect else 5
        self.codes = codes
        self.pre_analyse = pre_analyse

        self.create_connection(self.path)
        print(&#39;created connection with {}&#39;.format(self.path))
    
    def _create_websocket(self, uri:str, on_open=None, on_message=None, on_error=None, on_close=None):
        &#34;&#34;&#34;
        Create and return a websocket connection object

        Args:
            uri : str
                Location of server this user connects.

            on_open : function : optional
                Callback function execute when websocket connection is created.
                
            on_message : function : optional
                Callback function execute when receive message from websocket connection.
            
            on_error : function : optional
                Callback function execute when error occurs on websocket connection.

            on_close : function : optional
                Callback function execute when websocket connectoin breaks or closes.

        Return:
            Return the websocket object that is created when called.
            
        &#34;&#34;&#34;
        print(&#39;create_websocket!&#39;)
        ws = websocket.WebSocketApp(
            uri,
            on_open=on_open or self.on_open,
            on_message=on_message or self.on_message,
            on_error=on_error or self.on_error,
            on_close=on_close or self.on_close
        )
        return ws
    
    def create_connection(self, uri: str, on_open=None, on_message=None, on_error=None, on_close=None):
        &#34;&#34;&#34;
        Initialize websocket connection between this user object itself and given server

        Args:
            Args:
            uri : str
                Location of server this user connects.

            on_open : function : optional
                Callback function execute when websocket connection is created.
                
            on_message : function : optional
                Callback function execute when receive message from websocket connection.
            
            on_error : function : optional
                Callback function execute when error occurs on websocket connection.

            on_close : function : optional
                Callback function execute when websocket connectoin breaks or closes.
        &#34;&#34;&#34;
        self.ws = self._create_websocket(uri, on_open, on_message, on_error, on_close)
        self.ws.run_forever(dispatcher=rel, reconnect=self.reconnect)

    def on_message(self, ws, message):
        &#34;&#34;&#34;
        Default callback when receive message from websocket connectoin.
        Don&#39;t override this function if you can&#39;t figure out what you would
        face to do so!

        Args:
            ws : websocket.WebSocketApp
                Connection object.
            
            message : str
                Message Object in utf-8 received from websocket connection.

        &#34;&#34;&#34;
        print(f&#39;JSONSocketUser.message: {message}&#39;)
        self._safe_handle(ws, message)

    def on_error(self, ws, error):
        &#34;&#34;&#34;
        Default callback execute when error occurs on connection.
        As default, it would only print error instead of raise an
        exception.
        Args:
            ws : websocket.WebSocketApp
                Connection object.
            
            error : exception object
                Object contains full information of the error.
            
        &#34;&#34;&#34;
        print(f&#39;JSONSocketUser.error: {error}&#39;)
    
    def on_close(self, ws, close_status_code, close_msg):
        &#34;&#34;&#34;
        Default callback execute when connection is closed.
        As default, it would only print closure information.

        Args:
            ws : websocket.WebSocketApp
                Connection object

            close_status_code : str
                Status code of closure, more details refer to `https://websocket-client.readthedocs.io/en/latest`
        
            close_msg : str
                Information of closure.
            
        &#34;&#34;&#34;
        print(f&#39;JSONSocketUser.close: {ws} closed with status code {close_status_code} and message {close_msg}&#39;)

    def on_open(self, ws):
        &#34;&#34;&#34;
        Callback that is called when connection is open.
        As default it will only print message that bot opens.
        Args:
            ws : websocket.WebSocketApp
                Connection object. 
        
        &#34;&#34;&#34;
        print(&#39;JSONSocketUser.open&#39;)
        
    @staticmethod
    def _make_data_dict(code:int, **extra_args) -&gt; object:
        &#34;&#34;&#34;
        Format given params to meet that social server need.

        Args:
            code : int
                Type code of this message, more details refer to `/codes.md`
            **extra_args : key-value pair of params : optional
                Other params to carry with message. all of these will be wrapped
                in `extra` segment of return value.

        Return:
            Wrapped object of all given params.
        &#34;&#34;&#34;
        return {
            &#39;code&#39;: code,
            &#39;extra&#39;: extra_args
        }
    
    def _send_data_to_ws(self, ws, code:int, **extra_args):
        &#34;&#34;&#34;
        Warp and format given params then send with websocket connection.

        Args:
            ws : websocket.WebSocketApp
                Connection object.
            code : int 
                Type code of the message, which decides how it will work
            **extra_args : key-value pair of params : optional
                Other params to carry with message. all of these will be wrapped
                in `extra` segment of return value.

        &#34;&#34;&#34;
        data_dict = self._make_data_dict(code=code, **extra_args)
        self._safe_send(ws, data_dict)

    def _safe_send(self, ws, data:dict):
        &#34;&#34;&#34;
        Send wrapped data making sure of data safety. The `safety` emphasizes data format 
        instead of connection or privacy!

        Args:
            ws : websocket.WebSocketApp
                Connection object.
            
            data : dict
                Wrapped data object in format of that in `/code.md`. 
        
        &#34;&#34;&#34;
        try:
            if isinstance(data, dict):
                data = json.dumps(data)
            else:
                pass

            ws.send(data)
            return True
        except websocket.WebSocketConnectionClosedException as e:
            print(&#39;Bot: _safe_send: Connection Closed Exception&#39;, e)

        except Exception as e:
            traceback.print_exc()
            print(&#39;Bot: self._safe_send: Exception Occurs&#39;, e)

    def _safe_handle(self, ws, message:str):
        &#34;&#34;&#34;
        Load object from message (that in type of jstr) and distribute it
        to matching handler.
        It will time for each message from received to fully processed. 
        Args:
            ws : websocket.WebSocketApp
                Connection object.
            message : json string
                Message received from websocket.

        &#34;&#34;&#34;
        ct = datetime.datetime.now()
        print(&#39;before social bot _safe_handle current time:- &#39;, ct)

        try:
            data = json.loads(message)
            ct = datetime.datetime.now()
            self._handle_data_dict(ws, data)

        except ValueError as e:
            print(f&#39;Bot: _safe_handle received non-json message: {message}&#39;)

        except Exception as e:
            print(&#39;Bot: Server function error!&#39;, e)
            traceback.print_exc()
        
        ct = datetime.datetime.now()
        print(&#39;after social bot _safe_handle current time:- &#39;, ct)
    
    def _handle_data_dict(self, ws, data:dict):
        &#34;&#34;&#34;
        Distribute message to matching handler by type code.
        
        Args:
            ws : websocket.WebSocketApp
                Connection object.
            data : dict
                Message object received from connection.
        
        &#34;&#34;&#34;
        code = data[&#39;code&#39;]

        if code &gt;= 40000 and code &lt; 50000:
            self.on_receive_command(data)
        elif code &gt;= 50000 and code &lt; 60000:
            self.on_receive_message(message_from_raw(data) if self.pre_analyse else data)
        elif code &gt;= 60000 and code &lt; 70000:
            self.on_receive_status(data)
        else:
            self.on_receive_other(data)
        print(f&#39;Bot default: _handle_data_dict received {data} at websocket {ws}&#39;)

    def _command_register(self, email, password):
        &#34;&#34;&#34;
        Fundamental API for user to register.

        Args:
            email : str
                Email for registering an account.
            password : str
                Password for registering an account.
            
        &#34;&#34;&#34;

        if not self.ws:
            raise Exception(&#39;error: register before connection created!&#39;)
        
        self._send_data_to_ws(self.ws, self.codes.OPERATION_REGISTER, email=email, password=password)
    
    def _command_reset_password(self, email, password):
        &#34;&#34;&#34;
        Fundamental API for user to reset password of account.

        Args:
            email : str
                Email of account to reset password.
            password : str
                Original password of the account.
        &#34;&#34;&#34;

        if not self.ws:
            raise Exception(&#39;error: reset password before connection created!&#39;)
        
        self._send_data_to_ws(self.ws, self.codes.OPERATION_RESET_PASSWORD, email=email, password=password)

    def _command_login(self, user_id, password):
        &#34;&#34;&#34;
        Fundamental API for user to login.

        Args:
            user_id : str
                User ID of account to login.
            password : str
                Password of the account.
        &#34;&#34;&#34;

        if not self.ws:
            raise Exception(&#39;error: login before connection created!&#39;)
        
        self._send_data_to_ws(self.ws, self.codes.OPERATION_LOGIN, user_id=user_id, password=password)
    
    def _command_logout(self, user_id):
        &#34;&#34;&#34;
        Fundamental API for user to logout.

        Args:
            user_id : str
                User ID of account to logout.
        &#34;&#34;&#34;

        if not self.ws:
            raise Exception(&#39;error: logout before connection created!&#39;)
        
        self._send_data_to_ws(self.ws, self.codes.OPERATION_LOGOUT, user_id=user_id)

    def _command_join_channel(self, user_id, channel_id):
        &#34;&#34;&#34;
        Fundamental API for user to join a existing channel.
        Will receive error code if trynna join a unexisting channel.

        Args:
            user_id : str
                User ID of account that already logged in.
            channel_id : str
                ID of the channel to join.
        &#34;&#34;&#34;

        if not self.ws:
            raise Exception(&#39;error: join channel before connection created!&#39;)
        
        self._send_data_to_ws(self.ws, self.codes.OPERATION_JOIN_CHANNEL, user_id=user_id, channel_id=channel_id)

    def _command_leave_channel(self, user_id, channel_id):
        &#34;&#34;&#34;
        Fundamental API for user to leave a existing channel that contains current account.
        Will receive error code if trynna leave a channel that doesn&#39;t contain you.

        Args:
            user_id : str
                User ID of account that already logged in.
            channel_id : str
                ID of the channel to leave.
        &#34;&#34;&#34;
        if not self.ws:
            raise Exception(&#39;error: leave channel before connection created!&#39;)
        
        self._send_data_to_ws(self.ws, self.codes.OPERATION_LEAVE_CHANNEL, user_id=user_id, channel_id=channel_id)

    def _command_fetch_offline_message(self, user_id):
        &#34;&#34;&#34;
        Fundamental API for user to fetch messages that sent to an account 
        when it&#39;s not online.

        Args:
            user_id : str
                User ID of a account that already logged in.
        &#34;&#34;&#34;

        if not self.ws:
            raise Exception(&#39;error: fetch offline message before connection created!&#39;)
        
        self._send_data_to_ws(self.ws, self.codes.OPERATION_FETCH_OFFLINE_MESSAGE, user_id=user_id)

    def _command_fetch_user_channels(self, user_id):
        &#34;&#34;&#34;
        Fundamental API for user to fetch the list of channels that contains this account. 

        Args:
            user_id : str
                User ID of a account that already logged in.
        &#34;&#34;&#34;

        if not self.ws:
            raise Exception(&#39;error: get user channels before connection created!&#39;)
        
        self._send_data_to_ws(self.ws, self.codes.OPERATION_GET_USER_CHANNEL_LIST, user_id=user_id)

    def _command_create_channel(self, user_id, channel_id):
        &#34;&#34;&#34;
        Fundamental API for user to create a new channel. 
        If create with a ID already in use will receive error code.

        Args:
            user_id : str
                User ID of a account that already logged in.
            channel_id : str
                ID of channel to create.
        &#34;&#34;&#34;

        if not self.ws:
            raise Exception(&#39;error: create channel before connection created!&#39;)
        
        self._send_data_to_ws(self.ws, self.codes.OPERATION_CREATE_CHANNEL, user_id=user_id, channel_id=channel_id)

    def _command_fetch_channel_user_list(self, user_id, channel_id):
        &#34;&#34;&#34;
        Fundamental API for user to fetch a list of ussers in a certain channel. 
        Will receive error code if trynna fetch a channel inexists.

        Args:
            user_id : str
                User ID of a account that already logged in.
            channel_id : str
                ID of channel to fetch.
        &#34;&#34;&#34;

        if not self.ws:
            raise Exception(&#39;error: fetch channel user list before connection created!&#39;)
        
        self._send_data_to_ws(self.ws, self.codes.COMMAND_UP_FETCH_CHANNEL_USER_LIST, user_id=user_id, channel_id=channel_id)

    def _command_fetch_channel_command_list(self, user_id, channel_id):
        &#34;&#34;&#34;
        Fundamental API for user to fetch a list of features in a certain channel. 
        Will receive error code if trynna fetch a channel inexists.

        Args:
            user_id : str
                User ID of a account that already logged in.
            channel_id : str
                ID of channel to fetch.
        &#34;&#34;&#34;

        if not self.ws:
            raise Exception(&#39;error: fetch channel command list before connection created!&#39;)
        
        self._send_data_to_ws(self.ws, self.codes.COMMAND_UP_FETCH_CCS_COMMAND_LIST, user_id=user_id, channel_id=channel_id)

    def _command_fetch_recipient_list(self, user_id, msg_id):
        &#34;&#34;&#34;
        Fundamental API for user to fetch a list of recipients of a certain message.
        Will receive error code if trynna fetch a message unexist.
        Args:
            user_id : str
                User ID of a account that already logged in.
            msg_id : str
                ID of message to fetch.
        &#34;&#34;&#34;

        if not self.ws:
            raise Exception(&#39;error: fetch recipient list before connection created!&#39;)
        
        self._send_data_to_ws(self.ws, self.codes.COMMAND_UP_FETCH_RECIPIENT_LIST, user_id=user_id, msg_id=msg_id)

    def _command_send_message(self, temp_msg_id, message:Message):
        &#34;&#34;&#34;
        Wrapped API for sending certain message to certain users in certain channel.

        Args:
            temp_msg_id : str
                Not in use, will be removed in the future.
            message : Message
                Message object that consists of information required for sending.
        &#34;&#34;&#34;

        if not self.ws:
            raise Exception(&#39;error: send message before connection created!&#39;)
        
        if message.type == MessageType.TEXT:
            self._send_message_text(message.channel, message.sender, message.to, temp_msg_id, message.body, message.origin)
        else:
            #TODO:
            pass

    def _send_message_text(self, channel_id, from_user_id, to_user_ids, temp_msg_id, msg_body, origin):
        &#34;&#34;&#34;
        Fundamental API to send message in text.
        
        Args: 
            channel_id : str
                ID of channel to send.
            from_user_id : str
                ID of sender.
            to_user_id : list
                List of recipients.
            temp_msg_id : str
                Not in use, will be removed in the future.
            msg_body : str
                Content of message to send.
            origin : str
                Specifier for bot, server, god and goddess.
        &#34;&#34;&#34;
        print(&#34;Send text message: id-{}, body-{}&#34;.format(temp_msg_id, msg_body))
        self._send_data_to_ws(self.ws, self.codes.MESSAGE_UP_TEXT, channel_id=channel_id, from_user_id=from_user_id, to_user_ids=to_user_ids, temp_msg_id=temp_msg_id, msg_body=msg_body, origin=origin)
    
    def on_receive_command(self, data):
        &#34;&#34;&#34;
        Default callback that is called when receive command from connection.

        Args:
            data : dict
                Object of command.
        
        &#34;&#34;&#34;
        print(f&#39;Default on_receive_command: {data}&#39;)

    def on_receive_message(self, data):
        &#34;&#34;&#34;
        Default callback that is called when receive message from connection.

        Args:
            data : Message
                Object of message.
        
        &#34;&#34;&#34;
        print(f&#39;Default on_receive_message: {data}&#39;)

    def on_receive_status(self, data):
        &#34;&#34;&#34;
        Default callback that is called when receive status from connection.

        Args:
            data : dict
                Object of status.
        
        &#34;&#34;&#34;
        print(f&#39;Default on_receive_status: {data}&#39;)

    def on_receive_other(self, data):
        &#34;&#34;&#34;
        Default callback that is called when receive something that is not command,
        message or status from connection.
        It always indicates error occurs on server end. As default, it will raise an 
        exception when called.
        Args:
            data : dict
                Object of received thing.
        
        &#34;&#34;&#34;
        raise Exception(f&#34;Error happens, received {data}&#34;)

    def run(self):
        &#34;&#34;&#34;
        Default function to startup a bot.
        Basically it will bind an rel to reconnect when stalled too long.
        Override this if you want to make some change before connection is
        created!
        &#34;&#34;&#34;
        rel.signal(2, rel.abort)
        print(&#39;rel created&#39;)
        rel.dispatch()
        print(&#39;finished running&#39;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="socialization.bot.base_bot.BaseBot" href="base_bot.html#socialization.bot.base_bot.BaseBot">BaseBot</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="socialization.bot.JSONSocketUser.create_connection"><code class="name flex">
<span>def <span class="ident">create_connection</span></span>(<span>self, uri: str, on_open=None, on_message=None, on_error=None, on_close=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize websocket connection between this user object itself and given server</p>
<h2 id="args">Args</h2>
<p>Args:
uri : str
Location of server this user connects.</p>
<p>on_open : function : optional
Callback function execute when websocket connection is created.</p>
<p>on_message : function : optional
Callback function execute when receive message from websocket connection.</p>
<p>on_error : function : optional
Callback function execute when error occurs on websocket connection.</p>
<p>on_close : function : optional
Callback function execute when websocket connectoin breaks or closes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_connection(self, uri: str, on_open=None, on_message=None, on_error=None, on_close=None):
    &#34;&#34;&#34;
    Initialize websocket connection between this user object itself and given server

    Args:
        Args:
        uri : str
            Location of server this user connects.

        on_open : function : optional
            Callback function execute when websocket connection is created.
            
        on_message : function : optional
            Callback function execute when receive message from websocket connection.
        
        on_error : function : optional
            Callback function execute when error occurs on websocket connection.

        on_close : function : optional
            Callback function execute when websocket connectoin breaks or closes.
    &#34;&#34;&#34;
    self.ws = self._create_websocket(uri, on_open, on_message, on_error, on_close)
    self.ws.run_forever(dispatcher=rel, reconnect=self.reconnect)</code></pre>
</details>
</dd>
<dt id="socialization.bot.JSONSocketUser.on_close"><code class="name flex">
<span>def <span class="ident">on_close</span></span>(<span>self, ws, close_status_code, close_msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Default callback execute when connection is closed.
As default, it would only print closure information.</p>
<h2 id="args">Args</h2>
<p>ws : websocket.WebSocketApp
Connection object</p>
<p>close_status_code : str
Status code of closure, more details refer to <code>https://websocket-client.readthedocs.io/en/latest</code></p>
<p>close_msg : str
Information of closure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_close(self, ws, close_status_code, close_msg):
    &#34;&#34;&#34;
    Default callback execute when connection is closed.
    As default, it would only print closure information.

    Args:
        ws : websocket.WebSocketApp
            Connection object

        close_status_code : str
            Status code of closure, more details refer to `https://websocket-client.readthedocs.io/en/latest`
    
        close_msg : str
            Information of closure.
        
    &#34;&#34;&#34;
    print(f&#39;JSONSocketUser.close: {ws} closed with status code {close_status_code} and message {close_msg}&#39;)</code></pre>
</details>
</dd>
<dt id="socialization.bot.JSONSocketUser.on_error"><code class="name flex">
<span>def <span class="ident">on_error</span></span>(<span>self, ws, error)</span>
</code></dt>
<dd>
<div class="desc"><p>Default callback execute when error occurs on connection.
As default, it would only print error instead of raise an
exception.</p>
<h2 id="args">Args</h2>
<p>ws : websocket.WebSocketApp
Connection object.</p>
<p>error : exception object
Object contains full information of the error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_error(self, ws, error):
    &#34;&#34;&#34;
    Default callback execute when error occurs on connection.
    As default, it would only print error instead of raise an
    exception.
    Args:
        ws : websocket.WebSocketApp
            Connection object.
        
        error : exception object
            Object contains full information of the error.
        
    &#34;&#34;&#34;
    print(f&#39;JSONSocketUser.error: {error}&#39;)</code></pre>
</details>
</dd>
<dt id="socialization.bot.JSONSocketUser.on_message"><code class="name flex">
<span>def <span class="ident">on_message</span></span>(<span>self, ws, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Default callback when receive message from websocket connectoin.
Don't override this function if you can't figure out what you would
face to do so!</p>
<h2 id="args">Args</h2>
<p>ws : websocket.WebSocketApp
Connection object.</p>
<p>message : str
Message Object in utf-8 received from websocket connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_message(self, ws, message):
    &#34;&#34;&#34;
    Default callback when receive message from websocket connectoin.
    Don&#39;t override this function if you can&#39;t figure out what you would
    face to do so!

    Args:
        ws : websocket.WebSocketApp
            Connection object.
        
        message : str
            Message Object in utf-8 received from websocket connection.

    &#34;&#34;&#34;
    print(f&#39;JSONSocketUser.message: {message}&#39;)
    self._safe_handle(ws, message)</code></pre>
</details>
</dd>
<dt id="socialization.bot.JSONSocketUser.on_open"><code class="name flex">
<span>def <span class="ident">on_open</span></span>(<span>self, ws)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback that is called when connection is open.
As default it will only print message that bot opens.</p>
<h2 id="args">Args</h2>
<p>ws : websocket.WebSocketApp
Connection object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_open(self, ws):
    &#34;&#34;&#34;
    Callback that is called when connection is open.
    As default it will only print message that bot opens.
    Args:
        ws : websocket.WebSocketApp
            Connection object. 
    
    &#34;&#34;&#34;
    print(&#39;JSONSocketUser.open&#39;)</code></pre>
</details>
</dd>
<dt id="socialization.bot.JSONSocketUser.on_receive_command"><code class="name flex">
<span>def <span class="ident">on_receive_command</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Default callback that is called when receive command from connection.</p>
<h2 id="args">Args</h2>
<p>data : dict
Object of command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_receive_command(self, data):
    &#34;&#34;&#34;
    Default callback that is called when receive command from connection.

    Args:
        data : dict
            Object of command.
    
    &#34;&#34;&#34;
    print(f&#39;Default on_receive_command: {data}&#39;)</code></pre>
</details>
</dd>
<dt id="socialization.bot.JSONSocketUser.on_receive_message"><code class="name flex">
<span>def <span class="ident">on_receive_message</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Default callback that is called when receive message from connection.</p>
<h2 id="args">Args</h2>
<p>data : Message
Object of message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_receive_message(self, data):
    &#34;&#34;&#34;
    Default callback that is called when receive message from connection.

    Args:
        data : Message
            Object of message.
    
    &#34;&#34;&#34;
    print(f&#39;Default on_receive_message: {data}&#39;)</code></pre>
</details>
</dd>
<dt id="socialization.bot.JSONSocketUser.on_receive_other"><code class="name flex">
<span>def <span class="ident">on_receive_other</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Default callback that is called when receive something that is not command,
message or status from connection.
It always indicates error occurs on server end. As default, it will raise an
exception when called.</p>
<h2 id="args">Args</h2>
<p>data : dict
Object of received thing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_receive_other(self, data):
    &#34;&#34;&#34;
    Default callback that is called when receive something that is not command,
    message or status from connection.
    It always indicates error occurs on server end. As default, it will raise an 
    exception when called.
    Args:
        data : dict
            Object of received thing.
    
    &#34;&#34;&#34;
    raise Exception(f&#34;Error happens, received {data}&#34;)</code></pre>
</details>
</dd>
<dt id="socialization.bot.JSONSocketUser.on_receive_status"><code class="name flex">
<span>def <span class="ident">on_receive_status</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Default callback that is called when receive status from connection.</p>
<h2 id="args">Args</h2>
<p>data : dict
Object of status.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_receive_status(self, data):
    &#34;&#34;&#34;
    Default callback that is called when receive status from connection.

    Args:
        data : dict
            Object of status.
    
    &#34;&#34;&#34;
    print(f&#39;Default on_receive_status: {data}&#39;)</code></pre>
</details>
</dd>
<dt id="socialization.bot.JSONSocketUser.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Default function to startup a bot.
Basically it will bind an rel to reconnect when stalled too long.
Override this if you want to make some change before connection is
created!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    Default function to startup a bot.
    Basically it will bind an rel to reconnect when stalled too long.
    Override this if you want to make some change before connection is
    created!
    &#34;&#34;&#34;
    rel.signal(2, rel.abort)
    print(&#39;rel created&#39;)
    rel.dispatch()
    print(&#39;finished running&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="socialization.bot.Message"><code class="flex name class">
<span>class <span class="ident">Message</span></span>
<span>(</span><span>type: <a title="socialization.bot.message.MessageType" href="message.html#socialization.bot.message.MessageType">MessageType</a>, body=None, channel: str = '', to: list = [], sender: str = '', recipient_count: int = 0, id: str = '', origin: str = 'Bot', raw=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Message():
    def __init__(self, type:MessageType, body=None, channel:str=&#39;&#39;, to:list=[], sender:str=&#39;&#39;, recipient_count:int=0,
                 id:str=&#39;&#39;, origin:str=&#39;Bot&#39;, raw=None) -&gt; None:
        self.type = type
        self.body = body
        self.channel = channel
        self.to = to
        self.sender = sender
        self.recipient_count = recipient_count
        self.id = id
        self.origin = origin
        self.raw = raw</code></pre>
</details>
</dd>
<dt id="socialization.bot.MessageType"><code class="flex name class">
<span>class <span class="ident">MessageType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>This is enumeration of message types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessageType(Enum):
    &#34;&#34;&#34;
    This is enumeration of message types.
    &#34;&#34;&#34;
    TEXT = 1
    IMAGE = 2
    FILE = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="socialization.bot.MessageType.FILE"><code class="name">var <span class="ident">FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="socialization.bot.MessageType.IMAGE"><code class="name">var <span class="ident">IMAGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="socialization.bot.MessageType.TEXT"><code class="name">var <span class="ident">TEXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="socialization" href="../index.html">socialization</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="socialization.bot.base_bot" href="base_bot.html">socialization.bot.base_bot</a></code></li>
<li><code><a title="socialization.bot.json_socket_user" href="json_socket_user.html">socialization.bot.json_socket_user</a></code></li>
<li><code><a title="socialization.bot.message" href="message.html">socialization.bot.message</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="socialization.bot.BaseBot" href="#socialization.bot.BaseBot">BaseBot</a></code></h4>
<ul class="">
<li><code><a title="socialization.bot.BaseBot.create_channel" href="#socialization.bot.BaseBot.create_channel">create_channel</a></code></li>
<li><code><a title="socialization.bot.BaseBot.fetch_bot_channels" href="#socialization.bot.BaseBot.fetch_bot_channels">fetch_bot_channels</a></code></li>
<li><code><a title="socialization.bot.BaseBot.fetch_channel_command_list" href="#socialization.bot.BaseBot.fetch_channel_command_list">fetch_channel_command_list</a></code></li>
<li><code><a title="socialization.bot.BaseBot.fetch_offline_message" href="#socialization.bot.BaseBot.fetch_offline_message">fetch_offline_message</a></code></li>
<li><code><a title="socialization.bot.BaseBot.fetch_recipients" href="#socialization.bot.BaseBot.fetch_recipients">fetch_recipients</a></code></li>
<li><code><a title="socialization.bot.BaseBot.join_channel" href="#socialization.bot.BaseBot.join_channel">join_channel</a></code></li>
<li><code><a title="socialization.bot.BaseBot.leave_channel" href="#socialization.bot.BaseBot.leave_channel">leave_channel</a></code></li>
<li><code><a title="socialization.bot.BaseBot.login" href="#socialization.bot.BaseBot.login">login</a></code></li>
<li><code><a title="socialization.bot.BaseBot.logout" href="#socialization.bot.BaseBot.logout">logout</a></code></li>
<li><code><a title="socialization.bot.BaseBot.on_close" href="#socialization.bot.BaseBot.on_close">on_close</a></code></li>
<li><code><a title="socialization.bot.BaseBot.on_error" href="#socialization.bot.BaseBot.on_error">on_error</a></code></li>
<li><code><a title="socialization.bot.BaseBot.on_message" href="#socialization.bot.BaseBot.on_message">on_message</a></code></li>
<li><code><a title="socialization.bot.BaseBot.on_open" href="#socialization.bot.BaseBot.on_open">on_open</a></code></li>
<li><code><a title="socialization.bot.BaseBot.on_receive_command" href="#socialization.bot.BaseBot.on_receive_command">on_receive_command</a></code></li>
<li><code><a title="socialization.bot.BaseBot.on_receive_message" href="#socialization.bot.BaseBot.on_receive_message">on_receive_message</a></code></li>
<li><code><a title="socialization.bot.BaseBot.on_receive_status" href="#socialization.bot.BaseBot.on_receive_status">on_receive_status</a></code></li>
<li><code><a title="socialization.bot.BaseBot.register" href="#socialization.bot.BaseBot.register">register</a></code></li>
<li><code><a title="socialization.bot.BaseBot.reset_password" href="#socialization.bot.BaseBot.reset_password">reset_password</a></code></li>
<li><code><a title="socialization.bot.BaseBot.run" href="#socialization.bot.BaseBot.run">run</a></code></li>
<li><code><a title="socialization.bot.BaseBot.send_message" href="#socialization.bot.BaseBot.send_message">send_message</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="socialization.bot.JSONSocketUser" href="#socialization.bot.JSONSocketUser">JSONSocketUser</a></code></h4>
<ul class="two-column">
<li><code><a title="socialization.bot.JSONSocketUser.create_connection" href="#socialization.bot.JSONSocketUser.create_connection">create_connection</a></code></li>
<li><code><a title="socialization.bot.JSONSocketUser.on_close" href="#socialization.bot.JSONSocketUser.on_close">on_close</a></code></li>
<li><code><a title="socialization.bot.JSONSocketUser.on_error" href="#socialization.bot.JSONSocketUser.on_error">on_error</a></code></li>
<li><code><a title="socialization.bot.JSONSocketUser.on_message" href="#socialization.bot.JSONSocketUser.on_message">on_message</a></code></li>
<li><code><a title="socialization.bot.JSONSocketUser.on_open" href="#socialization.bot.JSONSocketUser.on_open">on_open</a></code></li>
<li><code><a title="socialization.bot.JSONSocketUser.on_receive_command" href="#socialization.bot.JSONSocketUser.on_receive_command">on_receive_command</a></code></li>
<li><code><a title="socialization.bot.JSONSocketUser.on_receive_message" href="#socialization.bot.JSONSocketUser.on_receive_message">on_receive_message</a></code></li>
<li><code><a title="socialization.bot.JSONSocketUser.on_receive_other" href="#socialization.bot.JSONSocketUser.on_receive_other">on_receive_other</a></code></li>
<li><code><a title="socialization.bot.JSONSocketUser.on_receive_status" href="#socialization.bot.JSONSocketUser.on_receive_status">on_receive_status</a></code></li>
<li><code><a title="socialization.bot.JSONSocketUser.run" href="#socialization.bot.JSONSocketUser.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="socialization.bot.Message" href="#socialization.bot.Message">Message</a></code></h4>
</li>
<li>
<h4><code><a title="socialization.bot.MessageType" href="#socialization.bot.MessageType">MessageType</a></code></h4>
<ul class="">
<li><code><a title="socialization.bot.MessageType.FILE" href="#socialization.bot.MessageType.FILE">FILE</a></code></li>
<li><code><a title="socialization.bot.MessageType.IMAGE" href="#socialization.bot.MessageType.IMAGE">IMAGE</a></code></li>
<li><code><a title="socialization.bot.MessageType.TEXT" href="#socialization.bot.MessageType.TEXT">TEXT</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>