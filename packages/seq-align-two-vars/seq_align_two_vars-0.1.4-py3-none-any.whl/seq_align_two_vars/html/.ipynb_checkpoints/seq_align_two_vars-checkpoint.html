<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>seq_align_two_vars API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>seq_align_two_vars</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import pandas as pd
import networkx as nx
from matplotlib import pyplot as plt
from sklearn.cluster import AgglomerativeClustering
from scipy.cluster.hierarchy import dendrogram

def sim_func(a,b):
    &#34;&#34;&#34;
    default sim func to be pass in 

    Args:
        a: first item
        b: second item

    Returns:
        int: 1 if equal else -1
    
    
    Example:
    
    ```python
    sim_func(&#34;a&#34;, &#34;b&#34;)
    ```
    Return -1
    &#34;&#34;&#34;
    if a == b:
        return 1
    else:
        return -1
    
def distance(val):
    if val &gt; 0:
        return 0
    else:
        return -val
    
def pretty_print(matrix):
    print(&#39;\n&#39;.join([&#39;\t&#39;.join([str(cell) for cell in row]) for row in matrix]))
    print(&#39;\n&#39;)
    
    
# examples:
#citation networks

# To create data:
# 1. use make_sample
# 2. read in datafile
# 3. input networks, generate random walk data

# return: Dataframe with each row is an observation
# length &gt; 3
def make_sample(length, category, size, var = 2, prob = None, distribution = np.random.rand, var_len=False):
    sample = []
    leng = length
    for k in range(size):
        if var_len == True:
            leng = np.random.randint(3, length)
        cate_lst = []
        lst = [cate_lst]
        for i in range(var):
            x = distribution(size = leng + 1)
            lst.append(x)

        for i in range(leng):
            if prob != None:
                cur = category[np.random.choice(np.arange(len(category)), p=prob)]
            else:
                cur = category[np.random.randint(0, len(category))]
            cate_lst.append(cur)
        sample.append(lst)
    return normalize(pd.DataFrame(sample, columns= [&#34;category&#34;] + [str(i+1) for i in range(var)]))

def read_data(filename, column_name, category_index = 0):
    if &#34;parquet.gzip&#34; in filename:
        df = pd.read_parquet(filename, columns = column_name)
    elif &#34;csv&#34; in filename:
        df = pd.read_csv(filename, names= column_name)
    elif &#34;json&#34; in filename:
        df = pd.read_json(filename, names= column_name)
    elif &#34;excel&#34; in filename:
        df = pd.read_excel(filename, names= column_name)
    else:
        df = pd.read_data(filename, names= column_name)
    dct = {}
    count = 1
    for i in range(len(column_name)):
        if  i == category_index:
            dct[column_name[i]] = &#34;category&#34;
        else:
            dct[column_name[i]] = count
            count += 1
    df.rename(columns = dct, inplace=True)
    df = df[[&#39;category&#39;] + [ col for col in df.columns if col != &#39;category&#39;]]
    return df

#normalized 
def normalize(df):
    for i in df.columns:
        if i != &#34;category&#34;:
            min_ = 100000000000000000
            max_ = 0
            for j, row in df.iterrows():
                for num in row[i]:
                    if num &gt; max_:
                        max_ = num
                    if num &lt; min_:
                        min_ = num
            lst = []
            for j, row in df.iterrows():
                tmp = []
                for num in row[i]:
                    tmp.append(round((num - min_) / (max_ - min_), 4))
                lst.append(tmp)
            
            df[i] = lst
    return df

#only work with random variable now

#weighted edge and node network
#logistic network
def random_walk(G, walk_len, count, var=2, distribution=None):
    walks = []
    for i in range(count):
        cur_node = random.choice(list(G.nodes))
        lst = [[cur_node]]
        for j in range(1, walk_len):
            neigh = list(G.neighbors(cur_node))
            if neigh:
                neighbor = random.choice(neigh)   # choose one random neighbor
                lst[0].append(neighbor)   # add it to walk
                cur_node = neighbor   # save it to cur_node to continue from it next iteration
            else:
                break
        for j in range(var):
            if distribution == &#34;normal&#34;:
                x = np.random.normal(size = len(lst[0]) + 1)
                x = (x - x.min()) / (x.max() - x.min())
                x = np.delete(x, np.where(x == 0))
                x = np.delete(x, np.where(x == 1))
                lst.append(x)
            else:
                x = np.random.rand(len(lst[0]) - 1)
                lst.append(x)
        walks.append(lst)
    return pd.DataFrame(walks, columns= [&#34;category&#34;] + [str(i+1) for i in range(var)])

def get_cmap(n, name=&#39;hsv&#39;):
    &#39;&#39;&#39;Returns a function that maps each index in 0, 1, ..., n-1 to a distinct 
    RGB color; the keyword argument name must be a standard mpl colormap name.&#39;&#39;&#39;
    return plt.cm.get_cmap(name, n)

#TODO: edge length not thickness
def draw(df, sample, color = &#34;hsv&#34;):
    # only work for var = 2, best suitable to show data inteprated as time and dis
    # color example: {&#34;A&#34;: &#34;r&#34;, &#34;B&#34;: &#34;y&#34;, &#34;C&#34;: &#34;g&#34;, &#34;D&#34;:&#34;b&#34;} or cmap
    
    G=nx.DiGraph()
    X = df.loc[sample][0]
    X1 = df.loc[sample][1]
    X2 = df.loc[sample][2]
    
    if isinstance(color, dict) == False:
        tmp = np.unique(np.array(X))
        cmap = get_cmap(len(tmp)+1, name = color)
        color = {}
        for i in range(len(tmp)):
            color[tmp[i]] = cmap(i)
        
    plt.figure(1,figsize=(2.5 * len(X),2)) 

    node_size = []
    for i in range(len(X) - 1):
        node_size.append(1000 + 10000 * float(X1[i]))
    node_size.append(1000)
    
    node_color = []
    width = []
    sum_dis = 0
    for i in range(len(X)):
        if i == 0:
            G.add_node(i, pos = (0,1))
        elif i != len(X) - 1:
            diss = (np.sqrt(node_size[i]/31400)-np.sqrt(2000/31400) + np.sqrt(node_size[i-1]/31400)-np.sqrt(2000/31400))**2
            sum_dis = sum_dis + diss + 1
            G.add_node(i, pos = (sum_dis,1))
        else:
            G.add_node(i, pos = (sum_dis+1,1))
        node_color.append(color[X[i]])
    
    edge_labels = {}
    for i in range(len(X) - 1):
        G.add_edge(i, i+1, len= 1)
        edge_labels[(i, i+1)] = round(float(X2[i]),2)
        width.append(0.2+float(X2[i]) * 10)
    pos=nx.get_node_attributes(G,&#39;pos&#39;)
    
    labeldict = {}
    
    for i in range(len(X) - 1):
        labeldict[i] = X[i] + &#34;\n&#34; + str(round(float(X2[i]),2))
    labeldict[i+1] = X[i+1]
    
    nx.draw(G,pos, labels = labeldict, node_size = node_size, width = width, node_color = node_color, edge_color = &#39;b&#39;)
    
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)
    
    plt.show()
    
def com_draw(df, lst, color = None):
    for x in lst:
        draw(df, x, color = color)
    
def propogate_matrix_global_two_vars(X, Y, X1, Y1, X2, Y2, ratio, gap_score, align_score, proportion):
    X1 = np.insert(X1, 0, 0)
    X2 = np.insert(X2, 0, 0)
    Y1 = np.insert(Y1, 0, 0)
    Y2 = np.insert(Y2, 0, 0)
    
    value_matrix = [[0 for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    source_matrix = [[[0, 0] for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    source_gap_score = [[0 for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    need_constant_gap = [[0 for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    
    need_constant_gap[0][0] = 1
    
    for j in range(len(Y)+1):
        for i in range(len(X)+1):
            if j == 0 and i == 0:
                continue
            # For the global approach, the first row and column involves the time penalties
            # of adding in a gap of a given length to the beginning of either sequence.
            elif j == 0:
                above_score = update_gap_two_vars(i - 1, j, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;above&#34;)
                above_value = value_matrix[i-1][j] - gap_score * need_constant_gap[i-1][j] + source_gap_score[i-1][j] * proportion - above_score[0] * proportion
                    
                value_matrix[i][j] = above_value
                source_matrix[i][j] = [i - 1,j]
                source_gap_score[i][j] = above_score[0]
                need_constant_gap[i][j] = 0
            elif i == 0:
                left_score = update_gap_two_vars(i, j - 1, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;left&#34;)
                left_value = value_matrix[i][j-1] - gap_score * need_constant_gap[i][j-1] + source_gap_score[i][j-1] * proportion - left_score[0] * proportion
                    
                value_matrix[i][j] = left_value
                source_matrix[i][j] = [i,j-1]
                source_gap_score[i][j] = left_score[0]
                need_constant_gap[i][j] = 0
            else:
                score = align_score(X[i-1], Y[j-1])
                
                diag_score = update_gap_two_vars(i-1, j-1, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;diag&#34;)
                diag_value = value_matrix[i-1][j-1] + score + source_gap_score[i-1][j-1] * proportion- diag_score[0] * proportion
                    
                left_score = update_gap_two_vars(i, j-1, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;left&#34;)
                left_value = value_matrix[i][j-1] - gap_score * need_constant_gap[i][j-1] + source_gap_score[i][j-1] * proportion - left_score[0] * proportion
                
                above_score = update_gap_two_vars(i-1, j, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;above&#34;)
                above_value = value_matrix[i-1][j] - gap_score * need_constant_gap[i-1][j] + source_gap_score[i-1][j] * proportion - above_score[0] * proportion
                
                max_score = max(diag_value, left_value, above_value)
                value_matrix[i][j] = max_score
                if diag_value == max_score:
                    source_matrix[i][j] = [i -1, j-1]
                    source_gap_score[i][j] = 0
                    need_constant_gap[i][j] = 1
                elif left_value == max_score:
                    source_matrix[i][j] = [i,j-1]
                    if left_score[1] or above_score[1]:
                        source_gap_score[i][j] = 0
                        need_constant_gap[i][j] = 1
                    else:
                        source_gap_score[i][j] = left_score[0]
                        need_constant_gap[i][j] = 0
                else:
                    source_matrix[i][j] = [i -1,j]
                    if left_score[1] or above_score[1]:
                        source_gap_score[i][j] = 0
                        need_constant_gap[i][j] = 1
                    else:
                        source_gap_score[i][j] = above_score[0]
                        need_constant_gap[i][j] = 0
    # pretty_print(value_matrix)
    return value_matrix[len(X)][len(Y)]

def propogate_matrix_local_two_vars(X, Y, X1, Y1, X2, Y2, ratio, gap_score, align_score, proportion):
    X1 = np.insert(X1, 0, 0)
    X2 = np.insert(X2, 0, 0)
    Y1 = np.insert(Y1, 0, 0)
    Y2 = np.insert(Y2, 0, 0)
    
    value_matrix = [[0 for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    source_matrix = [[[0, 0] for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    source_gap_score = [[0 for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    need_constant_gap = [[0 for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    
    need_constant_gap[0][0] = 1
    
    for j in range(1, len(Y)+1):
        for i in range(1, len(X)+1):
            score = align_score(X[i-1], Y[j-1])

            diag_score = update_gap_two_vars(i-1, j-1, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;diag&#34;)
            diag_value = value_matrix[i-1][j-1] + score + source_gap_score[i-1][j-1] * proportion- diag_score[0] * proportion

            left_score = update_gap_two_vars(i, j-1, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;left&#34;)
            left_value = value_matrix[i][j-1] - gap_score * need_constant_gap[i][j-1] + source_gap_score[i][j-1] * proportion - left_score[0] * proportion

            above_score = update_gap_two_vars(i-1, j, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;above&#34;)
            above_value = value_matrix[i-1][j] - gap_score * need_constant_gap[i-1][j] + source_gap_score[i-1][j] * proportion - above_score[0] * proportion

            max_score = max(diag_value, left_value, above_value, 0)
            value_matrix[i][j] = max_score
            if diag_value == max_score or max_score == 0:
                source_matrix[i][j] = [i-1, j-1]
                source_gap_score[i][j] = 0
                need_constant_gap[i][j] = 1
            elif left_value == max_score:
                source_matrix[i][j] = [i,j-1]
                if left_score[1] or above_score[1]:
                    source_gap_score[i][j] = 0
                    need_constant_gap[i][j] = 1
                else:
                    source_gap_score[i][j] = left_score[0]
                    need_constant_gap[i][j] = 0
            else:
                source_matrix[i][j] = [i -1,j]
                if left_score[1] or above_score[1]:
                    source_gap_score[i][j] = 0
                    need_constant_gap[i][j] = 1
                else:
                    source_gap_score[i][j] = above_score[0]
                    need_constant_gap[i][j] = 0
    # pretty_print(value_matrix)
    return value_matrix[len(X)][len(Y)]

# ratio 0-1, X/Y1 * ratio + X/Y2 * (1-ratio)
def update_gap_two_vars(row_index, column_index, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, direction):
    # This means we are dealing with a value alongside the edge.
    if row_index == 0 or column_index == 0:
        return [abs(sum(X1[0:row_index+1]) - sum(Y1[0:column_index+1])) * ratio + abs(sum(X2[0:row_index+1]) - sum(Y2[0:column_index+1])) * (1-ratio), 0]
    # This means this value came from our diagonal direction.
    elif source_matrix[row_index][column_index][0] &lt; row_index and source_matrix[row_index][column_index][1] &lt; column_index:
        if direction == &#34;left&#34;:
            return [Y1[column_index] * ratio + Y2[column_index] * (1-ratio), 0]
        elif direction == &#34;above&#34;:
            return [X1[row_index] * ratio + X2[row_index] * (1-ratio), 0]
        else:
            return [abs(X1[row_index] - Y1[column_index]) * ratio + abs(X2[row_index] - Y2[column_index]) * (1-ratio), 0]
    # In this case, this value came from a downward movement, meaning an extended gap in the y-direction.
    elif source_matrix[row_index][column_index][0] &lt; row_index:
        # This means that our best choice is a &#39;zigzag&#39; movement.  So, we need to have the algorithm
        # reset the gap score, since we are now going to deal with a gap in the other sequence.
        if direction == &#34;left&#34;:
            return [abs(source_gap_score[row_index][column_index] - Y1[column_index] * ratio - Y2[column_index] * (1-ratio)), 1]
        elif direction == &#34;above&#34;:
            return [source_gap_score[row_index][column_index] + X1[row_index] * ratio + X2[row_index] * (1-ratio), 0]
        else:
            return [abs(source_gap_score[row_index][column_index] + (X1[row_index] - Y1[column_index]) * ratio + (X2[row_index] - Y2[column_index]) * (1-ratio)), 0]
    # In this case, this value came from a rightward movement, meaning an extended gap in the x-direction.
    elif source_matrix[row_index][column_index][1] &lt; column_index:
        if direction == &#34;left&#34;:
            return [source_gap_score[row_index][column_index] + Y1[column_index] * ratio + Y2[column_index] * (1-ratio), 0]
        # This means that our best choice is a &#39;zigzag&#39; movement.  So, we need to have the algorithm
        # reset the gap score, since we are now going to deal with a gap in the other sequence.
        elif direction == &#34;above&#34;:
            return [abs(source_gap_score[row_index][column_index] - X1[row_index] * ratio - X2[row_index] * (1-ratio)), 1]
        else:
            return [abs(source_gap_score[row_index][column_index] + (Y1[column_index ] - X1[row_index])*ratio + (Y2[column_index] - X2[row_index]) * (1-ratio)), 0]
        
#analysis
def distance_metric(df, treat_dis = True):
    dist = np.zeros((len(df),len(df)))
    for i in range(len(df)):
        for j in range(i+1, len(df)):
            dis = propogate_matrix_global_two_vars(df.loc[i][&#34;category&#34;], df.loc[j][&#34;category&#34;], df.loc[i][&#34;1&#34;], df.loc[j][&#34;1&#34;], df.loc[i][&#34;2&#34;], df.loc[j][&#34;2&#34;], 0.5, 1, sim_func, 2)
            if treat_dis:
                dis = distance(dis)
            dist[i][j] = dis
            dist[j][i] = dis
    return dist

def neighbours(dis, target, thres):
    count = 0
    lst = []
    for x in dis[target]:
        if x &lt; thres &amp; count != target:
            lst.append(count)
        count += 1
    return lst

def plot_dendrogram(model, **kwargs):
    # Create linkage matrix and then plot the dendrogram

    # create the counts of samples under each node
    counts = np.zeros(model.children_.shape[0])
    n_samples = len(model.labels_)
    for i, merge in enumerate(model.children_):
        current_count = 0
        for child_idx in merge:
            if child_idx &lt; n_samples:
                current_count += 1  # leaf node
            else:
                current_count += counts[child_idx - n_samples]
        counts[i] = current_count

    linkage_matrix = np.column_stack(
        [model.children_, model.distances_, counts]
    ).astype(float)

    # Plot the corresponding dendrogram
    dendrogram(linkage_matrix, **kwargs)
    
def cluster(dis, distance = None, n_clusters = None):
    model = AgglomerativeClustering(affinity=&#34;precomputed&#34;, distance_threshold=distance,n_clusters=n_clusters, linkage=&#34;average&#34;, compute_distances=True)
    model = model.fit(dis)
    return model

def count(model):
    labels = np.array(model.labels_)
    unique, counts = np.unique(labels, return_counts=True)
    return unique, counts</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="seq_align_two_vars.cluster"><code class="name flex">
<span>def <span class="ident">cluster</span></span>(<span>dis, distance=None, n_clusters=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cluster(dis, distance = None, n_clusters = None):
    model = AgglomerativeClustering(affinity=&#34;precomputed&#34;, distance_threshold=distance,n_clusters=n_clusters, linkage=&#34;average&#34;, compute_distances=True)
    model = model.fit(dis)
    return model</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.com_draw"><code class="name flex">
<span>def <span class="ident">com_draw</span></span>(<span>df, lst, color=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def com_draw(df, lst, color = None):
    for x in lst:
        draw(df, x, color = color)</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>model)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(model):
    labels = np.array(model.labels_)
    unique, counts = np.unique(labels, return_counts=True)
    return unique, counts</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance(val):
    if val &gt; 0:
        return 0
    else:
        return -val</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.distance_metric"><code class="name flex">
<span>def <span class="ident">distance_metric</span></span>(<span>df, treat_dis=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance_metric(df, treat_dis = True):
    dist = np.zeros((len(df),len(df)))
    for i in range(len(df)):
        for j in range(i+1, len(df)):
            dis = propogate_matrix_global_two_vars(df.loc[i][&#34;category&#34;], df.loc[j][&#34;category&#34;], df.loc[i][&#34;1&#34;], df.loc[j][&#34;1&#34;], df.loc[i][&#34;2&#34;], df.loc[j][&#34;2&#34;], 0.5, 1, sim_func, 2)
            if treat_dis:
                dis = distance(dis)
            dist[i][j] = dis
            dist[j][i] = dis
    return dist</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>df, sample, color='hsv')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(df, sample, color = &#34;hsv&#34;):
    # only work for var = 2, best suitable to show data inteprated as time and dis
    # color example: {&#34;A&#34;: &#34;r&#34;, &#34;B&#34;: &#34;y&#34;, &#34;C&#34;: &#34;g&#34;, &#34;D&#34;:&#34;b&#34;} or cmap
    
    G=nx.DiGraph()
    X = df.loc[sample][0]
    X1 = df.loc[sample][1]
    X2 = df.loc[sample][2]
    
    if isinstance(color, dict) == False:
        tmp = np.unique(np.array(X))
        cmap = get_cmap(len(tmp)+1, name = color)
        color = {}
        for i in range(len(tmp)):
            color[tmp[i]] = cmap(i)
        
    plt.figure(1,figsize=(2.5 * len(X),2)) 

    node_size = []
    for i in range(len(X) - 1):
        node_size.append(1000 + 10000 * float(X1[i]))
    node_size.append(1000)
    
    node_color = []
    width = []
    sum_dis = 0
    for i in range(len(X)):
        if i == 0:
            G.add_node(i, pos = (0,1))
        elif i != len(X) - 1:
            diss = (np.sqrt(node_size[i]/31400)-np.sqrt(2000/31400) + np.sqrt(node_size[i-1]/31400)-np.sqrt(2000/31400))**2
            sum_dis = sum_dis + diss + 1
            G.add_node(i, pos = (sum_dis,1))
        else:
            G.add_node(i, pos = (sum_dis+1,1))
        node_color.append(color[X[i]])
    
    edge_labels = {}
    for i in range(len(X) - 1):
        G.add_edge(i, i+1, len= 1)
        edge_labels[(i, i+1)] = round(float(X2[i]),2)
        width.append(0.2+float(X2[i]) * 10)
    pos=nx.get_node_attributes(G,&#39;pos&#39;)
    
    labeldict = {}
    
    for i in range(len(X) - 1):
        labeldict[i] = X[i] + &#34;\n&#34; + str(round(float(X2[i]),2))
    labeldict[i+1] = X[i+1]
    
    nx.draw(G,pos, labels = labeldict, node_size = node_size, width = width, node_color = node_color, edge_color = &#39;b&#39;)
    
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)
    
    plt.show()</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.get_cmap"><code class="name flex">
<span>def <span class="ident">get_cmap</span></span>(<span>n, name='hsv')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a function that maps each index in 0, 1, &hellip;, n-1 to a distinct
RGB color; the keyword argument name must be a standard mpl colormap name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cmap(n, name=&#39;hsv&#39;):
    &#39;&#39;&#39;Returns a function that maps each index in 0, 1, ..., n-1 to a distinct 
    RGB color; the keyword argument name must be a standard mpl colormap name.&#39;&#39;&#39;
    return plt.cm.get_cmap(name, n)</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.make_sample"><code class="name flex">
<span>def <span class="ident">make_sample</span></span>(<span>length, category, size, var=2, prob=None, distribution=&lt;built-in method rand of numpy.random.mtrand.RandomState object&gt;, var_len=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_sample(length, category, size, var = 2, prob = None, distribution = np.random.rand, var_len=False):
    sample = []
    leng = length
    for k in range(size):
        if var_len == True:
            leng = np.random.randint(3, length)
        cate_lst = []
        lst = [cate_lst]
        for i in range(var):
            x = distribution(size = leng + 1)
            lst.append(x)

        for i in range(leng):
            if prob != None:
                cur = category[np.random.choice(np.arange(len(category)), p=prob)]
            else:
                cur = category[np.random.randint(0, len(category))]
            cate_lst.append(cur)
        sample.append(lst)
    return normalize(pd.DataFrame(sample, columns= [&#34;category&#34;] + [str(i+1) for i in range(var)]))</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.neighbours"><code class="name flex">
<span>def <span class="ident">neighbours</span></span>(<span>dis, target, thres)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neighbours(dis, target, thres):
    count = 0
    lst = []
    for x in dis[target]:
        if x &lt; thres &amp; count != target:
            lst.append(count)
        count += 1
    return lst</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>df)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(df):
    for i in df.columns:
        if i != &#34;category&#34;:
            min_ = 100000000000000000
            max_ = 0
            for j, row in df.iterrows():
                for num in row[i]:
                    if num &gt; max_:
                        max_ = num
                    if num &lt; min_:
                        min_ = num
            lst = []
            for j, row in df.iterrows():
                tmp = []
                for num in row[i]:
                    tmp.append(round((num - min_) / (max_ - min_), 4))
                lst.append(tmp)
            
            df[i] = lst
    return df</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.plot_dendrogram"><code class="name flex">
<span>def <span class="ident">plot_dendrogram</span></span>(<span>model, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_dendrogram(model, **kwargs):
    # Create linkage matrix and then plot the dendrogram

    # create the counts of samples under each node
    counts = np.zeros(model.children_.shape[0])
    n_samples = len(model.labels_)
    for i, merge in enumerate(model.children_):
        current_count = 0
        for child_idx in merge:
            if child_idx &lt; n_samples:
                current_count += 1  # leaf node
            else:
                current_count += counts[child_idx - n_samples]
        counts[i] = current_count

    linkage_matrix = np.column_stack(
        [model.children_, model.distances_, counts]
    ).astype(float)

    # Plot the corresponding dendrogram
    dendrogram(linkage_matrix, **kwargs)</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>matrix)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(matrix):
    print(&#39;\n&#39;.join([&#39;\t&#39;.join([str(cell) for cell in row]) for row in matrix]))
    print(&#39;\n&#39;)</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.propogate_matrix_global_two_vars"><code class="name flex">
<span>def <span class="ident">propogate_matrix_global_two_vars</span></span>(<span>X, Y, X1, Y1, X2, Y2, ratio, gap_score, align_score, proportion)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def propogate_matrix_global_two_vars(X, Y, X1, Y1, X2, Y2, ratio, gap_score, align_score, proportion):
    X1 = np.insert(X1, 0, 0)
    X2 = np.insert(X2, 0, 0)
    Y1 = np.insert(Y1, 0, 0)
    Y2 = np.insert(Y2, 0, 0)
    
    value_matrix = [[0 for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    source_matrix = [[[0, 0] for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    source_gap_score = [[0 for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    need_constant_gap = [[0 for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    
    need_constant_gap[0][0] = 1
    
    for j in range(len(Y)+1):
        for i in range(len(X)+1):
            if j == 0 and i == 0:
                continue
            # For the global approach, the first row and column involves the time penalties
            # of adding in a gap of a given length to the beginning of either sequence.
            elif j == 0:
                above_score = update_gap_two_vars(i - 1, j, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;above&#34;)
                above_value = value_matrix[i-1][j] - gap_score * need_constant_gap[i-1][j] + source_gap_score[i-1][j] * proportion - above_score[0] * proportion
                    
                value_matrix[i][j] = above_value
                source_matrix[i][j] = [i - 1,j]
                source_gap_score[i][j] = above_score[0]
                need_constant_gap[i][j] = 0
            elif i == 0:
                left_score = update_gap_two_vars(i, j - 1, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;left&#34;)
                left_value = value_matrix[i][j-1] - gap_score * need_constant_gap[i][j-1] + source_gap_score[i][j-1] * proportion - left_score[0] * proportion
                    
                value_matrix[i][j] = left_value
                source_matrix[i][j] = [i,j-1]
                source_gap_score[i][j] = left_score[0]
                need_constant_gap[i][j] = 0
            else:
                score = align_score(X[i-1], Y[j-1])
                
                diag_score = update_gap_two_vars(i-1, j-1, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;diag&#34;)
                diag_value = value_matrix[i-1][j-1] + score + source_gap_score[i-1][j-1] * proportion- diag_score[0] * proportion
                    
                left_score = update_gap_two_vars(i, j-1, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;left&#34;)
                left_value = value_matrix[i][j-1] - gap_score * need_constant_gap[i][j-1] + source_gap_score[i][j-1] * proportion - left_score[0] * proportion
                
                above_score = update_gap_two_vars(i-1, j, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;above&#34;)
                above_value = value_matrix[i-1][j] - gap_score * need_constant_gap[i-1][j] + source_gap_score[i-1][j] * proportion - above_score[0] * proportion
                
                max_score = max(diag_value, left_value, above_value)
                value_matrix[i][j] = max_score
                if diag_value == max_score:
                    source_matrix[i][j] = [i -1, j-1]
                    source_gap_score[i][j] = 0
                    need_constant_gap[i][j] = 1
                elif left_value == max_score:
                    source_matrix[i][j] = [i,j-1]
                    if left_score[1] or above_score[1]:
                        source_gap_score[i][j] = 0
                        need_constant_gap[i][j] = 1
                    else:
                        source_gap_score[i][j] = left_score[0]
                        need_constant_gap[i][j] = 0
                else:
                    source_matrix[i][j] = [i -1,j]
                    if left_score[1] or above_score[1]:
                        source_gap_score[i][j] = 0
                        need_constant_gap[i][j] = 1
                    else:
                        source_gap_score[i][j] = above_score[0]
                        need_constant_gap[i][j] = 0
    # pretty_print(value_matrix)
    return value_matrix[len(X)][len(Y)]</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.propogate_matrix_local_two_vars"><code class="name flex">
<span>def <span class="ident">propogate_matrix_local_two_vars</span></span>(<span>X, Y, X1, Y1, X2, Y2, ratio, gap_score, align_score, proportion)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def propogate_matrix_local_two_vars(X, Y, X1, Y1, X2, Y2, ratio, gap_score, align_score, proportion):
    X1 = np.insert(X1, 0, 0)
    X2 = np.insert(X2, 0, 0)
    Y1 = np.insert(Y1, 0, 0)
    Y2 = np.insert(Y2, 0, 0)
    
    value_matrix = [[0 for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    source_matrix = [[[0, 0] for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    source_gap_score = [[0 for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    need_constant_gap = [[0 for x in range(len(Y) + 1)] for x in range(len(X) + 1)]
    
    need_constant_gap[0][0] = 1
    
    for j in range(1, len(Y)+1):
        for i in range(1, len(X)+1):
            score = align_score(X[i-1], Y[j-1])

            diag_score = update_gap_two_vars(i-1, j-1, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;diag&#34;)
            diag_value = value_matrix[i-1][j-1] + score + source_gap_score[i-1][j-1] * proportion- diag_score[0] * proportion

            left_score = update_gap_two_vars(i, j-1, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;left&#34;)
            left_value = value_matrix[i][j-1] - gap_score * need_constant_gap[i][j-1] + source_gap_score[i][j-1] * proportion - left_score[0] * proportion

            above_score = update_gap_two_vars(i-1, j, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, &#34;above&#34;)
            above_value = value_matrix[i-1][j] - gap_score * need_constant_gap[i-1][j] + source_gap_score[i-1][j] * proportion - above_score[0] * proportion

            max_score = max(diag_value, left_value, above_value, 0)
            value_matrix[i][j] = max_score
            if diag_value == max_score or max_score == 0:
                source_matrix[i][j] = [i-1, j-1]
                source_gap_score[i][j] = 0
                need_constant_gap[i][j] = 1
            elif left_value == max_score:
                source_matrix[i][j] = [i,j-1]
                if left_score[1] or above_score[1]:
                    source_gap_score[i][j] = 0
                    need_constant_gap[i][j] = 1
                else:
                    source_gap_score[i][j] = left_score[0]
                    need_constant_gap[i][j] = 0
            else:
                source_matrix[i][j] = [i -1,j]
                if left_score[1] or above_score[1]:
                    source_gap_score[i][j] = 0
                    need_constant_gap[i][j] = 1
                else:
                    source_gap_score[i][j] = above_score[0]
                    need_constant_gap[i][j] = 0
    # pretty_print(value_matrix)
    return value_matrix[len(X)][len(Y)]</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.random_walk"><code class="name flex">
<span>def <span class="ident">random_walk</span></span>(<span>G, walk_len, count, var=2, distribution=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_walk(G, walk_len, count, var=2, distribution=None):
    walks = []
    for i in range(count):
        cur_node = random.choice(list(G.nodes))
        lst = [[cur_node]]
        for j in range(1, walk_len):
            neigh = list(G.neighbors(cur_node))
            if neigh:
                neighbor = random.choice(neigh)   # choose one random neighbor
                lst[0].append(neighbor)   # add it to walk
                cur_node = neighbor   # save it to cur_node to continue from it next iteration
            else:
                break
        for j in range(var):
            if distribution == &#34;normal&#34;:
                x = np.random.normal(size = len(lst[0]) + 1)
                x = (x - x.min()) / (x.max() - x.min())
                x = np.delete(x, np.where(x == 0))
                x = np.delete(x, np.where(x == 1))
                lst.append(x)
            else:
                x = np.random.rand(len(lst[0]) - 1)
                lst.append(x)
        walks.append(lst)
    return pd.DataFrame(walks, columns= [&#34;category&#34;] + [str(i+1) for i in range(var)])</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.read_data"><code class="name flex">
<span>def <span class="ident">read_data</span></span>(<span>filename, column_name, category_index=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_data(filename, column_name, category_index = 0):
    if &#34;parquet.gzip&#34; in filename:
        df = pd.read_parquet(filename, columns = column_name)
    elif &#34;csv&#34; in filename:
        df = pd.read_csv(filename, names= column_name)
    elif &#34;json&#34; in filename:
        df = pd.read_json(filename, names= column_name)
    elif &#34;excel&#34; in filename:
        df = pd.read_excel(filename, names= column_name)
    else:
        df = pd.read_data(filename, names= column_name)
    dct = {}
    count = 1
    for i in range(len(column_name)):
        if  i == category_index:
            dct[column_name[i]] = &#34;category&#34;
        else:
            dct[column_name[i]] = count
            count += 1
    df.rename(columns = dct, inplace=True)
    df = df[[&#39;category&#39;] + [ col for col in df.columns if col != &#39;category&#39;]]
    return df</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.sim_func"><code class="name flex">
<span>def <span class="ident">sim_func</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<div class="desc"><p>default sim func to be pass in </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a</code></strong></dt>
<dd>first item</dd>
<dt><strong><code>b</code></strong></dt>
<dd>second item</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>1 if equal else -1</dd>
</dl>
<p>Example:</p>
<pre><code class="language-python">sim_func(&quot;a&quot;, &quot;b&quot;)
</code></pre>
<p>Return -1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sim_func(a,b):
    &#34;&#34;&#34;
    default sim func to be pass in 

    Args:
        a: first item
        b: second item

    Returns:
        int: 1 if equal else -1
    
    
    Example:
    
    ```python
    sim_func(&#34;a&#34;, &#34;b&#34;)
    ```
    Return -1
    &#34;&#34;&#34;
    if a == b:
        return 1
    else:
        return -1</code></pre>
</details>
</dd>
<dt id="seq_align_two_vars.update_gap_two_vars"><code class="name flex">
<span>def <span class="ident">update_gap_two_vars</span></span>(<span>row_index, column_index, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, direction)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_gap_two_vars(row_index, column_index, source_matrix, X1, Y1, X2, Y2, ratio, source_gap_score, direction):
    # This means we are dealing with a value alongside the edge.
    if row_index == 0 or column_index == 0:
        return [abs(sum(X1[0:row_index+1]) - sum(Y1[0:column_index+1])) * ratio + abs(sum(X2[0:row_index+1]) - sum(Y2[0:column_index+1])) * (1-ratio), 0]
    # This means this value came from our diagonal direction.
    elif source_matrix[row_index][column_index][0] &lt; row_index and source_matrix[row_index][column_index][1] &lt; column_index:
        if direction == &#34;left&#34;:
            return [Y1[column_index] * ratio + Y2[column_index] * (1-ratio), 0]
        elif direction == &#34;above&#34;:
            return [X1[row_index] * ratio + X2[row_index] * (1-ratio), 0]
        else:
            return [abs(X1[row_index] - Y1[column_index]) * ratio + abs(X2[row_index] - Y2[column_index]) * (1-ratio), 0]
    # In this case, this value came from a downward movement, meaning an extended gap in the y-direction.
    elif source_matrix[row_index][column_index][0] &lt; row_index:
        # This means that our best choice is a &#39;zigzag&#39; movement.  So, we need to have the algorithm
        # reset the gap score, since we are now going to deal with a gap in the other sequence.
        if direction == &#34;left&#34;:
            return [abs(source_gap_score[row_index][column_index] - Y1[column_index] * ratio - Y2[column_index] * (1-ratio)), 1]
        elif direction == &#34;above&#34;:
            return [source_gap_score[row_index][column_index] + X1[row_index] * ratio + X2[row_index] * (1-ratio), 0]
        else:
            return [abs(source_gap_score[row_index][column_index] + (X1[row_index] - Y1[column_index]) * ratio + (X2[row_index] - Y2[column_index]) * (1-ratio)), 0]
    # In this case, this value came from a rightward movement, meaning an extended gap in the x-direction.
    elif source_matrix[row_index][column_index][1] &lt; column_index:
        if direction == &#34;left&#34;:
            return [source_gap_score[row_index][column_index] + Y1[column_index] * ratio + Y2[column_index] * (1-ratio), 0]
        # This means that our best choice is a &#39;zigzag&#39; movement.  So, we need to have the algorithm
        # reset the gap score, since we are now going to deal with a gap in the other sequence.
        elif direction == &#34;above&#34;:
            return [abs(source_gap_score[row_index][column_index] - X1[row_index] * ratio - X2[row_index] * (1-ratio)), 1]
        else:
            return [abs(source_gap_score[row_index][column_index] + (Y1[column_index ] - X1[row_index])*ratio + (Y2[column_index] - X2[row_index]) * (1-ratio)), 0]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="seq_align_two_vars.cluster" href="#seq_align_two_vars.cluster">cluster</a></code></li>
<li><code><a title="seq_align_two_vars.com_draw" href="#seq_align_two_vars.com_draw">com_draw</a></code></li>
<li><code><a title="seq_align_two_vars.count" href="#seq_align_two_vars.count">count</a></code></li>
<li><code><a title="seq_align_two_vars.distance" href="#seq_align_two_vars.distance">distance</a></code></li>
<li><code><a title="seq_align_two_vars.distance_metric" href="#seq_align_two_vars.distance_metric">distance_metric</a></code></li>
<li><code><a title="seq_align_two_vars.draw" href="#seq_align_two_vars.draw">draw</a></code></li>
<li><code><a title="seq_align_two_vars.get_cmap" href="#seq_align_two_vars.get_cmap">get_cmap</a></code></li>
<li><code><a title="seq_align_two_vars.make_sample" href="#seq_align_two_vars.make_sample">make_sample</a></code></li>
<li><code><a title="seq_align_two_vars.neighbours" href="#seq_align_two_vars.neighbours">neighbours</a></code></li>
<li><code><a title="seq_align_two_vars.normalize" href="#seq_align_two_vars.normalize">normalize</a></code></li>
<li><code><a title="seq_align_two_vars.plot_dendrogram" href="#seq_align_two_vars.plot_dendrogram">plot_dendrogram</a></code></li>
<li><code><a title="seq_align_two_vars.pretty_print" href="#seq_align_two_vars.pretty_print">pretty_print</a></code></li>
<li><code><a title="seq_align_two_vars.propogate_matrix_global_two_vars" href="#seq_align_two_vars.propogate_matrix_global_two_vars">propogate_matrix_global_two_vars</a></code></li>
<li><code><a title="seq_align_two_vars.propogate_matrix_local_two_vars" href="#seq_align_two_vars.propogate_matrix_local_two_vars">propogate_matrix_local_two_vars</a></code></li>
<li><code><a title="seq_align_two_vars.random_walk" href="#seq_align_two_vars.random_walk">random_walk</a></code></li>
<li><code><a title="seq_align_two_vars.read_data" href="#seq_align_two_vars.read_data">read_data</a></code></li>
<li><code><a title="seq_align_two_vars.sim_func" href="#seq_align_two_vars.sim_func">sim_func</a></code></li>
<li><code><a title="seq_align_two_vars.update_gap_two_vars" href="#seq_align_two_vars.update_gap_two_vars">update_gap_two_vars</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>