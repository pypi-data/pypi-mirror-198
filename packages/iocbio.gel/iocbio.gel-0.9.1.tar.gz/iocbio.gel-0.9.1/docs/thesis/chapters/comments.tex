This section provides analysis of the development process and an overview of important elements in the technology stack, with commentary on specific aspects during development that involved significant decisions or affected flow of development.

\section{Domain Knowledge}
At the time of choosing this topic for the thesis, we had little knowledge about protein determination methods and processes, how/what applications are used to perform analysis, and why. As we started working on the project and having meetings with the project owners, we received some details on the current way of processing gel images and their shortcomings. However, our understanding of how some features should work or relate to the processes was partially faulty for some aspects, which required some rework down the line. This may have been mitigated with more detailed communication and development of clearer specifications, and by periodically releasing partial versions of the applications for the project owner to test specific aspects of workflows. More thorough research into the backgrounds of the algorithms and motivations behind the methods, stepping into the scientist's shoes, may have also helped for some implementations.

\section{Project Management}

Two main causes were identified that contributed to a significant enough time delay and eventually resulted in cutting some features out of the scope - communication and external time management.

Although the features initially planned for the start of the project were simplistic, the authors spent a lot of time familiarizing themselves with the framework, libraries, and exact requirements of the project, but they did not take enough time to agree on development practices and communicate their specific implementation details before developing those features. This resulted in an initial codebase where duplication was hard to spot and rectify because of three varying styles of implementation - most of which required refactoring later on. 

It was an open discussion on whether or not the authors should have tried to more specialize in developing different aspects of the application. This would have perhaps decreased the combined time that was spent on individually learning all the frameworks and libraries. It would have also forced a stricter initial structure for the software and exposed the need to improve communication between the authors. Unfortunately, due to circumstances, the authors were able to work on the project on differing days of the week, and the communication overhead felt more like a blocker. Additionally, the initial development effort was placed on creating the different application views, and so at the time it made sense to focus everyone on creating vertical slices of the software.

Secondly, external time constraints were not properly taken into account in project management during the second half of the project. The authors were too optimistic in estimating their capabilities or available time and realized fairly late that the project scope should be reprioritized.

The project management process failed to properly identify which of the external time sinks were recurring in their nature and which were one-time events. This made planning issues for upcoming sprints more difficult. A strategy to cope with this was adopted in form of splitting the issues even smaller so it would be possible to pick them up more readily in an ad-hoc manner. It helped a little but was not a sufficient solution. When a developer fell behind on their input, the situation was compounded by the additional need to familiarize themselves with changes done in the software in the meanwhile. As a remedy, perhaps implementing pair-programming sessions would have helped, but the need for this was not communicated clearly at the time.

\section{Curved Lanes}
One of the initial requirements for the application, curved lanes, was eventually found to be notably difficult to implement, and therefore not implemented within the current scope. There was one idea of how it may be done relatively easily, using the MultiRectROI widget. It was a ready-made widget that allowed chaining together multiple rectangular ROIs at variable angles and would've provided a single concatenated array of image data, much like a regular ROI for easy usage \cite{multi-rect-roi}. The issue with it was that the ROIs when connected at angles, overlapped with each other at one side and left a gap on the other, which wouldn't have been the desired result. Other ideas revolved around creating polygonal ROIs that joined edge-to-edge and could have curved edges or simply two curved lines (PyQtGraph offers methods to implement curved lines using the PlotCurveItem class \cite{plot-curve-item}) from which the region data would be calculated with a custom-made algorithm, staying perpendicular to the centerline. Both of those ideas would have needed to solve the issue of curving causing one side to have fewer pixels than the other, meaning each rectangular row of pixels had to expand into a circular arc from the shorter line to and along with the longer. We had little idea of how to properly/most efficiently implement this and feared it would eat up too much time, so in the face of time constraints, we decided to drop it.

\section{Qt}
Using the Qt framework for our application was considered a given since it was desired by the project owner and deemed standard for the problem domain and user base. Since we were unfamiliar with the framework and making standard desktop applications, the rate of feature development was affected. It was difficult to tell if opting for a more familiar web-based app paradigm would've decreased initial friction and allowed us to implement more features, as some of the libraries for image processing and plotting might've been hard to find mature and feature-equivalent versions for. Performance implications were also considered, as some image processing algorithms are slow even in the current implementation. Visuals of the application may have been significantly better though, as Hypertext Markup Language (HTML) / Cascading Style Sheets (CSS) pages are easier to customize.

\section{Python}
We had the option to either use C++ or Python with a wrapper library for Qt, and we chose the latter due to familiarity and perceived ease of development when compared to the former. While the application might've been more performant on C++, the extra layer of unfamiliarity with the language, its lack of memory management, and fewer batteries-included libraries with usable widgets like PyQtGraph and skimage would have most likely increased the learning curve and development time for the same set of features significantly. The overall performance of the application, even with the overhead of Python, is good, with one exception being the background subtraction algorithm, which is implemented differently from its ImageJ equivalent.

\section{Application Architecture}
During the later stages of development, the authors found out about Qt's Model-View\footnote{https://doc.qt.io/qt-6/model-view-programming.html} system, which may have benefited the project significantly. Having a separate model object to more conveniently map the database entities and allow for easy state sharing across view components may have made implementing and maintaining some aspects, like Create, Read, Update, Delete (CRUD) tables for measurements and lanes, easier.
The documentation for it wasn't very in-depth, however, so the question of how to properly encode more complex views like graphs and integrate with other libraries remained and may have been too much of an undertaking by that stage of development.

\section{Alternative Image Sources}
Not nearly enough was done to support alternative image sources, as it was the case for adding databases. There is an interface \emph{select\_image.py}\footnote{iocbio/gel/gui/dialogs/select\_image.py} for implementing the visual dialog component which is shown to the user when attempting to select or change an image. But, since fetching images from a local folder didn't require managing a connection, a common interface for such a client was not created. As such, the first steps for implementing a new image source would be to follow the implementation and usage of the \emph{omero\_client.py}\footnote{iocbio/gel/application/image\_source/omero\_client.py} class and separate image source specifics from the shared interface.
