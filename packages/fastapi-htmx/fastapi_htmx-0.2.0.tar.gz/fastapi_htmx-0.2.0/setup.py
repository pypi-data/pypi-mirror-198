# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['fastapi_htmx']

package_data = \
{'': ['*']}

modules = \
['py']
install_requires = \
['fastapi>=0.94,<0.95', 'jinja2>=3.1,<4.0']

setup_kwargs = {
    'name': 'fastapi-htmx',
    'version': '0.2.0',
    'description': 'Extension for FastAPI to make HTMX easier to use.',
    'long_description': '# FastAPI-HTMX\n\nExtension for FastAPI to make HTMX easier to use.\n\nFastAPI-HTMX is an opinionated extension for FastAPI to speed up development of lightly interactive web applications. FastAPI-HTMX is implemented as a decorator, so it can be used on endpoints selectively. Furthermore it reduces boilerplate for Jinja2 template handling and allows for rapid prototyping by providing convenient helpers.\n\n\n## Install\n\ninstall via `pip`:\n```\n$ pip install fastapi-htmx\n```\n\ninstall via `poetry`:\n```\n$ poetry add fastapi-htmx\n```\n\n\n## Usage\n\n### Getting Started\n\nBasic example using FastAPI with `fastapi-htmx`\n\n`my_app/api.py`:\n```python\nfrom pathlib import Path\n\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.templating import Jinja2Templates\nfrom fastapi_htmx import htmx, htmx_init\n\napp = FastAPI()\nhtmx_init(templates=Jinja2Templates(directory=Path("my_app") / "templates"))\n\n@app.get("/", response_class=HTMLResponse)\n@htmx("index", "index")\nasync def root_page(request: Request):\n    return {"greeting": "Hello World"}\n\n@app.get("/customers", response_class=HTMLResponse)\n@htmx("customers")\nasync def get_customers(request: Request):\n    return {"customers": ["John Doe", "Jane Doe"]}\n```\n\nNote that:\n- `htmx()` got parameters, specifying the Jinja2 template to use\n- `htmx_init()` is needed for FastAPI-HTMX to find the templates\n- **There is no direct handling of the template needed, it only needs to be specified and the needed variables need to be returned**. This way endpoints can be designed in a familiar way to standard REST endpoints in FastAPI.\n    - This simplifies modularizing the app later (see below) and also providing a REST API if needed. See the "Usage" section for further examples.\n    - `get_customers` does not respond with the whole web page, but only with a part of it. See the [HTMX documentation](https://htmx.org/docs/#introduction) on how HTMX merges partials into the current web page.\n- **`request: Request` although not used in the endpoint directly, it is currently required for the decorator to work!**\n\nThe [Jinja2 templates](https://jinja.palletsprojects.com/en/3.1.x/templates/) to go along with the above code need to be placed like specified in `htmx_init` in `my_app/templates/` in order for the example to work.\n\nThe root page `my_app/templates/index.jinja2`:\n```jinja2\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Hello FastAPI-HTMX</title>\n</head>\n<body>\n    <h1>{{ greeting }}</h1>\n    <button\n        hx-get="/customers"\n        hx-swap="innerHTML"\n        hx-target="#customers_list"\n    >\n        Load Data\n    </button>\n    <div id="customers_list"></div>\n    <script src="https://unpkg.com/htmx.org@1.8.5"></script>\n</body>\n</html>\n```\n\nThe [partial template to load with HTMX](https://htmx.org/docs/#introduction) `my_app/templates/customers.jinja2`:\n```jinja2\n<ul>\n    {% for customer in customers %}\n        <li>{{ customer }}</li>\n    {% endfor %}\n</ul>\n```\n\n\n### Main Concept\n\nThe decorator `htmx` provides the following helpers:\n\n- `partial_template_name` The partial template to use\n- `full_template_name` The full page template to use when URL rewriting + history is used\n- `*_template_constructor` For DRY code, in case the logic to gather all needed variables is needed multiple times\n\nSeeing these arguments one might ask themselves: Why all these parameters? The answer is an opinionated take on how to design modular endpoints wit partials and url-rewriting support:\n\nThe idea behind FastAPI-HTMX is to maintain a modular structure in the app and with the endpoints. Similar to a REST API with a [SPA](https://developer.mozilla.org/en-US/docs/Glossary/SPA). This way the frontend can be modular as well. This majorly helps with supporting [URL rewriting and the history](https://htmx.org/docs/#history) in the frontend:\n\n- A simple endpoint just answers with the partial.\n- Without it, if the URL is rewritten and a user navigates back, reloads the page or copies the URL and opens it in another tab or shares the URL, only the partial would be shown in the browser.\n\n**To enable SPA like functionality FastAPI-HTMX uses the concept of partials and fullpages as arguments for the decorator and requires to return a dict of the needed variables**.\n\nIn order to support this in an app, see the following example:\n\n`my_app/api_with_constructors.py`:\n```python\nfrom pathlib import Path\n\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.templating import Jinja2Templates\nfrom fastapi_htmx import htmx, htmx_init\n\napp = FastAPI()\nhtmx_init(templates=Jinja2Templates(directory=Path("my_app") / "templates"))\n\ndef construct_customers():\n    return {"customers": ["John Doe", "Jane Doe"]}\n\ndef construct_root_page():\n    return {\n        "greeting": "Hello World",\n        **construct_customers()\n    }\n\n@app.get("/", response_class=HTMLResponse)\n@htmx("index", "index")\nasync def root_page(request: Request):\n    return construct_root_page()\n\n@app.get("/customers", response_class=HTMLResponse)\n@htmx("customers", "index", construct_customers, construct_root_page)\nasync def get_customers(request: Request):\n    pass\n```\n\nNote that:\n- The `construct_*` functions are added, they now return the data\n    - **`construct_root_page` gathers all variables specified needed for the root page, including those for partials**\n        - **This also means you must avoid naming conflicts across endpoints, so dicts can be merged.**\n        - Costly operations can still be ignored, just use if statements in the template or similar\n- The decorators arguments are extended\n    - The second argument is the fullpage template which is used when the endpoint is called directly (new tab, navigation or reload)\n        - **E.g. since `construct_root_page` gathers all the data for the whole page, the whole page can be returned to the client**\n    - The other arguments are just to save some boilerplate code handling the [`HX-Request` header](https://htmx.org/attributes/hx-push-url/)\n        - **There is no need to use the arguments for the constructor functions, they are just for convenience.** If needed the endpoint can be used for the logic as well. Especially if no URL rewriting is needed.\n\nFor the above code to work the `my_app/templates/index.jinja2` needs to be changed as well. The changes are in the button and target div.\nChanged root page `my_app/templates/index.jinja2`:\n```jinja2\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Hello FastAPI-HTMX</title>\n</head>\n<body>\n    <h1>{{ greeting }}</h1>\n    <button\n        hx-get="/customers"\n        hx-push-url="true"\n        hx-swap="innerHTML"\n        hx-target="#customers_list"\n    >\n        Load Data\n    </button>\n    <div id="customers_list">\n        {% include \'customers.jinja2\' %}\n    </div>\n    <script src="https://unpkg.com/htmx.org@1.8.6"></script>\n</body>\n</html>\n```\n\nNote that:\n- `hx-push-url="true"` was added to the button\n- The partial is now loaded by default requiring the main endpoint to also provide the needed variables like shown above\n\nThe unchanged partial `my_app/templates/customers.jinja2`:\n```jinja2\n<ul>\n    {% for customer in customers %}\n        <li>{{ customer }}</li>\n    {% endfor %}\n</ul>\n```\n\nTo add additional partials and endpoints just repeat the same logic:\n- Include the partial in the parent Jinja2 template, like the main template. A hierarchy is possible as well.\n- Refactor the partials endpoints logic into a function\n    - Add it\'s return value to the parents constructor function like done above in `construct_root_page`\n    - Add the parents template and constructor function to the partials endpoints `htmx` decorator arguments\n\n\n### Advanced Usage\n\nIn case the `htmx()` arguments for partial and fullpage callables are not flexible enough, an endpoint can be used like usual. For a bit more convenience the `HX-Request` header is easily accessible via `request.hx_request`:\n\n```python\nfrom fastapi_htmx import HXRequest, htmx, htmx_init\n\n@htmx("email_detail", "index")\ndef get_email(request: HXRequest, email_id: int):\n    if request.hx_request:\n        return my_partial()\n    else:\n        return fullpage()\n```\n\n#### Filters\n\nIn order to use [custom Jinja2 filters](https://jinja.palletsprojects.com/en/3.1.x/api/#custom-filters) like the following, configure them like below.\n\n```Jinja2\n<p>{{ customer.created|datetime_format }}</p>\n```\n\nAdd custom filters for use in Jinja2 templates:\n```python\n# ...\ndef datetime_format(value: datetime, format="%H:%M %d.%m.%Y"):\n    return value.strftime(format) if value is not None else ""\n\ntemplates = Jinja2Templates(directory=Path("my_app") / "templates")\ntemplates.env.filters["datetime_format"] = datetime_format\nhtmx_init(templates=templates)\n# ...\n```\n',
    'author': 'maces',
    'author_email': 'fastapi-htmx@mzip.de',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/maces/fastapi-htmx',
    'packages': packages,
    'package_data': package_data,
    'py_modules': modules,
    'install_requires': install_requires,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
