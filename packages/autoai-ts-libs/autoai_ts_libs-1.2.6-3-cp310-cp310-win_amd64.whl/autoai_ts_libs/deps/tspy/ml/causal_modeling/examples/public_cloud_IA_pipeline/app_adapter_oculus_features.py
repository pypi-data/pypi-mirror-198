#  /************** Begin Copyright - Do not add comments here **************
#   * Licensed Materials - Property of IBM
#   *
#   *   OCO Source Materials
#   *
#   *   (C) Copyright IBM Corp. 2020, All Rights Reserved
#   *
#   * The source code for this program is not published or other-
#   * wise divested of its trade secrets, irrespective of what has
#   * been deposited with the U.S. Copyright Office.
#   ***************************** End Copyright ****************************/

"""
This is an implementation of autoai_ts_libs.deps.tspy.ml.causal_modeling.algorithms.csd_input_adapters.InputAdapterRawToEncoded
to handle Oculus alerts (OA). OA are anomaly events generated by an AIOps underlay network.
The implementation provides functions to read OA sequences, to encode them in one-hot vectors, and
to save/load them from files.
"""

from autoai_ts_libs.deps.tspy.ml.causal_modeling.algorithms.csd_input_adapters import InputAdapterRawToEncoded
import lazy_import
import collections
import numpy as np
import json
import pickle

word_tokenize = lazy_import.lazy_callable("nltk.tokenize.word_tokenize")

# v1 keys
SERVICE_KEY = 'service'
RESOURCE_KEY = 'resource'
EVENT_KEY = 'event'
TEXT_KEY = 'text'
TEXTFIELD_TAKE_NCHARS = 30
RESOURCEFIELD_TAKE_NCHARS = 3
# v2 keys
REGION_KEY = 'region'
DATACENTER_KEY = 'datacenter'
SEVERITY_KEY = 'severity'
TIMEDELTA_KEY = 'timedelta'


class appAdapterOculusFeatures(InputAdapterRawToEncoded):
    """ Extracts multi-one-hot features from json formatted Oculus features. Multiple feature versions supported.
    """

    def __init__(self, feature_version='v4', verbose=True, encoder_dicts=None, *argv, **kwargs):
        """
        """
        super().__init__(*argv, **kwargs)
        self.version_to_func_map = {'v4': self.encode_one_oculus_alert_v4,
                                    'v3': self.encode_one_oculus_alert_v3,
                                    'v2': self.encode_one_oculus_alert_v2,
                                    'v1': self.encode_one_oculus_alert_v1}
        if feature_version not in self.version_to_func_map:
            raise ValueError("ERROR: requested feature version %s is not supported (supported versions: %s)" %
                             (feature_version, ",".join(list(self.version_to_func_map.keys()))))
        self.feature_version = feature_version
        self.verbose = verbose
        self.verbose_prefix = self.__class__.__name__
        self.encoder_dicts = encoder_dicts  # set in fit()

    # main public method
    def fit(self, alerts):
        """
        Sets up feature codebooks, will overwrite any preexisting ones.
        Args:
            alerts:

        Returns:

        """
        self.encoder_dicts = self.generate_lookup_dicts(alerts=alerts, encoder_version=self.feature_version,
                                                        verbose=self.verbose)
        return self.encoder_dicts

    # main public method
    def encode(self, alerts, id_field='id'):
        """
        Given a list of raw alerts, generates a list of feature vectors via an encoder specified at initialization.
        Args:
            alerts: list of Oculus alert (json format)
            id_field: string specifying the key within the json to retrieve a unique alert id

        Returns:
            list of feature vectors [nalerts, feadim], array of alert ids corresponding to the feature vectors,
                        description of a feature vector (segments with their dimensionality)
        """
        return self.generate_static_features(alerts, id_field=id_field)


    def get_encoder_params(self):
        return self.encoder_dicts

    def load(self, f):
        if hasattr(f, 'read'):
            self.encoder_dicts = json.load(f)
        elif isinstance(f, str):
            if f.endswith('json'):
                with open(f, 'rt') as f:
                    self.encoder_dicts = json.load(f)
            else:  # could be legacy pickle
                with open(f, 'rb') as f:
                    self.encoder_dicts = pickle.load(f)
                    if self.verbose: print("WARN: Pickle encoder dict format is obsolete!")
        else:
            raise ValueError("%s (ERROR): unsupported handle type %s" % (self.verbose_prefix, type(f)))

    def save(self, f):
        if self.encoder_dicts is None:
            raise RuntimeError("%s (ERROR): Save request failed. Encoder parameters not set." % self.verbose_prefix)
        if hasattr(f, 'write'):
            json.dump(self.encoder_dicts, f, indent=4)
        elif isinstance(f, str):
            with open(f, 'wt') as of:
                json.dump(self.encoder_dicts, of, indent=4)
        else:
            raise ValueError("%s (ERROR): unsupported handle type %s" % (self.verbose_prefix, type(f)))

    @staticmethod
    def my_tokenize(s):
        numstr = '$NUM'
        os = []
        for w in word_tokenize(s):
            if any([str.isdigit(c) for c in w]):
                os.append(numstr)
            else:
                os.append(w)
        return os

    @staticmethod
    def encode_via_dict(entry, d):
        """
        Helper for entry lookup in a dict
        :param entry: key to lookup
        :param d: dict to look in (dict values should be unique indexes in [0, len(dict)-1]
        :return: value if entry found, len(dict) if not found (designated 'null' code)
        """
        return d[entry] if entry in d else len(d.keys())

    @staticmethod
    def encode_one_oculus_alert_v1(alert, master_dict, text_preproc_fct=my_tokenize,
                                   generate_descr=False):
        """
        Apply manual rules to extract static features for a single alert that came via the Oculus REST API
        :param alert:
        :return: a vector of encoded entries (plus optional descr vector, if generate_descr==True)
        """

        descr = []  # holds feature description (list of tuples)
        service_dict = master_dict[SERVICE_KEY]
        resource_dicts = master_dict[RESOURCE_KEY]
        event_dict = master_dict[EVENT_KEY]
        text_dict = master_dict[TEXT_KEY]
        # ------- Feature 1: "service" is a cardinality 4 set lookup
        key = SERVICE_KEY
        assert (len(service_dict) > 0 and key in alert)
        service_fea = appAdapterOculusFeatures.encode_via_dict(alert[key][0],
                                                               service_dict)  # service is a list, so take the first element here
        if generate_descr: descr.append(('discrete', len(service_dict.keys()) + 1))

        # ------- Feature 2: "resource" . split this one into three chunks, normalize/trucate and encode
        key = RESOURCE_KEY
        take_nchars = RESOURCEFIELD_TAKE_NCHARS  # take first chars of each block
        assert (len(resource_dicts) == 5 and key in alert)
        resval = alert[key].split('.')
        # -> first chunk
        # resource_fea_1 = encode_via_dict(resval[0], resource_dicts[0])   # full  # note non-truncated chunk 1 fea omitted!
        resource_fea_1t = appAdapterOculusFeatures.encode_via_dict(resval[0][:take_nchars],
                                                                   resource_dicts[0])  # truncated
        if generate_descr:  descr.append(('discrete', len(resource_dicts[0].keys()) + 1))
        # -> second chunk
        if len(resval) > 1:
            resource_fea_2 = appAdapterOculusFeatures.encode_via_dict(resval[1], resource_dicts[1])
            resource_fea_2t = appAdapterOculusFeatures.encode_via_dict(resval[1][:take_nchars], resource_dicts[2])
        else:
            resource_fea_2 = len(resource_dicts[1].keys())  # designated NA
            resource_fea_2t = len(resource_dicts[2].keys())  # designated NA
        if generate_descr:  descr.append(('discrete', len(resource_dicts[1].keys()) + 1))
        if generate_descr:  descr.append(('discrete', len(resource_dicts[2].keys()) + 1))
        # -> third chunk
        if len(resval) > 2:
            resource_fea_3 = appAdapterOculusFeatures.encode_via_dict(resval[2], resource_dicts[3])
            resource_fea_3t = appAdapterOculusFeatures.encode_via_dict(resval[2][:take_nchars], resource_dicts[4])
        else:
            resource_fea_3 = len(resource_dicts[3].keys())  # designated NA
            resource_fea_3t = len(resource_dicts[4].keys())  # designated NA
        if generate_descr:  descr.append(('discrete', len(resource_dicts[3].keys()) + 1))
        if generate_descr:  descr.append(('discrete', len(resource_dicts[4].keys()) + 1))

        # ------ Feature 3: event, example MLAG-INTF_INACTIVE_PEER_LINK_DOWN. Encode (card. ~ 200)
        key = EVENT_KEY
        assert (len(event_dict) > 0 and key in alert)
        event_fea = appAdapterOculusFeatures.encode_via_dict(alert[key], event_dict)
        if generate_descr:  descr.append(('discrete', len(event_dict.keys()) + 1))

        # ------ Feature 4: text, example 'The MLAG peer is down. MLAG 48 became inactive.', Tokenize and encode card ~200
        key = TEXT_KEY
        text_nchars = TEXTFIELD_TAKE_NCHARS  # take first chars
        assert (len(text_dict) > 0 and key in alert)
        txt = ' '.join(text_preproc_fct(alert[key]))
        text_fea = appAdapterOculusFeatures.encode_via_dict(txt[:text_nchars], text_dict)
        if generate_descr:  descr.append(('discrete', len(text_dict.keys()) + 1))

        fea_final = [service_fea, resource_fea_1t, resource_fea_2, resource_fea_2t, resource_fea_3, resource_fea_3t,
                     event_fea, text_fea]
        # Final feature vector
        if generate_descr:
            return fea_final, descr
        else:
            return fea_final

    @staticmethod
    def encode_one_oculus_alert_v2(alert, master_dict,
                                   text_preproc_fct=my_tokenize,
                                   generate_descr=False):
        """
        Apply manual rules to extract static features for a single alert that came via the Oculus database dump
        :param alert:
        :return: a vector of encoded entries (plus optional descr vector, if generate_descr==True)
        """
        descr = []  # holds feature description (list of tuples)
        F = []  # stores features

        # process the simple features (that require no special handling)
        for key in [REGION_KEY, DATACENTER_KEY, SERVICE_KEY, EVENT_KEY, SEVERITY_KEY, TIMEDELTA_KEY]:
            if key == TIMEDELTA_KEY and TIMEDELTA_KEY not in master_dict:
                continue
            d = master_dict[key]
            if key not in alert:
                raise RuntimeError("ERROR: the key \'%s\' (needed for format %s) not found in the alert object" %
                                   (key, 'v2'))
            assert (len(d) > 0)
            val = alert[key] if key != SERVICE_KEY else alert[key][0]
            F.append(appAdapterOculusFeatures.encode_via_dict(val, d))
            if generate_descr:  descr.append(('discrete', len(d.keys()) + 1))

        # ------- Feature: "resource" . split this one into three chunks, normalize/trucate and encode
        key = RESOURCE_KEY
        take_nchars = RESOURCEFIELD_TAKE_NCHARS  # take first chars of each block
        resource_dicts = master_dict[key]
        assert (len(resource_dicts) == 5 and key in alert)
        resval = alert[key].split('.')
        # -> first chunk
        # resource_fea_1 = encode_via_dict(resval[0], resource_dicts[0])   # full  # note non-truncated chunk 1 fea omitted!
        resource_fea_1t = appAdapterOculusFeatures.encode_via_dict(resval[0][:take_nchars],
                                                                   resource_dicts[0])  # truncated
        if generate_descr:  descr.append(('discrete', len(resource_dicts[0].keys()) + 1))
        # -> second chunk
        if len(resval) > 1:
            resource_fea_2 = appAdapterOculusFeatures.encode_via_dict(resval[1], resource_dicts[1])
            resource_fea_2t = appAdapterOculusFeatures.encode_via_dict(resval[1][:take_nchars], resource_dicts[2])
        else:
            resource_fea_2 = len(resource_dicts[1].keys())  # designated NA
            resource_fea_2t = len(resource_dicts[2].keys())  # designated NA
        if generate_descr:  descr.append(('discrete', len(resource_dicts[1].keys()) + 1))
        if generate_descr:  descr.append(('discrete', len(resource_dicts[2].keys()) + 1))
        # -> third chunk
        if len(resval) > 2:
            resource_fea_3 = appAdapterOculusFeatures.encode_via_dict(resval[2], resource_dicts[3])
            resource_fea_3t = appAdapterOculusFeatures.encode_via_dict(resval[2][:take_nchars], resource_dicts[4])
        else:
            resource_fea_3 = len(resource_dicts[3].keys())  # designated NA
            resource_fea_3t = len(resource_dicts[4].keys())  # designated NA
        if generate_descr:  descr.append(('discrete', len(resource_dicts[3].keys()) + 1))
        if generate_descr:  descr.append(('discrete', len(resource_dicts[4].keys()) + 1))
        F.append(resource_fea_1t)
        F.append(resource_fea_2)
        F.append(resource_fea_2t)
        F.append(resource_fea_3)
        F.append(resource_fea_3t)

        # ------ Feature: text, example 'The MLAG peer is down. MLAG 48 became inactive.', Tokenize and encode card ~200
        key = TEXT_KEY
        text_nchars = TEXTFIELD_TAKE_NCHARS  # take first chars
        text_dict = master_dict[key]
        assert (len(text_dict) > 0 and key in alert)
        txt = ' '.join(text_preproc_fct(alert[key]))
        text_fea = appAdapterOculusFeatures.encode_via_dict(txt[:text_nchars], text_dict)
        F.append(text_fea)
        if generate_descr:  descr.append(('discrete', len(text_dict.keys()) + 1))

        fea_final = F
        # Final feature vector
        if generate_descr:
            return fea_final, descr
        else:
            return fea_final

    @staticmethod
    def encode_one_oculus_alert_v3(alert, master_dict,
                                   text_preproc_fct=my_tokenize,
                                   generate_descr=False):
        """
        Apply manual rules to extract static features for a single alert that came via the Oculus database dump
        and are trimmed for alert prediction.
        :param alert:
        :return: a vector of encoded entries (plus optional descr vector, if generate_descr==True)
        """
        descr = []  # holds feature description (list of tuples)
        F = []  # stores features

        # process the simple features (that require no special handling)
        for key in [EVENT_KEY]:
            if key == TIMEDELTA_KEY and TIMEDELTA_KEY not in master_dict:
                continue
            d = master_dict[key]
            if key not in alert:
                raise RuntimeError("ERROR: the key \'%s\' (needed for format %s) not found in the alert object" %
                                   (key, 'v3'))
            assert (len(d) > 0)
            val = alert[key] if key != SERVICE_KEY else alert[key][0]
            F.append(appAdapterOculusFeatures.encode_via_dict(val, d))
            if generate_descr:  descr.append(('discrete', len(d.keys()) + 1))

        # ------- Feature: "resource" . split this one into three chunks, normalize/truncate and encode
        key = RESOURCE_KEY
        take_nchars = RESOURCEFIELD_TAKE_NCHARS  # take first chars of each block
        resource_dicts = master_dict[key]
        assert (len(resource_dicts) == 5 and key in alert)
        resval = alert[key].split('.')
        # -> first chunk
        # resource_fea_1 = encode_via_dict(resval[0], resource_dicts[0])   # full  # note non-truncated chunk 1 fea omitted!
        resource_fea_1t = appAdapterOculusFeatures.encode_via_dict(resval[0][:take_nchars],
                                                                   resource_dicts[0])  # truncated
        if generate_descr:  descr.append(('discrete', len(resource_dicts[0].keys()) + 1))
        # -> second chunk
        if len(resval) > 1:
            resource_fea_2 = appAdapterOculusFeatures.encode_via_dict(resval[1], resource_dicts[1])
            resource_fea_2t = appAdapterOculusFeatures.encode_via_dict(resval[1][:take_nchars], resource_dicts[2])
        else:
            resource_fea_2 = len(resource_dicts[1].keys())  # designated NA
            resource_fea_2t = len(resource_dicts[2].keys())  # designated NA
        if generate_descr:  descr.append(('discrete', len(resource_dicts[1].keys()) + 1))
        if generate_descr:  descr.append(('discrete', len(resource_dicts[2].keys()) + 1))
        F.append(resource_fea_1t)
        F.append(resource_fea_2)
        F.append(resource_fea_2t)

        fea_final = F
        # Final feature vector
        if generate_descr:
            return fea_final, descr
        else:
            return fea_final

    @staticmethod
    def encode_one_oculus_alert_v4(alert, master_dict,
                                   text_preproc_fct=my_tokenize,
                                   generate_descr=False):
        """
        Apply manual rules to extract static features for a single alert that came via the Oculus database dump
        :param alert:
        :return: a vector of encoded entries (plus optional descr vector, if generate_descr==True)
        """
        descr = []  # holds feature description (list of tuples)
        F = []  # stores features

        # process the simple features (that require no special handling)
        for key in [EVENT_KEY, SEVERITY_KEY]:
            if key == TIMEDELTA_KEY and TIMEDELTA_KEY not in master_dict:
                continue
            d = master_dict[key]
            if key not in alert:
                raise RuntimeError("ERROR: the key \'%s\' (needed for format %s) not found in the alert object" %
                                   (key, 'v2'))
            assert (len(d) > 0)
            val = alert[key] if key != SERVICE_KEY else alert[key][0]
            F.append(appAdapterOculusFeatures.encode_via_dict(val, d))
            if generate_descr:  descr.append(('discrete', len(d.keys()) + 1))

        # ------- Feature: "resource" . split this one into three chunks, normalize/trucate and encode
        key = RESOURCE_KEY
        take_nchars = RESOURCEFIELD_TAKE_NCHARS  # take first chars of each block
        resource_dicts = master_dict[key]
        assert (len(resource_dicts) == 5 and key in alert)
        resval = alert[key].split('.')
        # -> first chunk
        # resource_fea_1 = encode_via_dict(resval[0], resource_dicts[0])   # full  # note non-truncated chunk 1 fea omitted!
        resource_fea_1t = appAdapterOculusFeatures.encode_via_dict(resval[0][:take_nchars],
                                                                    resource_dicts[0])  # truncated
        if generate_descr:  descr.append(('discrete', len(resource_dicts[0].keys()) + 1))
        # -> second chunk
        if len(resval) > 1:
            resource_fea_2 = appAdapterOculusFeatures.encode_via_dict(resval[1], resource_dicts[1])
            resource_fea_2t = appAdapterOculusFeatures.encode_via_dict(resval[1][:take_nchars], resource_dicts[2])
        else:
            resource_fea_2 = len(resource_dicts[1].keys())  # designated NA
            resource_fea_2t = len(resource_dicts[2].keys())  # designated NA
        if generate_descr:  descr.append(('discrete', len(resource_dicts[1].keys()) + 1))
        if generate_descr:  descr.append(('discrete', len(resource_dicts[2].keys()) + 1))
        # -> third chunk
        if len(resval) > 2:
            resource_fea_3 = appAdapterOculusFeatures.encode_via_dict(resval[2], resource_dicts[3])
            resource_fea_3t = appAdapterOculusFeatures.encode_via_dict(resval[2][:take_nchars], resource_dicts[4])
        else:
            resource_fea_3 = len(resource_dicts[3].keys())  # designated NA
            resource_fea_3t = len(resource_dicts[4].keys())  # designated NA
        if generate_descr:  descr.append(('discrete', len(resource_dicts[3].keys()) + 1))
        if generate_descr:  descr.append(('discrete', len(resource_dicts[4].keys()) + 1))
        F.append(resource_fea_1t)
        F.append(resource_fea_2)
        F.append(resource_fea_2t)
        F.append(resource_fea_3)
        F.append(resource_fea_3t)
        fea_final = F
        # Final feature vector
        if generate_descr:
            return fea_final, descr
        else:
            return fea_final

    @staticmethod
    def generate_capped_dict(values, count_floor, verbose=True):
        """
        counts values, sorts by frequency, assigns integer values for all unique values with freq >= count_floor
        :param values: list of values
        :return: dict that can be used for encoding
        """
        assert (count_floor >= 0)
        cnt = collections.Counter(values)
        D = {}
        idx = 0
        for v, n in cnt.most_common(len(cnt)):
            if n > count_floor:
                D[v] = idx
                idx += 1
        if verbose: print("INFO: generate_capped_dict: created a dict with %d entries" % len(D))

        return D

    @staticmethod
    def generate_lookup_dicts(alerts, encoder_version='v1', count_floor=200, verbose=True):
        """
        Creates all dicts necessary to encode/produce features
        :param alerts:
        :return: dicts
        """
        master_dict = {}
        if encoder_version == 'v1':
            master_dict[SERVICE_KEY] = appAdapterOculusFeatures.generate_capped_dict(
                [a[SERVICE_KEY][0] for a in alerts], 0)
            master_dict[EVENT_KEY] = appAdapterOculusFeatures.generate_capped_dict([a[EVENT_KEY] for a in alerts], 0)
        elif encoder_version == 'v2' or encoder_version == 'v3' or encoder_version == 'v4':
            for key in [REGION_KEY, DATACENTER_KEY, SERVICE_KEY, EVENT_KEY, SEVERITY_KEY, TIMEDELTA_KEY]:
                if key == TIMEDELTA_KEY and key not in alerts[0]:
                    continue
                if key == 'service':
                    lst = [a[key][0] for a in alerts]  # service entries are lists, so...
                else:
                    lst = [a[key] for a in alerts]
                master_dict[key] = appAdapterOculusFeatures.generate_capped_dict(lst, count_floor=count_floor,
                                                                                 verbose=verbose)
            if TIMEDELTA_KEY in alerts[0]:
                lst = [a[key] for a in alerts]
                master_dict[key] = appAdapterOculusFeatures.generate_capped_dict(lst, count_floor=1, verbose=verbose)
        else:
            raise ValueError("ERROR: unsupported encoder format %s" % encoder_version)
        # The following are common in v1 & v2:
        # resource (three chunks)
        ch1 = []
        ch2 = []
        ch3 = []
        ch1t = []  # truncated version
        ch2t = []
        ch3t = []
        ntoks = RESOURCEFIELD_TAKE_NCHARS
        for a in alerts:
            reslst = a[RESOURCE_KEY].split('.')
            ch1.append(reslst[0])
            ch1t.append(reslst[0][:ntoks])
            if len(reslst) > 1:
                ch2.append(reslst[1])
                ch2t.append(reslst[1][:ntoks])
            if len(reslst) > 2:
                ch3.append(reslst[2])
                ch3t.append(reslst[2][:ntoks])
        resource_dicts = []
        # resource_dicts.append(generate_capped_dict(ch1, 5))  # this chunk seems not a good feature - omitting
        resource_dicts.append(appAdapterOculusFeatures.generate_capped_dict(ch1t, 5, verbose=verbose))
        resource_dicts.append(appAdapterOculusFeatures.generate_capped_dict(ch2, 5, verbose=verbose))
        resource_dicts.append(appAdapterOculusFeatures.generate_capped_dict(ch2t, 5, verbose=verbose))
        resource_dicts.append(appAdapterOculusFeatures.generate_capped_dict(ch3, 5, verbose=verbose))
        resource_dicts.append(appAdapterOculusFeatures.generate_capped_dict(ch3t, 5, verbose=verbose))
        master_dict[RESOURCE_KEY] = resource_dicts

        # event
        event_dict = appAdapterOculusFeatures.generate_capped_dict([a[EVENT_KEY] for a in alerts], 0, verbose=verbose)
        master_dict[EVENT_KEY] = event_dict

        # text
        text_dict = appAdapterOculusFeatures.generate_capped_dict(
            [(' '.join(appAdapterOculusFeatures.my_tokenize(a[TEXT_KEY])))[:TEXTFIELD_TAKE_NCHARS] for a in alerts], 10,
            verbose=verbose)
        master_dict[TEXT_KEY] = text_dict

        return master_dict

    def generate_static_features(self, alerts, id_field='id'):
        """
        Given a list of raw alerts, generates a list of feature vectors via an encoder specified at initialization.
        Args:
            alerts: list of Oculus alert (json format)
            id_field: string specifying the key within the json to retrieve a unique alert id

        Returns:
            list of feature vectors [nalerts, feadim], array of alert ids corresponding to the feature vectors,
                        description of a feature vector (segments with their dimensionality)
        """
        F = []
        info = []
        assert (isinstance(alerts, list))
        assert (len(alerts) > 0)
        encoder_func = self.version_to_func_map[self.feature_version]
        # get a description first
        dummy, descr = encoder_func(alerts[0], self.encoder_dicts,
                                    text_preproc_fct=appAdapterOculusFeatures.my_tokenize,
                                    generate_descr=True)
        for a in alerts:
            F.append(
                encoder_func(a, self.encoder_dicts, text_preproc_fct=appAdapterOculusFeatures.my_tokenize,
                             generate_descr=False))
            info.append(a[id_field])
        F = np.asarray(F)
        info = np.asarray(info)
        assert (len(F) == len(info))
        if self.verbose:
            print("%s (INFO): Processed %d original alerts" % (self.verbose_prefix, len(alerts)))
        return F, info, descr
